diff -uNrb linux-3.1.9/fs/yaffs2/Kconfig linux-3.1.9-yaffs2/fs/yaffs2/Kconfig
--- linux-3.1.9/fs/yaffs2/Kconfig	2012-06-20 14:51:23.966803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/Kconfig	2012-06-28 16:56:57.727627703 -0600
@@ -1,23 +1,23 @@
 #
-# YAFFS file system configurations
+# yaffs file system configurations
 #
 
 config YAFFS_FS
-	tristate "YAFFS2 file system support"
+	tristate "yaffs2 file system support"
 	default n
 	depends on MTD_BLOCK
 	select YAFFS_YAFFS1
 	select YAFFS_YAFFS2
 	help
-	  YAFFS2, or Yet Another Flash Filing System, is a filing system
+	  yaffs2, or Yet Another Flash File System, is a file system
 	  optimised for NAND Flash chips.
 
-	  To compile the YAFFS2 file system support as a module, choose M
+	  To compile the yaffs2 file system support as a module, choose M
 	  here: the module will be called yaffs2.
 
 	  If unsure, say N.
 
-	  Further information on YAFFS2 is available at
+	  Further information on yaffs2 is available at
 	  <http://www.aleph1.co.uk/yaffs/>.
 
 config YAFFS_YAFFS1
@@ -25,7 +25,7 @@
 	depends on YAFFS_FS
 	default y
 	help
-	  Enable YAFFS1 support -- yaffs for 512 byte / page devices
+	  Enable yaffs1 support -- yaffs for 512 byte / page devices
 
 	  Not needed for 2K-page devices.
 
@@ -49,11 +49,11 @@
 	  If unsure, say N.
 
 config YAFFS_DOES_ECC
-	bool "Lets Yaffs do its own ECC"
+	bool "Lets yaffs do its own ECC"
 	depends on YAFFS_FS && YAFFS_YAFFS1 && !YAFFS_9BYTE_TAGS
 	default n
 	help
-	  This enables Yaffs to use its own ECC functions instead of using
+	  This enables yaffs to use its own ECC functions instead of using
 	  the ones from the generic MTD-NAND driver.
 
 	  If unsure, say N.
@@ -74,7 +74,7 @@
 	depends on YAFFS_FS
 	default y
 	help
-	  Enable YAFFS2 support -- yaffs for >= 2K bytes per page devices
+	  Enable yaffs2 support -- yaffs for >= 2K bytes per page devices
 
 	  If unsure, say Y.
 
@@ -91,11 +91,11 @@
 	  If unsure, say Y.
 
 config YAFFS_DISABLE_TAGS_ECC
-	bool "Disable YAFFS from doing ECC on tags by default"
+	bool "Disable yaffs from doing ECC on tags by default"
 	depends on YAFFS_FS && YAFFS_YAFFS2
 	default n
 	help
-	  This defaults Yaffs to using its own ECC calculations on tags instead of
+	  This defaults yaffs to using its own ECC calculations on tags instead of
 	  just relying on the MTD.
 	  This behavior can also be overridden with tags_ecc_on and
 	  tags_ecc_off mount options.
@@ -107,7 +107,7 @@
 	depends on YAFFS_FS
 	default n
 	help
-          Normally YAFFS only checks chunks before writing until an erased
+          Normally yaffs only checks chunks before writing until an erased
 	  chunk is found. This helps to detect any partially written
 	  chunks that might have happened due to power loss.
 
diff -uNrb linux-3.1.9/fs/yaffs2/Makefile linux-3.1.9-yaffs2/fs/yaffs2/Makefile
--- linux-3.1.9/fs/yaffs2/Makefile	2012-06-20 14:51:23.966803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/Makefile	2012-06-28 16:57:25.295628722 -0600
@@ -6,12 +6,13 @@
 
 yaffs-y := yaffs_ecc.o yaffs_vfs.o yaffs_guts.o yaffs_checkptrw.o
 yaffs-y += yaffs_packedtags1.o yaffs_packedtags2.o yaffs_nand.o
-yaffs-y += yaffs_tagscompat.o yaffs_tagsvalidity.o
+yaffs-y += yaffs_tagscompat.o
 yaffs-y += yaffs_mtdif.o yaffs_mtdif1.o yaffs_mtdif2.o
 yaffs-y += yaffs_nameval.o yaffs_attribs.o
 yaffs-y += yaffs_allocator.o
 yaffs-y += yaffs_yaffs1.o
 yaffs-y += yaffs_yaffs2.o
 yaffs-y += yaffs_bitmap.o
+yaffs-y += yaffs_summary.o
 yaffs-y += yaffs_verify.o
 
diff -uNrb linux-3.1.9/fs/yaffs2/moduleconfig.h linux-3.1.9-yaffs2/fs/yaffs2/moduleconfig.h
--- linux-3.1.9/fs/yaffs2/moduleconfig.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.9-yaffs2/fs/yaffs2/moduleconfig.h	2012-06-28 16:54:39.719622577 -0600
@@ -0,0 +1,27 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Martin Fouts <Martin.Fouts@palmsource.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_CONFIG_H__
+#define __YAFFS_CONFIG_H__
+
+#ifdef YAFFS_OUT_OF_TREE
+
+#define CONFIG_YAFFS_FS
+#define CONFIG_YAFFS_DEBUG
+
+#endif
+
+#endif
+
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_allocator.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_allocator.c
--- linux-3.1.9/fs/yaffs2/yaffs_allocator.c	2012-06-20 14:51:23.966803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_allocator.c	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -16,53 +16,19 @@
 #include "yaffs_trace.h"
 #include "yportenv.h"
 
-#ifdef CONFIG_YAFFS_KMALLOC_ALLOCATOR
-
-void yaffs_deinit_raw_tnodes_and_objs(struct yaffs_dev *dev)
-{
-	dev = dev;
-}
-
-void yaffs_init_raw_tnodes_and_objs(struct yaffs_dev *dev)
-{
-	dev = dev;
-}
-
-struct yaffs_tnode *yaffs_alloc_raw_tnode(struct yaffs_dev *dev)
-{
-	return (struct yaffs_tnode *)kmalloc(dev->tnode_size, GFP_NOFS);
-}
-
-void yaffs_free_raw_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn)
-{
-	dev = dev;
-	kfree(tn);
-}
-
-void yaffs_init_raw_objs(struct yaffs_dev *dev)
-{
-	dev = dev;
-}
-
-void yaffs_deinit_raw_objs(struct yaffs_dev *dev)
-{
-	dev = dev;
-}
-
-struct yaffs_obj *yaffs_alloc_raw_obj(struct yaffs_dev *dev)
-{
-	dev = dev;
-	return (struct yaffs_obj *)kmalloc(sizeof(struct yaffs_obj));
-}
-
-void yaffs_free_raw_obj(struct yaffs_dev *dev, struct yaffs_obj *obj)
-{
-
-	dev = dev;
-	kfree(obj);
-}
-
-#else
+/*
+ * Each entry in yaffs_tnode_list and yaffs_obj_list hold blocks
+ * of approx 100 objects that are themn allocated singly.
+ * This is basically a simplified slab allocator.
+ *
+ * We don't use the Linux slab allocator because slab does not allow
+ * us to dump all the objects in one hit when we do a umount and tear
+ * down  all the tnodes and objects. slab requires that we first free
+ * the individual objects.
+ *
+ * Once yaffs has been mainlined I shall try to motivate for a change
+ * to slab to provide the extra features we need here.
+ */
 
 struct yaffs_tnode_list {
 	struct yaffs_tnode_list *next;
@@ -81,7 +47,7 @@
 	struct yaffs_tnode_list *alloc_tnode_list;
 
 	int n_obj_created;
-	struct yaffs_obj *free_objs;
+	struct list_head free_objs;
 	int n_free_objects;
 
 	struct yaffs_obj_list *allocated_obj_list;
@@ -89,14 +55,12 @@
 
 static void yaffs_deinit_raw_tnodes(struct yaffs_dev *dev)
 {
-
 	struct yaffs_allocator *allocator =
 	    (struct yaffs_allocator *)dev->allocator;
-
 	struct yaffs_tnode_list *tmp;
 
 	if (!allocator) {
-		YBUG();
+		BUG();
 		return;
 	}
 
@@ -106,7 +70,6 @@
 		kfree(allocator->alloc_tnode_list->tnodes);
 		kfree(allocator->alloc_tnode_list);
 		allocator->alloc_tnode_list = tmp;
-
 	}
 
 	allocator->free_tnodes = NULL;
@@ -118,14 +81,15 @@
 {
 	struct yaffs_allocator *allocator = dev->allocator;
 
-	if (allocator) {
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
 		allocator->alloc_tnode_list = NULL;
 		allocator->free_tnodes = NULL;
 		allocator->n_free_tnodes = 0;
 		allocator->n_tnodes_created = 0;
-	} else {
-		YBUG();
-	}
 }
 
 static int yaffs_create_tnodes(struct yaffs_dev *dev, int n_tnodes)
@@ -140,7 +104,7 @@
 	struct yaffs_tnode_list *tnl;
 
 	if (!allocator) {
-		YBUG();
+		BUG();
 		return YAFFS_FAIL;
 	}
 
@@ -148,7 +112,6 @@
 		return YAFFS_OK;
 
 	/* make these things */
-
 	new_tnodes = kmalloc(n_tnodes * dev->tnode_size, GFP_NOFS);
 	mem = (u8 *) new_tnodes;
 
@@ -176,7 +139,6 @@
 	 * NB If we can't add this to the management list it isn't fatal
 	 * but it just means we can't free this bunch of tnodes later.
 	 */
-
 	tnl = kmalloc(sizeof(struct yaffs_tnode_list), GFP_NOFS);
 	if (!tnl) {
 		yaffs_trace(YAFFS_TRACE_ERROR,
@@ -188,7 +150,7 @@
 		allocator->alloc_tnode_list = tnl;
 	}
 
-	yaffs_trace(YAFFS_TRACE_ALLOCATE,"Tnodes added");
+	yaffs_trace(YAFFS_TRACE_ALLOCATE, "Tnodes added");
 
 	return YAFFS_OK;
 }
@@ -200,7 +162,7 @@
 	struct yaffs_tnode *tn = NULL;
 
 	if (!allocator) {
-		YBUG();
+		BUG();
 		return NULL;
 	}
 
@@ -223,7 +185,7 @@
 	struct yaffs_allocator *allocator = dev->allocator;
 
 	if (!allocator) {
-		YBUG();
+		BUG();
 		return;
 	}
 
@@ -235,17 +197,24 @@
 	dev->checkpoint_blocks_required = 0;	/* force recalculation */
 }
 
+/*--------------- yaffs_obj alloaction ------------------------
+ *
+ * Free yaffs_objs are stored in a list using obj->siblings.
+ * The blocks of allocated objects are stored in a linked list.
+ */
+
 static void yaffs_init_raw_objs(struct yaffs_dev *dev)
 {
 	struct yaffs_allocator *allocator = dev->allocator;
 
-	if (allocator) {
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
 		allocator->allocated_obj_list = NULL;
-		allocator->free_objs = NULL;
+	INIT_LIST_HEAD(&allocator->free_objs);
 		allocator->n_free_objects = 0;
-	} else {
-		YBUG();
-	}
 }
 
 static void yaffs_deinit_raw_objs(struct yaffs_dev *dev)
@@ -254,7 +223,7 @@
 	struct yaffs_obj_list *tmp;
 
 	if (!allocator) {
-		YBUG();
+		BUG();
 		return;
 	}
 
@@ -262,11 +231,10 @@
 		tmp = allocator->allocated_obj_list->next;
 		kfree(allocator->allocated_obj_list->objects);
 		kfree(allocator->allocated_obj_list);
-
 		allocator->allocated_obj_list = tmp;
 	}
 
-	allocator->free_objs = NULL;
+	INIT_LIST_HEAD(&allocator->free_objs);
 	allocator->n_free_objects = 0;
 	allocator->n_obj_created = 0;
 }
@@ -274,13 +242,12 @@
 static int yaffs_create_free_objs(struct yaffs_dev *dev, int n_obj)
 {
 	struct yaffs_allocator *allocator = dev->allocator;
-
 	int i;
 	struct yaffs_obj *new_objs;
 	struct yaffs_obj_list *list;
 
 	if (!allocator) {
-		YBUG();
+		BUG();
 		return YAFFS_FAIL;
 	}
 
@@ -292,27 +259,19 @@
 	list = kmalloc(sizeof(struct yaffs_obj_list), GFP_NOFS);
 
 	if (!new_objs || !list) {
-		if (new_objs) {
 			kfree(new_objs);
 			new_objs = NULL;
-		}
-		if (list) {
 			kfree(list);
 			list = NULL;
-		}
 		yaffs_trace(YAFFS_TRACE_ALLOCATE,
 			"Could not allocate more objects");
 		return YAFFS_FAIL;
 	}
 
 	/* Hook them into the free list */
-	for (i = 0; i < n_obj - 1; i++) {
-		new_objs[i].siblings.next =
-		    (struct list_head *)(&new_objs[i + 1]);
-	}
+	for (i = 0; i < n_obj; i++)
+		list_add(&new_objs[i].siblings, &allocator->free_objs);
 
-	new_objs[n_obj - 1].siblings.next = (void *)allocator->free_objs;
-	allocator->free_objs = new_objs;
 	allocator->n_free_objects += n_obj;
 	allocator->n_obj_created += n_obj;
 
@@ -328,21 +287,22 @@
 struct yaffs_obj *yaffs_alloc_raw_obj(struct yaffs_dev *dev)
 {
 	struct yaffs_obj *obj = NULL;
+	struct list_head *lh;
 	struct yaffs_allocator *allocator = dev->allocator;
 
 	if (!allocator) {
-		YBUG();
+		BUG();
 		return obj;
 	}
 
 	/* If there are none left make more */
-	if (!allocator->free_objs)
+	if (list_empty(&allocator->free_objs))
 		yaffs_create_free_objs(dev, YAFFS_ALLOCATION_NOBJECTS);
 
-	if (allocator->free_objs) {
-		obj = allocator->free_objs;
-		allocator->free_objs =
-		    (struct yaffs_obj *)(allocator->free_objs->siblings.next);
+	if (!list_empty(&allocator->free_objs)) {
+		lh = allocator->free_objs.next;
+		obj = list_entry(lh, struct yaffs_obj, siblings);
+		list_del_init(lh);
 		allocator->n_free_objects--;
 	}
 
@@ -354,43 +314,44 @@
 
 	struct yaffs_allocator *allocator = dev->allocator;
 
-	if (!allocator)
-		YBUG();
-	else {
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
 		/* Link into the free list. */
-		obj->siblings.next = (struct list_head *)(allocator->free_objs);
-		allocator->free_objs = obj;
+	list_add(&obj->siblings, &allocator->free_objs);
 		allocator->n_free_objects++;
-	}
 }
 
 void yaffs_deinit_raw_tnodes_and_objs(struct yaffs_dev *dev)
 {
-	if (dev->allocator) {
+
+	if (!dev->allocator) {
+		BUG();
+		return;
+	}
+
 		yaffs_deinit_raw_tnodes(dev);
 		yaffs_deinit_raw_objs(dev);
-
 		kfree(dev->allocator);
 		dev->allocator = NULL;
-	} else {
-		YBUG();
-	}
 }
 
 void yaffs_init_raw_tnodes_and_objs(struct yaffs_dev *dev)
 {
 	struct yaffs_allocator *allocator;
 
-	if (!dev->allocator) {
+	if (dev->allocator) {
+		BUG();
+		return;
+	}
+
 		allocator = kmalloc(sizeof(struct yaffs_allocator), GFP_NOFS);
 		if (allocator) {
 			dev->allocator = allocator;
 			yaffs_init_raw_tnodes(dev);
 			yaffs_init_raw_objs(dev);
 		}
-	} else {
-		YBUG();
-	}
 }
 
-#endif
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_allocator.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_allocator.h
--- linux-3.1.9/fs/yaffs2/yaffs_allocator.h	2012-06-20 14:51:23.966803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_allocator.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_attribs.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_attribs.c
--- linux-3.1.9/fs/yaffs2/yaffs_attribs.c	2012-06-20 14:51:23.966803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_attribs.c	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -52,7 +52,7 @@
 	obj->yst_gid = gid;
 }
 
-loff_t yaffs_get_file_size(struct yaffs_obj *obj)
+static loff_t yaffs_get_file_size(struct yaffs_obj *obj)
 {
 	YCHAR *alias = NULL;
 	obj = yaffs_get_equivalent_obj(obj);
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_attribs.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_attribs.h
--- linux-3.1.9/fs/yaffs2/yaffs_attribs.h	2012-06-20 14:51:23.966803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_attribs.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_bitmap.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_bitmap.c
--- linux-3.1.9/fs/yaffs2/yaffs_bitmap.c	2012-06-20 14:51:23.966803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_bitmap.c	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -23,7 +23,7 @@
 		yaffs_trace(YAFFS_TRACE_ERROR,
 			"BlockBits block %d is not valid",
 			blk);
-		YBUG();
+		BUG();
 	}
 	return dev->chunk_bits +
 	    (dev->chunk_bit_stride * (blk - dev->internal_start_block));
@@ -36,7 +36,7 @@
 		yaffs_trace(YAFFS_TRACE_ERROR,
 			"Chunk Id (%d:%d) invalid",
 			blk, chunk);
-		YBUG();
+		BUG();
 	}
 }
 
@@ -52,7 +52,6 @@
 	u8 *blk_bits = yaffs_block_bits(dev, blk);
 
 	yaffs_verify_chunk_bit_id(dev, blk, chunk);
-
 	blk_bits[chunk / 8] &= ~(1 << (chunk & 7));
 }
 
@@ -61,15 +60,14 @@
 	u8 *blk_bits = yaffs_block_bits(dev, blk);
 
 	yaffs_verify_chunk_bit_id(dev, blk, chunk);
-
 	blk_bits[chunk / 8] |= (1 << (chunk & 7));
 }
 
 int yaffs_check_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
 {
 	u8 *blk_bits = yaffs_block_bits(dev, blk);
-	yaffs_verify_chunk_bit_id(dev, blk, chunk);
 
+	yaffs_verify_chunk_bit_id(dev, blk, chunk);
 	return (blk_bits[chunk / 8] & (1 << (chunk & 7))) ? 1 : 0;
 }
 
@@ -77,6 +75,7 @@
 {
 	u8 *blk_bits = yaffs_block_bits(dev, blk);
 	int i;
+
 	for (i = 0; i < dev->chunk_bit_stride; i++) {
 		if (*blk_bits)
 			return 1;
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_bitmap.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_bitmap.h
--- linux-3.1.9/fs/yaffs2/yaffs_bitmap.h	2012-06-20 14:51:23.966803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_bitmap.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_checkptrw.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_checkptrw.c
--- linux-3.1.9/fs/yaffs2/yaffs_checkptrw.c	2012-06-20 14:51:23.970803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_checkptrw.c	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -14,6 +14,52 @@
 #include "yaffs_checkptrw.h"
 #include "yaffs_getblockinfo.h"
 
+struct yaffs_checkpt_chunk_hdr {
+	int version;
+	int seq;
+	u32 sum;
+	u32 xor;
+} ;
+
+
+static int apply_chunk_offset(struct yaffs_dev *dev, int chunk)
+{
+	return chunk - dev->chunk_offset;
+}
+
+static int apply_block_offset(struct yaffs_dev *dev, int block)
+{
+	return block - dev->block_offset;
+}
+
+static void yaffs2_checkpt_init_chunk_hdr(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_chunk_hdr hdr;
+
+	hdr.version = YAFFS_CHECKPOINT_VERSION;
+	hdr.seq = dev->checkpt_page_seq;
+	hdr.sum = dev->checkpt_sum;
+	hdr.xor = dev->checkpt_xor;
+
+	dev->checkpt_byte_offs = sizeof(hdr);
+
+	memcpy(dev->checkpt_buffer, &hdr, sizeof(hdr));
+}
+
+static int yaffs2_checkpt_check_chunk_hdr(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_chunk_hdr hdr;
+
+	memcpy(&hdr, dev->checkpt_buffer, sizeof(hdr));
+
+	dev->checkpt_byte_offs = sizeof(hdr);
+
+	return hdr.version == YAFFS_CHECKPOINT_VERSION &&
+		hdr.seq == dev->checkpt_page_seq &&
+		hdr.sum == dev->checkpt_sum &&
+		hdr.xor == dev->checkpt_xor;
+}
+
 static int yaffs2_checkpt_space_ok(struct yaffs_dev *dev)
 {
 	int blocks_avail = dev->n_erased_blocks - dev->param.n_reserved_blocks;
@@ -36,21 +82,23 @@
 
 	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
 		struct yaffs_block_info *bi = yaffs_get_block_info(dev, i);
+		int offset_i = apply_block_offset(dev, i);
+		int result;
+
 		if (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT) {
 			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
 			"erasing checkpt block %d", i);
 
 			dev->n_erasures++;
 
-			if (dev->param.
-			    erase_fn(dev,
-				     i - dev->block_offset /* realign */ )) {
+			result = dev->param.erase_fn(dev, offset_i);
+			if(result) {
 				bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
 				dev->n_erased_blocks++;
 				dev->n_free_chunks +=
 				    dev->param.chunks_per_block;
 			} else {
-				dev->param.bad_block_fn(dev, i);
+				dev->param.bad_block_fn(dev, offset_i);
 				bi->block_state = YAFFS_BLOCK_STATE_DEAD;
 			}
 		}
@@ -65,6 +113,7 @@
 {
 	int i;
 	int blocks_avail = dev->n_erased_blocks - dev->param.n_reserved_blocks;
+
 	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
 		"allocating checkpt block: erased %d reserved %d avail %d next %d ",
 		dev->n_erased_blocks, dev->param.n_reserved_blocks,
@@ -76,8 +125,9 @@
 
 		for (i = dev->checkpt_next_block; i <= dev->internal_end_block;
 		     i++) {
-			struct yaffs_block_info *bi =
-			    yaffs_get_block_info(dev, i);
+			struct yaffs_block_info *bi;
+
+			bi = yaffs_get_block_info(dev, i);
 			if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
 				dev->checkpt_next_block = i + 1;
 				dev->checkpt_cur_block = i;
@@ -106,27 +156,36 @@
 		for (i = dev->checkpt_next_block; i <= dev->internal_end_block;
 		     i++) {
 			int chunk = i * dev->param.chunks_per_block;
-			int realigned_chunk = chunk - dev->chunk_offset;
+			enum yaffs_block_state state;
+			u32 seq;
 
-			dev->param.read_chunk_tags_fn(dev, realigned_chunk,
+			dev->param.read_chunk_tags_fn(dev,
+					apply_chunk_offset(dev, chunk),
 						      NULL, &tags);
 			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
-				"find next checkpt block: search: block %d oid %d seq %d eccr %d",
-				i, tags.obj_id, tags.seq_number,
+				"find next checkpt block: search: block %d state %d oid %d seq %d eccr %d",
+				i, (int) state,
+				tags.obj_id, tags.seq_number,
 				tags.ecc_result);
 
-			if (tags.seq_number == YAFFS_SEQUENCE_CHECKPOINT_DATA) {
+			if (tags.seq_number != YAFFS_SEQUENCE_CHECKPOINT_DATA)
+				continue;
+
+			dev->param.query_block_fn(dev,
+						apply_block_offset(dev, i),
+						&state, &seq);
+			if (state == YAFFS_BLOCK_STATE_DEAD)
+				continue;
+
 				/* Right kind of block */
 				dev->checkpt_next_block = tags.obj_id;
 				dev->checkpt_cur_block = i;
-				dev->checkpt_block_list[dev->
-							blocks_in_checkpt] = i;
+			dev->checkpt_block_list[dev->blocks_in_checkpt] = i;
 				dev->blocks_in_checkpt++;
 				yaffs_trace(YAFFS_TRACE_CHECKPOINT,
 					"found checkpt block %d", i);
 				return;
 			}
-		}
 
 	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "found no more checkpt blocks");
 
@@ -136,6 +195,7 @@
 
 int yaffs2_checkpt_open(struct yaffs_dev *dev, int writing)
 {
+	int i;
 
 	dev->checkpt_open_write = writing;
 
@@ -162,29 +222,28 @@
 	dev->checkpt_cur_chunk = -1;
 	dev->checkpt_next_block = dev->internal_start_block;
 
-	/* Erase all the blocks in the checkpoint area */
 	if (writing) {
 		memset(dev->checkpt_buffer, 0, dev->data_bytes_per_chunk);
-		dev->checkpt_byte_offs = 0;
+		yaffs2_checkpt_init_chunk_hdr(dev);
 		return yaffs_checkpt_erase(dev);
-	} else {
-		int i;
+	}
+
+	/* Opening for a read */
 		/* Set to a value that will kick off a read */
 		dev->checkpt_byte_offs = dev->data_bytes_per_chunk;
-		/* A checkpoint block list of 1 checkpoint block per 16 block is (hopefully)
-		 * going to be way more than we need */
+	/* A checkpoint block list of 1 checkpoint block per 16 block is
+	 * (hopefully) going to be way more than we need */
 		dev->blocks_in_checkpt = 0;
 		dev->checkpt_max_blocks =
-		    (dev->internal_end_block - dev->internal_start_block) / 16 +
-		    2;
+	    (dev->internal_end_block - dev->internal_start_block) / 16 + 2;
 		dev->checkpt_block_list =
 		    kmalloc(sizeof(int) * dev->checkpt_max_blocks, GFP_NOFS);
+
 		if (!dev->checkpt_block_list)
 			return 0;
 
 		for (i = 0; i < dev->checkpt_max_blocks; i++)
 			dev->checkpt_block_list[i] = -1;
-	}
 
 	return 1;
 }
@@ -192,7 +251,8 @@
 int yaffs2_get_checkpt_sum(struct yaffs_dev *dev, u32 * sum)
 {
 	u32 composite_sum;
-	composite_sum = (dev->checkpt_sum << 8) | (dev->checkpt_xor & 0xFF);
+
+	composite_sum = (dev->checkpt_sum << 8) | (dev->checkpt_xor & 0xff);
 	*sum = composite_sum;
 	return 1;
 }
@@ -200,8 +260,7 @@
 static int yaffs2_checkpt_flush_buffer(struct yaffs_dev *dev)
 {
 	int chunk;
-	int realigned_chunk;
-
+	int offset_chunk;
 	struct yaffs_ext_tags tags;
 
 	if (dev->checkpt_cur_block < 0) {
@@ -235,13 +294,12 @@
 		chunk, dev->checkpt_cur_block, dev->checkpt_cur_chunk,
 		tags.obj_id, tags.chunk_id);
 
-	realigned_chunk = chunk - dev->chunk_offset;
+	offset_chunk = apply_chunk_offset(dev, chunk);
 
 	dev->n_page_writes++;
 
-	dev->param.write_chunk_tags_fn(dev, realigned_chunk,
+	dev->param.write_chunk_tags_fn(dev, offset_chunk,
 				       dev->checkpt_buffer, &tags);
-	dev->checkpt_byte_offs = 0;
 	dev->checkpt_page_seq++;
 	dev->checkpt_cur_chunk++;
 	if (dev->checkpt_cur_chunk >= dev->param.chunks_per_block) {
@@ -250,6 +308,9 @@
 	}
 	memset(dev->checkpt_buffer, 0, dev->data_bytes_per_chunk);
 
+	yaffs2_checkpt_init_chunk_hdr(dev);
+
+
 	return 1;
 }
 
@@ -257,7 +318,6 @@
 {
 	int i = 0;
 	int ok = 1;
-
 	u8 *data_bytes = (u8 *) data;
 
 	if (!dev->checkpt_buffer)
@@ -289,10 +349,8 @@
 	int i = 0;
 	int ok = 1;
 	struct yaffs_ext_tags tags;
-
 	int chunk;
-	int realigned_chunk;
-
+	int offset_chunk;
 	u8 *data_bytes = (u8 *) data;
 
 	if (!dev->checkpt_buffer)
@@ -311,43 +369,45 @@
 				dev->checkpt_cur_chunk = 0;
 			}
 
-			if (dev->checkpt_cur_block < 0)
+			if (dev->checkpt_cur_block < 0) {
 				ok = 0;
-			else {
+				break;
+			}
+
 				chunk = dev->checkpt_cur_block *
 				    dev->param.chunks_per_block +
 				    dev->checkpt_cur_chunk;
 
-				realigned_chunk = chunk - dev->chunk_offset;
-
+			offset_chunk = apply_chunk_offset(dev, chunk);
 				dev->n_page_reads++;
 
 				/* read in the next chunk */
 				dev->param.read_chunk_tags_fn(dev,
-							      realigned_chunk,
-							      dev->
-							      checkpt_buffer,
+						offset_chunk,
+						dev->checkpt_buffer,
 							      &tags);
 
-				if (tags.chunk_id != (dev->checkpt_page_seq + 1)
-				    || tags.ecc_result > YAFFS_ECC_RESULT_FIXED
-				    || tags.seq_number !=
-				    YAFFS_SEQUENCE_CHECKPOINT_DATA)
+			if (tags.chunk_id != (dev->checkpt_page_seq + 1) ||
+			    tags.ecc_result > YAFFS_ECC_RESULT_FIXED ||
+			    tags.seq_number != YAFFS_SEQUENCE_CHECKPOINT_DATA) {
 					ok = 0;
+				break;
+			}
+			if(!yaffs2_checkpt_check_chunk_hdr(dev)) {
+				ok = 0;
+				break;
+			}
 
-				dev->checkpt_byte_offs = 0;
 				dev->checkpt_page_seq++;
 				dev->checkpt_cur_chunk++;
 
 				if (dev->checkpt_cur_chunk >=
 				    dev->param.chunks_per_block)
 					dev->checkpt_cur_block = -1;
-			}
+
 		}
 
-		if (ok) {
-			*data_bytes =
-			    dev->checkpt_buffer[dev->checkpt_byte_offs];
+		*data_bytes = dev->checkpt_buffer[dev->checkpt_byte_offs];
 			dev->checkpt_sum += *data_bytes;
 			dev->checkpt_xor ^= *data_bytes;
 			dev->checkpt_byte_offs++;
@@ -355,32 +415,30 @@
 			data_bytes++;
 			dev->checkpt_byte_count++;
 		}
-	}
 
 	return i;
 }
 
 int yaffs_checkpt_close(struct yaffs_dev *dev)
 {
+	int i;
 
 	if (dev->checkpt_open_write) {
-		if (dev->checkpt_byte_offs != 0)
+		if (dev->checkpt_byte_offs !=
+			sizeof(sizeof(struct yaffs_checkpt_chunk_hdr)))
 			yaffs2_checkpt_flush_buffer(dev);
 	} else if (dev->checkpt_block_list) {
-		int i;
 		for (i = 0;
-		     i < dev->blocks_in_checkpt
-		     && dev->checkpt_block_list[i] >= 0; i++) {
+		     i < dev->blocks_in_checkpt &&
+		     dev->checkpt_block_list[i] >= 0; i++) {
 			int blk = dev->checkpt_block_list[i];
 			struct yaffs_block_info *bi = NULL;
-			if (dev->internal_start_block <= blk
-			    && blk <= dev->internal_end_block)
+
+			if (dev->internal_start_block <= blk &&
+			    blk <= dev->internal_end_block)
 				bi = yaffs_get_block_info(dev, blk);
 			if (bi && bi->block_state == YAFFS_BLOCK_STATE_EMPTY)
 				bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
-			else {
-				/* Todo this looks odd... */
-			}
 		}
 		kfree(dev->checkpt_block_list);
 		dev->checkpt_block_list = NULL;
@@ -390,7 +448,7 @@
 	    dev->blocks_in_checkpt * dev->param.chunks_per_block;
 	dev->n_erased_blocks -= dev->blocks_in_checkpt;
 
-	yaffs_trace(YAFFS_TRACE_CHECKPOINT,"checkpoint byte count %d",
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "checkpoint byte count %d",
 		dev->checkpt_byte_count);
 
 	if (dev->checkpt_buffer) {
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_checkptrw.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_checkptrw.h
--- linux-3.1.9/fs/yaffs2/yaffs_checkptrw.h	2012-06-20 14:51:23.970803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_checkptrw.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_ecc.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_ecc.c
--- linux-3.1.9/fs/yaffs2/yaffs_ecc.c	2012-06-20 14:51:23.970803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_ecc.c	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -16,22 +16,22 @@
  *
  * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
  * The two unused bit are set to 1.
- * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC
- * blocks are used on a 512-byte NAND page.
+ * The ECC can correct single bit errors in a 256-byte page of data. Thus, two
+ * such ECC blocks are used on a 512-byte NAND page.
  *
  */
 
+#include "yportenv.h"
+
+#include "yaffs_ecc.h"
+
 /* Table generated by gen-ecc.c
  * Using a table means we do not have to calculate p1..p4 and p1'..p4'
  * for each byte of data. These are instead provided in a table in bits7..2.
- * Bit 0 of each entry indicates whether the entry has an odd or even parity, and therefore
- * this bytes influence on the line parity.
+ * Bit 0 of each entry indicates whether the entry has an odd or even parity,
+ * and therefore this bytes influence on the line parity.
  */
 
-#include "yportenv.h"
-
-#include "yaffs_ecc.h"
-
 static const unsigned char column_parity_table[] = {
 	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
 	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
@@ -69,10 +69,9 @@
 
 
 /* Calculate the ECC for a 256-byte block of data */
-void yaffs_ecc_cacl(const unsigned char *data, unsigned char *ecc)
+void yaffs_ecc_calc(const unsigned char *data, unsigned char *ecc)
 {
 	unsigned int i;
-
 	unsigned char col_parity = 0;
 	unsigned char line_parity = 0;
 	unsigned char line_parity_prime = 0;
@@ -129,12 +128,6 @@
 		t |= 0x01;
 	ecc[0] = ~t;
 
-#ifdef CONFIG_YAFFS_ECC_WRONG_ORDER
-	/* Swap the bytes into the wrong order */
-	t = ecc[0];
-	ecc[0] = ecc[1];
-	ecc[1] = t;
-#endif
 }
 
 /* Correct the ECC on a 256 byte block of data */
@@ -159,15 +152,6 @@
 		unsigned byte;
 		unsigned bit;
 
-#ifdef CONFIG_YAFFS_ECC_WRONG_ORDER
-		/* swap the bytes to correct for the wrong order */
-		unsigned char t;
-
-		t = d0;
-		d0 = d1;
-		d1 = t;
-#endif
-
 		bit = byte = 0;
 
 		if (d1 & 0x80)
@@ -222,7 +206,6 @@
 			  struct yaffs_ecc_other *ecc_other)
 {
 	unsigned int i;
-
 	unsigned char col_parity = 0;
 	unsigned line_parity = 0;
 	unsigned line_parity_prime = 0;
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_ecc.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_ecc.h
--- linux-3.1.9/fs/yaffs2/yaffs_ecc.h	2012-06-20 14:51:23.970803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_ecc.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -18,8 +18,8 @@
  *
  * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
  * The two unused bit are set to 1.
- * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC
- * blocks are used on a 512-byte NAND page.
+ * The ECC can correct single bit errors in a 256-byte page of data.
+ * Thus, two such ECC blocks are used on a 512-byte NAND page.
  *
  */
 
@@ -32,7 +32,7 @@
 	unsigned line_parity_prime;
 };
 
-void yaffs_ecc_cacl(const unsigned char *data, unsigned char *ecc);
+void yaffs_ecc_calc(const unsigned char *data, unsigned char *ecc);
 int yaffs_ecc_correct(unsigned char *data, unsigned char *read_ecc,
 		      const unsigned char *test_ecc);
 
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_getblockinfo.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_getblockinfo.h
--- linux-3.1.9/fs/yaffs2/yaffs_getblockinfo.h	2012-06-20 14:51:23.970803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_getblockinfo.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -27,7 +27,7 @@
 		yaffs_trace(YAFFS_TRACE_ERROR,
 			"**>> yaffs: get_block_info block %d is not valid",
 			blk);
-		YBUG();
+		BUG();
 	}
 	return &dev->block_info[blk - dev->internal_start_block];
 }
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_guts.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_guts.c
--- linux-3.1.9/fs/yaffs2/yaffs_guts.c	2012-06-20 14:51:23.974803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_guts.c	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -15,25 +15,19 @@
 #include "yaffs_trace.h"
 
 #include "yaffs_guts.h"
-#include "yaffs_tagsvalidity.h"
 #include "yaffs_getblockinfo.h"
-
 #include "yaffs_tagscompat.h"
-
 #include "yaffs_nand.h"
-
 #include "yaffs_yaffs1.h"
 #include "yaffs_yaffs2.h"
 #include "yaffs_bitmap.h"
 #include "yaffs_verify.h"
-
 #include "yaffs_nand.h"
 #include "yaffs_packedtags2.h"
-
 #include "yaffs_nameval.h"
 #include "yaffs_allocator.h"
-
 #include "yaffs_attribs.h"
+#include "yaffs_summary.h"
 
 /* Note YAFFS_GC_GOOD_ENOUGH must be <= YAFFS_GC_PASSIVE_THRESHOLD */
 #define YAFFS_GC_GOOD_ENOUGH 2
@@ -44,14 +38,14 @@
 /* Forward declarations */
 
 static int yaffs_wr_data_obj(struct yaffs_obj *in, int inode_chunk,
-			     const u8 * buffer, int n_bytes, int use_reserve);
+			     const u8 *buffer, int n_bytes, int use_reserve);
 
 
 
 /* Function to calculate chunk and offset */
 
-static void yaffs_addr_to_chunk(struct yaffs_dev *dev, loff_t addr,
-				int *chunk_out, u32 * offset_out)
+void yaffs_addr_to_chunk(struct yaffs_dev *dev, loff_t addr,
+				int *chunk_out, u32 *offset_out)
 {
 	int chunk;
 	u32 offset;
@@ -82,7 +76,7 @@
  * be hellishly efficient.
  */
 
-static u32 calc_shifts_ceiling(u32 x)
+static inline u32 calc_shifts_ceiling(u32 x)
 {
 	int extra_bits;
 	int shifts;
@@ -105,7 +99,7 @@
 /* Function to return the number of shifts to get a 1 in bit 0
  */
 
-static u32 calc_shifts(u32 x)
+static inline u32 calc_shifts(u32 x)
 {
 	u32 shifts;
 
@@ -134,42 +128,30 @@
 	memset(dev->temp_buffer, 0, sizeof(dev->temp_buffer));
 
 	for (i = 0; buf && i < YAFFS_N_TEMP_BUFFERS; i++) {
-		dev->temp_buffer[i].line = 0;	/* not in use */
-		dev->temp_buffer[i].buffer = buf =
-		    kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+		dev->temp_buffer[i].in_use = 0;
+		buf = kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+		dev->temp_buffer[i].buffer = buf;
 	}
 
 	return buf ? YAFFS_OK : YAFFS_FAIL;
 }
 
-u8 *yaffs_get_temp_buffer(struct yaffs_dev * dev, int line_no)
+u8 *yaffs_get_temp_buffer(struct yaffs_dev * dev)
 {
-	int i, j;
+	int i;
 
 	dev->temp_in_use++;
 	if (dev->temp_in_use > dev->max_temp)
 		dev->max_temp = dev->temp_in_use;
 
 	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
-		if (dev->temp_buffer[i].line == 0) {
-			dev->temp_buffer[i].line = line_no;
-			if ((i + 1) > dev->max_temp) {
-				dev->max_temp = i + 1;
-				for (j = 0; j <= i; j++)
-					dev->temp_buffer[j].max_line =
-					    dev->temp_buffer[j].line;
-			}
-
+		if (dev->temp_buffer[i].in_use == 0) {
+			dev->temp_buffer[i].in_use = 1;
 			return dev->temp_buffer[i].buffer;
 		}
 	}
 
-	yaffs_trace(YAFFS_TRACE_BUFFERS,
-		"Out of temp buffers at line %d, other held by lines:",
-		line_no);
-	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++)
-		yaffs_trace(YAFFS_TRACE_BUFFERS," %d", dev->temp_buffer[i].line);
-
+	yaffs_trace(YAFFS_TRACE_BUFFERS, "Out of temp buffers");
 	/*
 	 * If we got here then we have to allocate an unmanaged one
 	 * This is not good.
@@ -180,7 +162,7 @@
 
 }
 
-void yaffs_release_temp_buffer(struct yaffs_dev *dev, u8 * buffer, int line_no)
+void yaffs_release_temp_buffer(struct yaffs_dev *dev, u8 *buffer)
 {
 	int i;
 
@@ -188,7 +170,7 @@
 
 	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
 		if (dev->temp_buffer[i].buffer == buffer) {
-			dev->temp_buffer[i].line = 0;
+			dev->temp_buffer[i].in_use = 0;
 			return;
 		}
 	}
@@ -196,8 +178,7 @@
 	if (buffer) {
 		/* assume it is an unmanaged one. */
 		yaffs_trace(YAFFS_TRACE_BUFFERS,
-		  "Releasing unmanaged temp buffer in line %d",
-		   line_no);
+			"Releasing unmanaged temp buffer");
 		kfree(buffer);
 		dev->unmanaged_buffer_deallocs++;
 	}
@@ -205,51 +186,26 @@
 }
 
 /*
- * Determine if we have a managed buffer.
- */
-int yaffs_is_managed_tmp_buffer(struct yaffs_dev *dev, const u8 * buffer)
-{
-	int i;
-
-	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
-		if (dev->temp_buffer[i].buffer == buffer)
-			return 1;
-	}
-
-	for (i = 0; i < dev->param.n_caches; i++) {
-		if (dev->cache[i].data == buffer)
-			return 1;
-	}
-
-	if (buffer == dev->checkpt_buffer)
-		return 1;
-
-	yaffs_trace(YAFFS_TRACE_ALWAYS,
-	  "yaffs: unmaged buffer detected.");
-	return 0;
-}
-
-/*
  * Functions for robustisizing TODO
  *
  */
 
 static void yaffs_handle_chunk_wr_ok(struct yaffs_dev *dev, int nand_chunk,
-				     const u8 * data,
+				     const u8 *data,
 				     const struct yaffs_ext_tags *tags)
 {
-	dev = dev;
-	nand_chunk = nand_chunk;
-	data = data;
-	tags = tags;
+	(void) dev;
+	(void) nand_chunk;
+	(void) data;
+	(void) tags;
 }
 
 static void yaffs_handle_chunk_update(struct yaffs_dev *dev, int nand_chunk,
 				      const struct yaffs_ext_tags *tags)
 {
-	dev = dev;
-	nand_chunk = nand_chunk;
-	tags = tags;
+	(void) dev;
+	(void) nand_chunk;
+	(void) tags;
 }
 
 void yaffs_handle_chunk_error(struct yaffs_dev *dev,
@@ -261,8 +217,9 @@
 		bi->chunk_error_strikes++;
 
 		if (bi->chunk_error_strikes > 3) {
-			bi->needs_retiring = 1;	/* Too many stikes, so retire this */
-			yaffs_trace(YAFFS_TRACE_ALWAYS, "yaffs: Block struck out");
+			bi->needs_retiring = 1;	/* Too many stikes, so retire */
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"yaffs: Block struck out");
 
 		}
 	}
@@ -277,7 +234,8 @@
 	yaffs_handle_chunk_error(dev, bi);
 
 	if (erased_ok) {
-		/* Was an actual write failure, so mark the block for retirement  */
+		/* Was an actual write failure,
+		 * so mark the block for retirement.*/
 		bi->needs_retiring = 1;
 		yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
 		  "**>> Block %d needs retiring", flash_block);
@@ -298,7 +256,8 @@
 
 static inline int yaffs_hash_fn(int n)
 {
-	n = abs(n);
+	if (n < 0)
+		n = -n;
 	return n % YAFFS_NOBJECT_BUCKETS;
 }
 
@@ -321,11 +280,11 @@
  *  Erased NAND checking functions
  */
 
-int yaffs_check_ff(u8 * buffer, int n_bytes)
+int yaffs_check_ff(u8 *buffer, int n_bytes)
 {
 	/* Horrible, slow implementation */
 	while (n_bytes--) {
-		if (*buffer != 0xFF)
+		if (*buffer != 0xff)
 			return 0;
 		buffer++;
 	}
@@ -335,7 +294,7 @@
 static int yaffs_check_chunk_erased(struct yaffs_dev *dev, int nand_chunk)
 {
 	int retval = YAFFS_OK;
-	u8 *data = yaffs_get_temp_buffer(dev, __LINE__);
+	u8 *data = yaffs_get_temp_buffer(dev);
 	struct yaffs_ext_tags tags;
 	int result;
 
@@ -346,11 +305,12 @@
 
 	if (!yaffs_check_ff(data, dev->data_bytes_per_chunk) ||
 		tags.chunk_used) {
-		yaffs_trace(YAFFS_TRACE_NANDACCESS, "Chunk %d not erased", nand_chunk);
+		yaffs_trace(YAFFS_TRACE_NANDACCESS,
+			"Chunk %d not erased", nand_chunk);
 		retval = YAFFS_FAIL;
 	}
 
-	yaffs_release_temp_buffer(dev, data, __LINE__);
+	yaffs_release_temp_buffer(dev, data);
 
 	return retval;
 
@@ -358,12 +318,12 @@
 
 static int yaffs_verify_chunk_written(struct yaffs_dev *dev,
 				      int nand_chunk,
-				      const u8 * data,
+				      const u8 *data,
 				      struct yaffs_ext_tags *tags)
 {
 	int retval = YAFFS_OK;
 	struct yaffs_ext_tags temp_tags;
-	u8 *buffer = yaffs_get_temp_buffer(dev, __LINE__);
+	u8 *buffer = yaffs_get_temp_buffer(dev);
 	int result;
 
 	result = yaffs_rd_chunk_tags_nand(dev, nand_chunk, buffer, &temp_tags);
@@ -373,7 +333,7 @@
 	    temp_tags.n_bytes != tags->n_bytes)
 		retval = YAFFS_FAIL;
 
-	yaffs_release_temp_buffer(dev, buffer, __LINE__);
+	yaffs_release_temp_buffer(dev, buffer);
 
 	return retval;
 }
@@ -388,7 +348,7 @@
 	checkpt_blocks = yaffs_calc_checkpt_blocks_required(dev);
 
 	reserved_chunks =
-	    ((reserved_blocks + checkpt_blocks) * dev->param.chunks_per_block);
+	    (reserved_blocks + checkpt_blocks) * dev->param.chunks_per_block;
 
 	return (dev->n_free_chunks > (reserved_chunks + n_chunks));
 }
@@ -396,7 +356,6 @@
 static int yaffs_find_alloc_block(struct yaffs_dev *dev)
 {
 	int i;
-
 	struct yaffs_block_info *bi;
 
 	if (dev->n_erased_blocks < 1) {
@@ -404,7 +363,7 @@
 		 * Can't get space to gc
 		 */
 		yaffs_trace(YAFFS_TRACE_ERROR,
-		  "yaffs tragedy: no more erased blocks" );
+		  "yaffs tragedy: no more erased blocks");
 
 		return -1;
 	}
@@ -453,7 +412,7 @@
 	}
 
 	if (!use_reserver && !yaffs_check_alloc_available(dev, 1)) {
-		/* Not enough space to allocate unless we're allowed to use the reserve. */
+		/* No space unless we're allowed to use the reserve. */
 		return -1;
 	}
 
@@ -486,7 +445,8 @@
 		return ret_val;
 	}
 
-	yaffs_trace(YAFFS_TRACE_ERROR, "!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!" );
+	yaffs_trace(YAFFS_TRACE_ERROR,
+		"!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!");
 
 	return -1;
 }
@@ -510,9 +470,10 @@
  */
 void yaffs_skip_rest_of_block(struct yaffs_dev *dev)
 {
+	struct yaffs_block_info *bi;
+
 	if (dev->alloc_block > 0) {
-		struct yaffs_block_info *bi =
-		    yaffs_get_block_info(dev, dev->alloc_block);
+		bi = yaffs_get_block_info(dev, dev->alloc_block);
 		if (bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING) {
 			bi->block_state = YAFFS_BLOCK_STATE_FULL;
 			dev->alloc_block = -1;
@@ -521,7 +482,7 @@
 }
 
 static int yaffs_write_new_chunk(struct yaffs_dev *dev,
-				 const u8 * data,
+				 const u8 *data,
 				 struct yaffs_ext_tags *tags, int use_reserver)
 {
 	int attempts = 0;
@@ -614,7 +575,7 @@
 		yaffs_trace(YAFFS_TRACE_ERROR,
 			"**>> yaffs write required %d attempts",
 			attempts);
-		dev->n_retired_writes += (attempts - 1);
+		dev->n_retried_writes += (attempts - 1);
 	}
 
 	return chunk;
@@ -642,10 +603,10 @@
 			int chunk_id =
 			    flash_block * dev->param.chunks_per_block;
 
-			u8 *buffer = yaffs_get_temp_buffer(dev, __LINE__);
+			u8 *buffer = yaffs_get_temp_buffer(dev);
 
 			memset(buffer, 0xff, dev->data_bytes_per_chunk);
-			yaffs_init_tags(&tags);
+			memset(&tags, 0, sizeof(tags));
 			tags.seq_number = YAFFS_SEQUENCE_BAD_BLOCK;
 			if (dev->param.write_chunk_tags_fn(dev, chunk_id -
 							   dev->chunk_offset,
@@ -655,7 +616,7 @@
 					"yaffs: Failed to write bad block marker to block %d",
 					flash_block);
 
-			yaffs_release_temp_buffer(dev, buffer, __LINE__);
+			yaffs_release_temp_buffer(dev, buffer);
 		}
 	}
 
@@ -668,27 +629,26 @@
 
 /*---------------- Name handling functions ------------*/
 
-static u16 yaffs_calc_name_sum(const YCHAR * name)
+static u16 yaffs_calc_name_sum(const YCHAR *name)
 {
 	u16 sum = 0;
 	u16 i = 1;
 
-	const YUCHAR *bname = (const YUCHAR *)name;
-	if (bname) {
-		while ((*bname) && (i < (YAFFS_MAX_NAME_LENGTH / 2))) {
+	if (!name)
+		return 0;
+
+	while ((*name) && i < (YAFFS_MAX_NAME_LENGTH / 2)) {
 
 			/* 0x1f mask is case insensitive */
-			sum += ((*bname) & 0x1f) * i;
+		sum += ((*name) & 0x1f) * i;
 			i++;
-			bname++;
-		}
+		name++;
 	}
 	return sum;
 }
 
 void yaffs_set_obj_name(struct yaffs_obj *obj, const YCHAR * name)
 {
-#ifndef CONFIG_YAFFS_NO_SHORT_NAMES
 	memset(obj->short_name, 0, sizeof(obj->short_name));
 	if (name && 
 	        strnlen(name, YAFFS_SHORT_NAME_LENGTH + 1) <=
@@ -696,7 +656,6 @@
 		strcpy(obj->short_name, name);
 	else
 		obj->short_name[0] = _Y('\0');
-#endif
 	obj->sum = yaffs_calc_name_sum(name);
 }
 
@@ -714,6 +673,14 @@
 #endif
 }
 
+loff_t yaffs_max_file_size(struct yaffs_dev *dev)
+{
+	if(sizeof(loff_t) < 8)
+		return YAFFS_MAX_FILE_SIZE_32;
+	else
+		return ((loff_t) YAFFS_MAX_CHUNK_ID) * dev->data_bytes_per_chunk;
+}
+
 /*-------------------- TNODES -------------------
 
  * List of spare tnodes
@@ -724,6 +691,7 @@
 struct yaffs_tnode *yaffs_get_tnode(struct yaffs_dev *dev)
 {
 	struct yaffs_tnode *tn = yaffs_alloc_raw_tnode(dev);
+
 	if (tn) {
 		memset(tn, 0, dev->tnode_size);
 		dev->n_tnodes++;
@@ -749,7 +717,7 @@
 	dev->n_tnodes = 0;
 }
 
-void yaffs_load_tnode_0(struct yaffs_dev *dev, struct yaffs_tnode *tn,
+static void yaffs_load_tnode_0(struct yaffs_dev *dev, struct yaffs_tnode *tn,
 			unsigned pos, unsigned val)
 {
 	u32 *map = (u32 *) tn;
@@ -772,9 +740,9 @@
 
 	if (dev->tnode_width > (32 - bit_in_word)) {
 		bit_in_word = (32 - bit_in_word);
-		word_in_map++;;
+		word_in_map++;
 		mask =
-		    dev->tnode_mask >> ( /*dev->tnode_width - */ bit_in_word);
+		    dev->tnode_mask >> bit_in_word;
 		map[word_in_map] &= ~mask;
 		map[word_in_map] |= (mask & (val >> bit_in_word));
 	}
@@ -799,7 +767,7 @@
 
 	if (dev->tnode_width > (32 - bit_in_word)) {
 		bit_in_word = (32 - bit_in_word);
-		word_in_map++;;
+		word_in_map++;
 		val |= (map[word_in_map] << bit_in_word);
 	}
 
@@ -826,7 +794,7 @@
 	int required_depth;
 	int level = file_struct->top_level;
 
-	dev = dev;
+	(void) dev;
 
 	/* Check sane level and chunk Id */
 	if (level < 0 || level > YAFFS_TNODES_MAX_LEVEL)
@@ -860,15 +828,16 @@
 	return tn;
 }
 
-/* AddOrFindLevel0Tnode finds the level 0 tnode if it exists, otherwise first expands the tree.
+/* add_find_tnode_0 finds the level 0 tnode if it exists,
+ * otherwise first expands the tree.
  * This happens in two steps:
  *  1. If the tree isn't tall enough, then make it taller.
  *  2. Scan down the tree towards the level 0 tnode adding tnodes if required.
  *
  * Used when modifying the tree.
  *
- *  If the tn argument is NULL, then a fresh tnode will be added otherwise the specified tn will
- *  be plugged into the ttree.
+ *  If the tn argument is NULL, then a fresh tnode will be added otherwise the
+ *  specified tn will be plugged into the ttree.
  */
 
 struct yaffs_tnode *yaffs_add_find_tnode_0(struct yaffs_dev *dev,
@@ -880,12 +849,11 @@
 	int i;
 	int l;
 	struct yaffs_tnode *tn;
-
 	u32 x;
 
 	/* Check sane level and page Id */
-	if (file_struct->top_level < 0
-	    || file_struct->top_level > YAFFS_TNODES_MAX_LEVEL)
+	if (file_struct->top_level < 0 ||
+	    file_struct->top_level > YAFFS_TNODES_MAX_LEVEL)
 		return NULL;
 
 	if (chunk_id > YAFFS_MAX_CHUNK_ID)
@@ -911,7 +879,8 @@
 				file_struct->top = tn;
 				file_struct->top_level++;
 			} else {
-				yaffs_trace(YAFFS_TRACE_ERROR, "yaffs: no more tnodes");
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"yaffs: no more tnodes");
 				return NULL;
 			}
 		}
@@ -937,11 +906,10 @@
 			} else if (l == 1) {
 				/* Looking from level 1 at level 0 */
 				if (passed_tn) {
-					/* If we already have one, then release it. */
+					/* If we already have one, release it */
 					if (tn->internal[x])
 						yaffs_free_tnode(dev,
-								 tn->
-								 internal[x]);
+							tn->internal[x]);
 					tn->internal[x] = passed_tn;
 
 				} else if (!tn->internal[x]) {
@@ -971,7 +939,8 @@
 			    int chunk_obj)
 {
 	return (tags->chunk_id == chunk_obj &&
-		tags->obj_id == obj_id && !tags->is_deleted) ? 1 : 0;
+		tags->obj_id == obj_id &&
+		!tags->is_deleted) ? 1 : 0;
 
 }
 
@@ -991,7 +960,8 @@
 			else {
 				yaffs_rd_chunk_tags_nand(dev, the_chunk, NULL,
 							 tags);
-				if (yaffs_tags_match(tags, obj_id, inode_chunk)) {
+				if (yaffs_tags_match(tags,
+							obj_id, inode_chunk)) {
 					/* found it; */
 					return the_chunk;
 				}
@@ -1010,7 +980,6 @@
 	int the_chunk = -1;
 	struct yaffs_ext_tags local_tags;
 	int ret_val = -1;
-
 	struct yaffs_dev *dev = in->my_dev;
 
 	if (!tags) {
@@ -1020,13 +989,13 @@
 
 	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
 
-	if (tn) {
+	if (!tn)
+		return ret_val;
+
 		the_chunk = yaffs_get_group_base(dev, tn, inode_chunk);
 
-		ret_val =
-		    yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
+	ret_val = yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
 					      inode_chunk);
-	}
 	return ret_val;
 }
 
@@ -1037,7 +1006,6 @@
 	struct yaffs_tnode *tn;
 	int the_chunk = -1;
 	struct yaffs_ext_tags local_tags;
-
 	struct yaffs_dev *dev = in->my_dev;
 	int ret_val = -1;
 
@@ -1048,18 +1016,17 @@
 
 	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
 
-	if (tn) {
+	if (!tn)
+		return ret_val;
 
 		the_chunk = yaffs_get_group_base(dev, tn, inode_chunk);
 
-		ret_val =
-		    yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
+	ret_val = yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
 					      inode_chunk);
 
 		/* Delete the entry in the filestructure (if found) */
 		if (ret_val != -1)
 			yaffs_load_tnode_0(dev, tn, inode_chunk, 0);
-	}
 
 	return ret_val;
 }
@@ -1082,14 +1049,15 @@
 	unsigned existing_serial, new_serial;
 
 	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE) {
-		/* Just ignore an attempt at putting a chunk into a non-file during scanning
+		/* Just ignore an attempt at putting a chunk into a non-file
+		 * during scanning.
 		 * If it is not during Scanning then something went wrong!
 		 */
 		if (!in_scan) {
 			yaffs_trace(YAFFS_TRACE_ERROR,
 				"yaffs tragedy:attempt to put data chunk into a non-file"
 				);
-			YBUG();
+			BUG();
 		}
 
 		yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
@@ -1110,23 +1078,29 @@
 
 	if (in_scan != 0) {
 		/* If we're scanning then we need to test for duplicates
-		 * NB This does not need to be efficient since it should only ever
+		 * NB This does not need to be efficient since it should only
 		 * happen when the power fails during a write, then only one
 		 * chunk should ever be affected.
 		 *
-		 * Correction for YAFFS2: This could happen quite a lot and we need to think about efficiency! TODO
-		 * Update: For backward scanning we don't need to re-read tags so this is quite cheap.
+		 * Correction for YAFFS2: This could happen quite a lot and we
+		 * need to think about efficiency! TODO
+		 * Update: For backward scanning we don't need to re-read tags
+		 * so this is quite cheap.
 		 */
 
 		if (existing_cunk > 0) {
-			/* NB Right now existing chunk will not be real chunk_id if the chunk group size > 1
-			 *    thus we have to do a FindChunkInFile to get the real chunk id.
+			/* NB Right now existing chunk will not be real
+			 * chunk_id if the chunk group size > 1
+			 * thus we have to do a FindChunkInFile to get the
+			 * real chunk id.
 			 *
-			 * We have a duplicate now we need to decide which one to use:
+			 * We have a duplicate now we need to decide which
+			 * one to use:
 			 *
-			 * Backwards scanning YAFFS2: The old one is what we use, dump the new one.
-			 * Forward scanning YAFFS2: The new one is what we use, dump the old one.
-			 * YAFFS1: Get both sets of tags and compare serial numbers.
+			 * Backwards scanning YAFFS2: The old one is what
+			 * we use, dump the new one.
+			 * YAFFS1: Get both sets of tags and compare serial
+			 * numbers.
 			 */
 
 			if (in_scan > 0) {
@@ -1150,8 +1124,8 @@
 
 			}
 
-			/* NB The deleted flags should be false, otherwise the chunks will
-			 * not be loaded during a scan
+			/* NB The deleted flags should be false, otherwise
+			 * the chunks will not be loaded during a scan
 			 */
 
 			if (in_scan > 0) {
@@ -1164,14 +1138,16 @@
 			     ((existing_serial + 1) & 3) == new_serial)) {
 				/* Forward scanning.
 				 * Use new
-				 * Delete the old one and drop through to update the tnode
+				 * Delete the old one and drop through to
+				 * update the tnode
 				 */
 				yaffs_chunk_del(dev, existing_cunk, 1,
 						__LINE__);
 			} else {
-				/* Backward scanning or we want to use the existing one
-				 * Use existing.
-				 * Delete the new one and return early so that the tnode isn't changed
+				/* Backward scanning or we want to use the
+				 * existing one
+				 * Delete the new one and return early so that
+				 * the tnode isn't changed
 				 */
 				yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
 				return YAFFS_OK;
@@ -1204,10 +1180,12 @@
 	}
 }
 
-/* SoftDeleteWorker scans backwards through the tnode tree and soft deletes all the chunks in the file.
- * All soft deleting does is increment the block's softdelete count and pulls the chunk out
- * of the tnode.
- * Thus, essentially this is the same as DeleteWorker except that the chunks are soft deleted.
+/* SoftDeleteWorker scans backwards through the tnode tree and soft deletes all
+ * the chunks in the file.
+ * All soft deleting does is increment the block's softdelete count and pulls
+ * the chunk out of the tnode.
+ * Thus, essentially this is the same as DeleteWorker except that the chunks
+ * are soft deleted.
  */
 
 static int yaffs_soft_del_worker(struct yaffs_obj *in, struct yaffs_tnode *tn,
@@ -1218,54 +1196,42 @@
 	int all_done = 1;
 	struct yaffs_dev *dev = in->my_dev;
 
-	if (tn) {
-		if (level > 0) {
+	if (!tn)
+		return 1;
 
-			for (i = YAFFS_NTNODES_INTERNAL - 1; all_done && i >= 0;
+	if (level > 0) {
+		for (i = YAFFS_NTNODES_INTERNAL - 1;
+			all_done && i >= 0;
 			     i--) {
 				if (tn->internal[i]) {
 					all_done =
 					    yaffs_soft_del_worker(in,
-								  tn->internal
-								  [i],
+					tn->internal[i],
 								  level - 1,
-								  (chunk_offset
-								   <<
+					(chunk_offset <<
 								   YAFFS_TNODES_INTERNAL_BITS)
 								  + i);
 					if (all_done) {
 						yaffs_free_tnode(dev,
-								 tn->internal
-								 [i]);
+						tn->internal[i]);
 						tn->internal[i] = NULL;
 					} else {
-						/* Hoosterman... how could this happen? */
+					/* Can this happen? */
 					}
 				}
 			}
 			return (all_done) ? 1 : 0;
-		} else if (level == 0) {
+	}
 
+	/* level 0 */
 			for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0; i--) {
 				the_chunk = yaffs_get_group_base(dev, tn, i);
 				if (the_chunk) {
-					/* Note this does not find the real chunk, only the chunk group.
-					 * We make an assumption that a chunk group is not larger than
-					 * a block.
-					 */
 					yaffs_soft_del_chunk(dev, the_chunk);
 					yaffs_load_tnode_0(dev, tn, i, 0);
 				}
-
-			}
-			return 1;
-
-		}
-
 	}
-
 	return 1;
-
 }
 
 static void yaffs_remove_obj_from_dir(struct yaffs_obj *obj)
@@ -1293,19 +1259,19 @@
 		yaffs_trace(YAFFS_TRACE_ALWAYS,
 			"tragedy: Trying to add an object to a null pointer directory"
 			);
-		YBUG();
+		BUG();
 		return;
 	}
 	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
 		yaffs_trace(YAFFS_TRACE_ALWAYS,
 			"tragedy: Trying to add an object to a non-directory"
 			);
-		YBUG();
+		BUG();
 	}
 
 	if (obj->siblings.prev == NULL) {
 		/* Not initialised */
-		YBUG();
+		BUG();
 	}
 
 	yaffs_verify_dir(directory);
@@ -1329,11 +1295,10 @@
 
 static int yaffs_change_obj_name(struct yaffs_obj *obj,
 				 struct yaffs_obj *new_dir,
-				 const YCHAR * new_name, int force, int shadows)
+				 const YCHAR *new_name, int force, int shadows)
 {
 	int unlink_op;
 	int del_op;
-
 	struct yaffs_obj *existing_target;
 
 	if (new_dir == NULL)
@@ -1343,49 +1308,39 @@
 		yaffs_trace(YAFFS_TRACE_ALWAYS,
 			"tragedy: yaffs_change_obj_name: new_dir is not a directory"
 			);
-		YBUG();
+		BUG();
 	}
 
-	/* TODO: Do we need this different handling for YAFFS2 and YAFFS1?? */
-	if (obj->my_dev->param.is_yaffs2)
 		unlink_op = (new_dir == obj->my_dev->unlinked_dir);
-	else
-		unlink_op = (new_dir == obj->my_dev->unlinked_dir
-			     && obj->variant_type == YAFFS_OBJECT_TYPE_FILE);
-
 	del_op = (new_dir == obj->my_dev->del_dir);
 
 	existing_target = yaffs_find_by_name(new_dir, new_name);
 
 	/* If the object is a file going into the unlinked directory,
-	 *   then it is OK to just stuff it in since duplicate names are allowed.
-	 *   else only proceed if the new name does not exist and if we're putting
+	 *   then it is OK to just stuff it in since duplicate names are OK.
+	 *   else only proceed if the new name does not exist and we're putting
 	 *   it into a directory.
 	 */
-	if ((unlink_op ||
-	     del_op ||
-	     force ||
-	     (shadows > 0) ||
-	     !existing_target) &&
-	    new_dir->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY) {
+	if (!(unlink_op || del_op || force ||
+	      shadows > 0 || !existing_target) ||
+	      new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
+		return YAFFS_FAIL;
+
 		yaffs_set_obj_name(obj, new_name);
 		obj->dirty = 1;
-
 		yaffs_add_obj_to_dir(new_dir, obj);
 
 		if (unlink_op)
 			obj->unlinked = 1;
 
-		/* If it is a deletion then we mark it as a shrink for gc purposes. */
-		if (yaffs_update_oh(obj, new_name, 0, del_op, shadows, NULL) >=
-		    0)
+	/* If it is a deletion then we mark it as a shrink for gc  */
+	if (yaffs_update_oh(obj, new_name, 0, del_op, shadows, NULL) >= 0)
 			return YAFFS_OK;
-	}
 
 	return YAFFS_FAIL;
 }
 
-/*------------------------ Short Operations Cache ----------------------------------------
+/*------------------------ Short Operations Cache ------------------------------
  *   In many situations where there is no high level buffering  a lot of
  *   reads might be short sequential reads, and a lot of writes may be short
  *   sequential writes. eg. scanning/writing a jpeg file.
@@ -1394,7 +1349,7 @@
  *   In Linux, the page cache provides read buffering and the short op cache 
  *   provides write buffering.
  *
- *   There are a limited number (~10) of cache chunks per device so that we don't
+ *   There are a small number (~10) of cache chunks per device so that we don't
  *   need a very intelligent search.
  */
 
@@ -1423,17 +1378,17 @@
 	int chunk_written = 0;
 	int n_caches = obj->my_dev->param.n_caches;
 
-	if (n_caches > 0) {
+	if (n_caches < 1)
+		return;
 		do {
 			cache = NULL;
 
-			/* Find the dirty cache for this object with the lowest chunk id. */
+		/* Find the lowest dirty chunk for this object */
 			for (i = 0; i < n_caches; i++) {
 				if (dev->cache[i].object == obj &&
 				    dev->cache[i].dirty) {
-					if (!cache
-					    || dev->cache[i].chunk_id <
-					    lowest) {
+				if (!cache ||
+				    dev->cache[i].chunk_id < lowest) {
 						cache = &dev->cache[i];
 						lowest = cache->chunk_id;
 					}
@@ -1442,7 +1397,6 @@
 
 			if (cache && !cache->locked) {
 				/* Write it out and free it up */
-
 				chunk_written =
 				    yaffs_wr_data_obj(cache->object,
 						      cache->chunk_id,
@@ -1451,16 +1405,12 @@
 				cache->dirty = 0;
 				cache->object = NULL;
 			}
-
 		} while (cache && chunk_written > 0);
 
 		if (cache)
 			/* Hoosterman, disk full while writing cache out. */
 			yaffs_trace(YAFFS_TRACE_ERROR,
 				"yaffs tragedy: no space during cache write");
-
-	}
-
 }
 
 /*yaffs_flush_whole_cache(dev)
@@ -1482,11 +1432,9 @@
 		for (i = 0; i < n_caches && !obj; i++) {
 			if (dev->cache[i].object && dev->cache[i].dirty)
 				obj = dev->cache[i].object;
-
 		}
 		if (obj)
 			yaffs_flush_file_cache(obj);
-
 	} while (obj);
 
 }
@@ -1506,7 +1454,6 @@
 				return &dev->cache[i];
 		}
 	}
-
 	return NULL;
 }
 
@@ -1518,21 +1465,23 @@
 	int i;
 	int pushout;
 
-	if (dev->param.n_caches > 0) {
+	if (dev->param.n_caches < 1)
+		return NULL;
+
 		/* Try find a non-dirty one... */
 
 		cache = yaffs_grab_chunk_worker(dev);
 
 		if (!cache) {
-			/* They were all dirty, find the last recently used object and flush
+		/* They were all dirty, find the LRU object and flush
 			 * its cache, then  find again.
-			 * NB what's here is not very accurate, we actually flush the object
-			 * the last recently used page.
+		 * NB what's here is not very accurate,
+		 * we actually flush the object with the LRU chunk.
 			 */
 
-			/* With locking we can't assume we can use entry zero */
-
-			the_obj = NULL;
+		/* With locking we can't assume we can use entry zero,
+		 * Set the_obj to a valid pointer for Coverity. */
+		the_obj = dev->cache[0].object;
 			usage = -1;
 			cache = NULL;
 			pushout = -1;
@@ -1540,8 +1489,8 @@
 			for (i = 0; i < dev->param.n_caches; i++) {
 				if (dev->cache[i].object &&
 				    !dev->cache[i].locked &&
-				    (dev->cache[i].last_use < usage
-				     || !cache)) {
+			    (dev->cache[i].last_use < usage ||
+			    !cache)) {
 					usage = dev->cache[i].last_use;
 					the_obj = dev->cache[i].object;
 					cache = &dev->cache[i];
@@ -1554,12 +1503,8 @@
 				yaffs_flush_file_cache(the_obj);
 				cache = yaffs_grab_chunk_worker(dev);
 			}
-
 		}
 		return cache;
-	} else {
-		return NULL;
-        }
 }
 
 /* Find a cached chunk */
@@ -1568,7 +1513,10 @@
 {
 	struct yaffs_dev *dev = obj->my_dev;
 	int i;
-	if (dev->param.n_caches > 0) {
+
+	if (dev->param.n_caches < 1)
+		return NULL;
+
 		for (i = 0; i < dev->param.n_caches; i++) {
 			if (dev->cache[i].object == obj &&
 			    dev->cache[i].chunk_id == chunk_id) {
@@ -1577,7 +1525,6 @@
 				return &dev->cache[i];
 			}
 		}
-	}
 	return NULL;
 }
 
@@ -1585,24 +1532,24 @@
 static void yaffs_use_cache(struct yaffs_dev *dev, struct yaffs_cache *cache,
 			    int is_write)
 {
+	int i;
 
-	if (dev->param.n_caches > 0) {
-		if (dev->cache_last_use < 0 || dev->cache_last_use > 100000000) {
+	if (dev->param.n_caches < 1)
+		return;
+
+	if (dev->cache_last_use < 0 ||
+		dev->cache_last_use > 100000000) {
 			/* Reset the cache usages */
-			int i;
 			for (i = 1; i < dev->param.n_caches; i++)
 				dev->cache[i].last_use = 0;
 
 			dev->cache_last_use = 0;
 		}
-
 		dev->cache_last_use++;
-
 		cache->last_use = dev->cache_last_use;
 
 		if (is_write)
 			cache->dirty = 1;
-	}
 }
 
 /* Invalidate a single cache page.
@@ -1611,9 +1558,10 @@
  */
 static void yaffs_invalidate_chunk_cache(struct yaffs_obj *object, int chunk_id)
 {
+	struct yaffs_cache *cache;
+
 	if (object->my_dev->param.n_caches > 0) {
-		struct yaffs_cache *cache =
-		    yaffs_find_chunk_cache(object, chunk_id);
+		cache = yaffs_find_chunk_cache(object, chunk_id);
 
 		if (cache)
 			cache->object = NULL;
@@ -1653,17 +1601,19 @@
 /*  FreeObject frees up a Object and puts it back on the free list */
 static void yaffs_free_obj(struct yaffs_obj *obj)
 {
-	struct yaffs_dev *dev = obj->my_dev;
+	struct yaffs_dev *dev;
 
+	if (!obj) {
+		BUG();
+		return;
+	}
+	dev = obj->my_dev;
 	yaffs_trace(YAFFS_TRACE_OS, "FreeObject %p inode %p",
 		obj, obj->my_inode);
-
-	if (!obj)
-		YBUG();
 	if (obj->parent)
-		YBUG();
+		BUG();
 	if (!list_empty(&obj->siblings))
-		YBUG();
+		BUG();
 
 	if (obj->my_inode) {
 		/* We're still hooked up to a cached inode.
@@ -1688,15 +1638,13 @@
 
 static int yaffs_generic_obj_del(struct yaffs_obj *in)
 {
-
-	/* First off, invalidate the file's data in the cache, without flushing. */
+	/* Iinvalidate the file's data in the cache, without flushing. */
 	yaffs_invalidate_whole_cache(in);
 
-	if (in->my_dev->param.is_yaffs2 && (in->parent != in->my_dev->del_dir)) {
-		/* Move to the unlinked directory so we have a record that it was deleted. */
+	if (in->my_dev->param.is_yaffs2 && in->parent != in->my_dev->del_dir) {
+		/* Move to unlinked directory so we have a deletion record */
 		yaffs_change_obj_name(in, in->my_dev->del_dir, _Y("deleted"), 0,
 				      0);
-
 	}
 
 	yaffs_remove_obj_from_dir(in);
@@ -1710,13 +1658,15 @@
 
 static void yaffs_soft_del_file(struct yaffs_obj *obj)
 {
-	if (obj->deleted &&
-	    obj->variant_type == YAFFS_OBJECT_TYPE_FILE && !obj->soft_del) {
+	if (!obj->deleted ||
+	    obj->variant_type != YAFFS_OBJECT_TYPE_FILE ||
+	    obj->soft_del)
+		return;
+
 		if (obj->n_data_chunks <= 0) {
 			/* Empty file with no duplicate object headers,
 			 * just delete it immediately */
-			yaffs_free_tnode(obj->my_dev,
-					 obj->variant.file_variant.top);
+		yaffs_free_tnode(obj->my_dev, obj->variant.file_variant.top);
 			obj->variant.file_variant.top = NULL;
 			yaffs_trace(YAFFS_TRACE_TRACING,
 				"yaffs: Deleting empty file %d",
@@ -1729,7 +1679,6 @@
 					      file_variant.top_level, 0);
 			obj->soft_del = 1;
 		}
-	}
 }
 
 /* Pruning removes any part of the file structure tree that is beyond the
@@ -1754,7 +1703,9 @@
 	int i;
 	int has_data;
 
-	if (tn) {
+	if (!tn)
+		return tn;
+
 		has_data = 0;
 
 		if (level > 0) {
@@ -1764,8 +1715,7 @@
 					    yaffs_prune_worker(dev,
 							       tn->internal[i],
 							       level - 1,
-							       (i ==
-								0) ? del0 : 1);
+						(i == 0) ? del0 : 1);
 				}
 
 				if (tn->internal[i])
@@ -1783,15 +1733,10 @@
 
 		if (has_data == 0 && del0) {
 			/* Free and return NULL */
-
 			yaffs_free_tnode(dev, tn);
 			tn = NULL;
 		}
-
-	}
-
 	return tn;
-
 }
 
 static int yaffs_prune_tree(struct yaffs_dev *dev,
@@ -1802,13 +1747,14 @@
 	int done = 0;
 	struct yaffs_tnode *tn;
 
-	if (file_struct->top_level > 0) {
+	if (file_struct->top_level < 1)
+		return YAFFS_OK;
+
 		file_struct->top =
-		    yaffs_prune_worker(dev, file_struct->top,
-				       file_struct->top_level, 0);
+	   yaffs_prune_worker(dev, file_struct->top, file_struct->top_level, 0);
 
-		/* Now we have a tree with all the non-zero branches NULL but the height
-		 * is the same as it was.
+	/* Now we have a tree with all the non-zero branches NULL but
+	 * the height is the same as it was.
 		 * Let's see if we can trim internal tnodes to shorten the tree.
 		 * We can do this if only the 0th element in the tnode is in use
 		 * (ie all the non-zero are NULL)
@@ -1831,19 +1777,20 @@
 				done = 1;
 			}
 		}
-	}
 
 	return YAFFS_OK;
 }
 
 /*-------------------- End of File Structure functions.-------------------*/
 
-/* AllocateEmptyObject gets us a clean Object. Tries to make allocate more if we run out */
+/* alloc_empty_obj gets us a clean Object.*/
 static struct yaffs_obj *yaffs_alloc_empty_obj(struct yaffs_dev *dev)
 {
 	struct yaffs_obj *obj = yaffs_alloc_raw_obj(dev);
 
-	if (obj) {
+	if (!obj)
+		return obj;
+
 		dev->n_obj++;
 
 		/* Now sweeten it up... */
@@ -1873,7 +1820,6 @@
 			yaffs_add_obj_to_dir(dev->lost_n_found, obj);
 
 		obj->being_created = 0;
-	}
 
 	dev->checkpoint_blocks_required = 0;	/* force recalculation */
 
@@ -1897,7 +1843,6 @@
 			lowest = dev->obj_bucket[dev->bucket_finder].count;
 			l = dev->bucket_finder;
 		}
-
 	}
 
 	return l;
@@ -1906,17 +1851,13 @@
 static int yaffs_new_obj_id(struct yaffs_dev *dev)
 {
 	int bucket = yaffs_find_nice_bucket(dev);
-
-	/* Now find an object value that has not already been taken
-	 * by scanning the list.
-	 */
-
 	int found = 0;
 	struct list_head *i;
-
 	u32 n = (u32) bucket;
 
-	/* yaffs_check_obj_hash_sane();  */
+	/* Now find an object value that has not already been taken
+	 * by scanning the list.
+	 */
 
 	while (!found) {
 		found = 1;
@@ -1931,7 +1872,6 @@
 			}
 		}
 	}
-
 	return n;
 }
 
@@ -1952,23 +1892,19 @@
 
 	list_for_each(i, &dev->obj_bucket[bucket].list) {
 		/* Look if it is in the list */
-		if (i) {
 			in = list_entry(i, struct yaffs_obj, hash_link);
 			if (in->obj_id == number) {
-
-				/* Don't tell the VFS about this one if it is defered free */
+			/* Don't show if it is defered free */
 				if (in->defered_free)
 					return NULL;
-
 				return in;
 			}
 		}
-	}
 
 	return NULL;
 }
 
-struct yaffs_obj *yaffs_new_obj(struct yaffs_dev *dev, int number,
+static struct yaffs_obj *yaffs_new_obj(struct yaffs_dev *dev, int number,
 				enum yaffs_obj_type type)
 {
 	struct yaffs_obj *the_obj = NULL;
@@ -1990,7 +1926,6 @@
 		return NULL;
 	}
 
-	if (the_obj) {
 		the_obj->fake = 0;
 		the_obj->rename_allowed = 1;
 		the_obj->unlink_allowed = 1;
@@ -2003,7 +1938,8 @@
 		case YAFFS_OBJECT_TYPE_FILE:
 			the_obj->variant.file_variant.file_size = 0;
 			the_obj->variant.file_variant.scanned_size = 0;
-			the_obj->variant.file_variant.shrink_size = ~0;	/* max */
+		the_obj->variant.file_variant.shrink_size =
+						yaffs_max_file_size(dev);
 			the_obj->variant.file_variant.top_level = 0;
 			the_obj->variant.file_variant.top = tn;
 			break;
@@ -2020,8 +1956,6 @@
 			/* todo this should not happen */
 			break;
 		}
-	}
-
 	return the_obj;
 }
 
@@ -2031,17 +1965,18 @@
 
 	struct yaffs_obj *obj =
 	    yaffs_new_obj(dev, number, YAFFS_OBJECT_TYPE_DIRECTORY);
-	if (obj) {
-		obj->fake = 1;	/* it is fake so it might have no NAND presence... */
-		obj->rename_allowed = 0;	/* ... and we're not allowed to rename it... */
-		obj->unlink_allowed = 0;	/* ... or unlink it */
+
+	if (!obj)
+		return NULL;
+
+	obj->fake = 1;	/* it is fake so it might not use NAND */
+	obj->rename_allowed = 0;
+	obj->unlink_allowed = 0;
 		obj->deleted = 0;
 		obj->unlinked = 0;
 		obj->yst_mode = mode;
 		obj->my_dev = dev;
 		obj->hdr_chunk = 0;	/* Not a valid chunk. */
-	}
-
 	return obj;
 
 }
@@ -2053,7 +1988,6 @@
 
 	dev->n_obj = 0;
 	dev->n_tnodes = 0;
-
 	yaffs_init_raw_tnodes_and_objs(dev);
 
 	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
@@ -2078,7 +2012,7 @@
 
 }
 
-YCHAR *yaffs_clone_str(const YCHAR * str)
+YCHAR *yaffs_clone_str(const YCHAR *str)
 {
 	YCHAR *new_str = NULL;
 	int len;
@@ -2114,6 +2048,7 @@
 static void yaffs_update_parent(struct yaffs_obj *obj)
 {
 	struct yaffs_dev *dev;
+
 	if (!obj)
 		return;
 	dev = obj->my_dev;
@@ -2168,19 +2103,19 @@
 
 static struct yaffs_obj *yaffs_create_obj(enum yaffs_obj_type type,
 					  struct yaffs_obj *parent,
-					  const YCHAR * name,
+					  const YCHAR *name,
 					  u32 mode,
 					  u32 uid,
 					  u32 gid,
 					  struct yaffs_obj *equiv_obj,
-					  const YCHAR * alias_str, u32 rdev)
+					  const YCHAR *alias_str, u32 rdev)
 {
 	struct yaffs_obj *in;
 	YCHAR *str = NULL;
-
 	struct yaffs_dev *dev = parent->my_dev;
 
-	/* Check if the entry exists. If it does then fail the call since we don't want a dup. */
+	/* Check if the entry exists.
+	 * If it does then fail the call since we don't want a dup. */
 	if (yaffs_find_by_name(parent, name))
 		return NULL;
 
@@ -2193,12 +2128,10 @@
 	in = yaffs_new_obj(dev, -1, type);
 
 	if (!in) {
-		if (str)
 			kfree(str);
 		return NULL;
 	}
 
-	if (in) {
 		in->hdr_chunk = 0;
 		in->valid = 1;
 		in->variant_type = type;
@@ -2222,8 +2155,7 @@
 			break;
 		case YAFFS_OBJECT_TYPE_HARDLINK:
 			in->variant.hardlink_variant.equiv_obj = equiv_obj;
-			in->variant.hardlink_variant.equiv_id =
-			    equiv_obj->obj_id;
+		in->variant.hardlink_variant.equiv_id = equiv_obj->obj_id;
 			list_add(&in->hard_links, &equiv_obj->hard_links);
 			break;
 		case YAFFS_OBJECT_TYPE_FILE:
@@ -2235,26 +2167,26 @@
 		}
 
 		if (yaffs_update_oh(in, name, 0, 0, 0, NULL) < 0) {
-			/* Could not create the object header, fail the creation */
+		/* Could not create the object header, fail */
 			yaffs_del_obj(in);
 			in = NULL;
 		}
 
+	if (in)
 		yaffs_update_parent(parent);
-	}
 
 	return in;
 }
 
 struct yaffs_obj *yaffs_create_file(struct yaffs_obj *parent,
-				    const YCHAR * name, u32 mode, u32 uid,
+				    const YCHAR *name, u32 mode, u32 uid,
 				    u32 gid)
 {
 	return yaffs_create_obj(YAFFS_OBJECT_TYPE_FILE, parent, name, mode,
 				uid, gid, NULL, NULL, 0);
 }
 
-struct yaffs_obj *yaffs_create_dir(struct yaffs_obj *parent, const YCHAR * name,
+struct yaffs_obj *yaffs_create_dir(struct yaffs_obj *parent, const YCHAR *name,
 				   u32 mode, u32 uid, u32 gid)
 {
 	return yaffs_create_obj(YAFFS_OBJECT_TYPE_DIRECTORY, parent, name,
@@ -2262,7 +2194,7 @@
 }
 
 struct yaffs_obj *yaffs_create_special(struct yaffs_obj *parent,
-				       const YCHAR * name, u32 mode, u32 uid,
+				       const YCHAR *name, u32 mode, u32 uid,
 				       u32 gid, u32 rdev)
 {
 	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SPECIAL, parent, name, mode,
@@ -2270,8 +2202,8 @@
 }
 
 struct yaffs_obj *yaffs_create_symlink(struct yaffs_obj *parent,
-				       const YCHAR * name, u32 mode, u32 uid,
-				       u32 gid, const YCHAR * alias)
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, const YCHAR *alias)
 {
 	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SYMLINK, parent, name, mode,
 				uid, gid, NULL, alias, 0);
@@ -2281,22 +2213,40 @@
 struct yaffs_obj *yaffs_link_obj(struct yaffs_obj *parent, const YCHAR * name,
 				 struct yaffs_obj *equiv_obj)
 {
-	/* Get the real object in case we were fed a hard link as an equivalent object */
+	/* Get the real object in case we were fed a hard link obj */
 	equiv_obj = yaffs_get_equivalent_obj(equiv_obj);
 
-	if (yaffs_create_obj
-	    (YAFFS_OBJECT_TYPE_HARDLINK, parent, name, 0, 0, 0,
-	     equiv_obj, NULL, 0)) {
+	if (yaffs_create_obj(YAFFS_OBJECT_TYPE_HARDLINK,
+			parent, name, 0, 0, 0,
+			equiv_obj, NULL, 0))
 		return equiv_obj;
-	} else {
+
 		return NULL;
-	}
 
 }
 
 
 
-/*------------------------- Block Management and Page Allocation ----------------*/
+/*---------------------- Block Management and Page Allocation -------------*/
+
+static void yaffs_deinit_blocks(struct yaffs_dev *dev)
+{
+	if (dev->block_info_alt && dev->block_info)
+		vfree(dev->block_info);
+	else
+		kfree(dev->block_info);
+
+	dev->block_info_alt = 0;
+
+	dev->block_info = NULL;
+
+	if (dev->chunk_bits_alt && dev->chunk_bits)
+		vfree(dev->chunk_bits);
+	else
+		kfree(dev->chunk_bits);
+	dev->chunk_bits_alt = 0;
+	dev->chunk_bits = NULL;
+}
 
 static int yaffs_init_blocks(struct yaffs_dev *dev)
 {
@@ -2304,7 +2254,6 @@
 
 	dev->block_info = NULL;
 	dev->chunk_bits = NULL;
-
 	dev->alloc_block = -1;	/* force it to get a new one */
 
 	/* If the first allocation strategy fails, thry the alternate one */
@@ -2318,7 +2267,9 @@
 		dev->block_info_alt = 0;
         }
 
-	if (dev->block_info) {
+	if (!dev->block_info)
+		goto alloc_error;
+
 		/* Set up dynamic blockinfo stuff. Round up bytes. */
 		dev->chunk_bit_stride = (dev->param.chunks_per_block + 7) / 8;
 		dev->chunk_bits =
@@ -2330,42 +2281,25 @@
 		} else {
 			dev->chunk_bits_alt = 0;
                 }
-	}
+	if (!dev->chunk_bits)
+		goto alloc_error;
+
 
-	if (dev->block_info && dev->chunk_bits) {
-		memset(dev->block_info, 0,
-		       n_blocks * sizeof(struct yaffs_block_info));
+	memset(dev->block_info, 0, n_blocks * sizeof(struct yaffs_block_info));
 		memset(dev->chunk_bits, 0, dev->chunk_bit_stride * n_blocks);
 		return YAFFS_OK;
-	}
 
+alloc_error:
+	yaffs_deinit_blocks(dev);
 	return YAFFS_FAIL;
 }
 
-static void yaffs_deinit_blocks(struct yaffs_dev *dev)
-{
-	if (dev->block_info_alt && dev->block_info)
-		vfree(dev->block_info);
-	else if (dev->block_info)
-		kfree(dev->block_info);
-
-	dev->block_info_alt = 0;
-
-	dev->block_info = NULL;
-
-	if (dev->chunk_bits_alt && dev->chunk_bits)
-		vfree(dev->chunk_bits);
-	else if (dev->chunk_bits)
-		kfree(dev->chunk_bits);
-	dev->chunk_bits_alt = 0;
-	dev->chunk_bits = NULL;
-}
 
 void yaffs_block_became_dirty(struct yaffs_dev *dev, int block_no)
 {
 	struct yaffs_block_info *bi = yaffs_get_block_info(dev, block_no);
-
 	int erased_ok = 0;
+	int i;
 
 	/* If the block is still healthy erase it and mark as clean.
 	 * If the block has had a data failure, then retire it.
@@ -2380,11 +2314,12 @@
 
 	bi->block_state = YAFFS_BLOCK_STATE_DIRTY;
 
-	/* If this is the block being garbage collected then stop gc'ing this block */
+	/* If this is the block being garbage collected then stop gc'ing */
 	if (block_no == dev->gc_block)
 		dev->gc_block = 0;
 
-	/* If this block is currently the best candidate for gc then drop as a candidate */
+	/* If this block is currently the best candidate for gc
+	 * then drop as a candidate */
 	if (block_no == dev->gc_dirtiest) {
 		dev->gc_dirtiest = 0;
 		dev->gc_pages_in_use = 0;
@@ -2400,13 +2335,13 @@
 		}
 	}
 
+	/* Verify erasure if needed */
 	if (erased_ok &&
-	    ((yaffs_trace_mask & YAFFS_TRACE_ERASE)
-	     || !yaffs_skip_verification(dev))) {
-		int i;
+	    ((yaffs_trace_mask & YAFFS_TRACE_ERASE) ||
+	     !yaffs_skip_verification(dev))) {
 		for (i = 0; i < dev->param.chunks_per_block; i++) {
-			if (!yaffs_check_chunk_erased
-			    (dev, block_no * dev->param.chunks_per_block + i)) {
+			if (!yaffs_check_chunk_erased(dev,
+				block_no * dev->param.chunks_per_block + i)) {
 				yaffs_trace(YAFFS_TRACE_ERROR,
 					">>Block %d erasure supposedly OK, but chunk %d not erased",
 					block_no, i);
@@ -2414,99 +2349,45 @@
 		}
 	}
 
-	if (erased_ok) {
-		/* Clean it up... */
-		bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
-		bi->seq_number = 0;
-		dev->n_erased_blocks++;
-		bi->pages_in_use = 0;
-		bi->soft_del_pages = 0;
-		bi->has_shrink_hdr = 0;
-		bi->skip_erased_check = 1;	/* Clean, so no need to check */
-		bi->gc_prioritise = 0;
-		yaffs_clear_chunk_bits(dev, block_no);
-
-		yaffs_trace(YAFFS_TRACE_ERASE,
-			"Erased block %d", block_no);
-	} else {
+	if (!erased_ok) {
 		/* We lost a block of free space */
 		dev->n_free_chunks -= dev->param.chunks_per_block;
 		yaffs_retire_block(dev, block_no);
 		yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
 			"**>> Block %d retired", block_no);
-	}
-}
-
-
-
-static int yaffs_gc_block(struct yaffs_dev *dev, int block, int whole_block)
-{
-	int old_chunk;
-	int new_chunk;
-	int mark_flash;
-	int ret_val = YAFFS_OK;
-	int i;
-	int is_checkpt_block;
-	int matching_chunk;
-	int max_copies;
-
-	int chunks_before = yaffs_get_erased_chunks(dev);
-	int chunks_after;
-
-	struct yaffs_ext_tags tags;
-
-	struct yaffs_block_info *bi = yaffs_get_block_info(dev, block);
-
-	struct yaffs_obj *object;
-
-	is_checkpt_block = (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT);
-
-	yaffs_trace(YAFFS_TRACE_TRACING,
-		"Collecting block %d, in use %d, shrink %d, whole_block %d",
-		block, bi->pages_in_use, bi->has_shrink_hdr,
-		whole_block);
-
-	/*yaffs_verify_free_chunks(dev); */
-
-	if (bi->block_state == YAFFS_BLOCK_STATE_FULL)
-		bi->block_state = YAFFS_BLOCK_STATE_COLLECTING;
-
-	bi->has_shrink_hdr = 0;	/* clear the flag so that the block can erase */
-
-	dev->gc_disable = 1;
-
-	if (is_checkpt_block || !yaffs_still_some_chunks(dev, block)) {
-		yaffs_trace(YAFFS_TRACE_TRACING,
-			"Collecting block %d that has no chunks in use",
-		   	block);
-		yaffs_block_became_dirty(dev, block);
-	} else {
-
-		u8 *buffer = yaffs_get_temp_buffer(dev, __LINE__);
-
-		yaffs_verify_blk(dev, bi, block);
-
-		max_copies = (whole_block) ? dev->param.chunks_per_block : 5;
-		old_chunk = block * dev->param.chunks_per_block + dev->gc_chunk;
-
-		for ( /* init already done */ ;
-		     ret_val == YAFFS_OK &&
-		     dev->gc_chunk < dev->param.chunks_per_block &&
-		     (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) &&
-		     max_copies > 0; dev->gc_chunk++, old_chunk++) {
-			if (yaffs_check_chunk_bit(dev, block, dev->gc_chunk)) {
+		return;
+	}
 
-				/* This page is in use and might need to be copied off */
+	/* Clean it up... */
+	bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
+	bi->seq_number = 0;
+	dev->n_erased_blocks++;
+	bi->pages_in_use = 0;
+	bi->soft_del_pages = 0;
+	bi->has_shrink_hdr = 0;
+	bi->skip_erased_check = 1;	/* Clean, so no need to check */
+	bi->gc_prioritise = 0;
+	bi->has_summary = 0;
 
-				max_copies--;
+	yaffs_clear_chunk_bits(dev, block_no);
 
-				mark_flash = 1;
+	yaffs_trace(YAFFS_TRACE_ERASE, "Erased block %d", block_no);
+}
 
-				yaffs_init_tags(&tags);
+static inline int yaffs_gc_process_chunk(struct yaffs_dev *dev,
+					struct yaffs_block_info *bi,
+					int old_chunk, u8 *buffer)
+{
+	int new_chunk;
+	int mark_flash = 1;
+	struct yaffs_ext_tags tags;
+	struct yaffs_obj *object;
+	int matching_chunk;
+	int ret_val = YAFFS_OK;
 
+	memset(&tags, 0, sizeof(tags));
 				yaffs_rd_chunk_tags_nand(dev, old_chunk,
 							 buffer, &tags);
-
 				object = yaffs_find_by_number(dev, tags.obj_id);
 
 				yaffs_trace(YAFFS_TRACE_GC_DETAIL,
@@ -2519,7 +2400,8 @@
 						matching_chunk =
 						    object->hdr_chunk;
 					else if (object->soft_del)
-						matching_chunk = old_chunk;	/* Defeat the test */
+			/* Defeat the test */
+			matching_chunk = old_chunk;
 					else
 						matching_chunk =
 						    yaffs_find_chunk_in_file
@@ -2533,7 +2415,6 @@
 							matching_chunk,
 							tags.obj_id,
 						   	tags.chunk_id);
-
 				}
 
 				if (!object) {
@@ -2547,128 +2428,153 @@
 				if (object &&
 				    object->deleted &&
 				    object->soft_del && tags.chunk_id != 0) {
-					/* Data chunk in a soft deleted file, throw it away
+		/* Data chunk in a soft deleted file,
+		 * throw it away.
 					 * It's a soft deleted data chunk,
-					 * No need to copy this, just forget about it and
-					 * fix up the object.
+		 * No need to copy this, just forget
+		 * about it and fix up the object.
 					 */
 
-					/* Free chunks already includes softdeleted chunks.
-					 * How ever this chunk is going to soon be really deleted
-					 * which will increment free chunks.
-					 * We have to decrement free chunks so this works out properly.
+		/* Free chunks already includes
+		 * softdeleted chunks, how ever this
+		 * chunk is going to soon be really
+		 * deleted which will increment free
+		 * chunks. We have to decrement free
+		 * chunks so this works out properly.
 					 */
 					dev->n_free_chunks--;
 					bi->soft_del_pages--;
 
 					object->n_data_chunks--;
-
 					if (object->n_data_chunks <= 0) {
-						/* remeber to clean up the object */
-						dev->gc_cleanup_list[dev->
-								     n_clean_ups]
-						    = tags.obj_id;
+			/* remeber to clean up obj */
+			dev->gc_cleanup_list[dev->n_clean_ups] = tags.obj_id;
 						dev->n_clean_ups++;
 					}
 					mark_flash = 0;
-				} else if (0) {
-					/* Todo object && object->deleted && object->n_data_chunks == 0 */
-					/* Deleted object header with no data chunks.
-					 * Can be discarded and the file deleted.
-					 */
-					object->hdr_chunk = 0;
-					yaffs_free_tnode(object->my_dev,
-							 object->
-							 variant.file_variant.
-							 top);
-					object->variant.file_variant.top = NULL;
-					yaffs_generic_obj_del(object);
-
 				} else if (object) {
-					/* It's either a data chunk in a live file or
-					 * an ObjectHeader, so we're interested in it.
-					 * NB Need to keep the ObjectHeaders of deleted files
-					 * until the whole file has been deleted off
+		/* It's either a data chunk in a live
+		 * file or an ObjectHeader, so we're
+		 * interested in it.
+		 * NB Need to keep the ObjectHeaders of
+		 * deleted files until the whole file
+		 * has been deleted off
 					 */
 					tags.serial_number++;
-
 					dev->n_gc_copies++;
 
 					if (tags.chunk_id == 0) {
 						/* It is an object Id,
-						 * We need to nuke the shrinkheader flags first
-						 * Also need to clean up shadowing.
-						 * We no longer want the shrink_header flag since its work is done
-						 * and if it is left in place it will mess up scanning.
+			 * We need to nuke the
+			 * shrinkheader flags since its
+			 * work is done.
+			 * Also need to clean up
+			 * shadowing.
 						 */
-
 						struct yaffs_obj_hdr *oh;
-						oh = (struct yaffs_obj_hdr *)
-						    buffer;
+			oh = (struct yaffs_obj_hdr *) buffer;
 
 						oh->is_shrink = 0;
 						tags.extra_is_shrink = 0;
-
 						oh->shadows_obj = 0;
 						oh->inband_shadowed_obj_id = 0;
 						tags.extra_shadows = 0;
 
 						/* Update file size */
-						if (object->variant_type ==
-						    YAFFS_OBJECT_TYPE_FILE) {
-							oh->file_size =
-							    object->variant.
-							    file_variant.
-							    file_size;
-							tags.extra_length =
-							    oh->file_size;
+			if (object->variant_type == YAFFS_OBJECT_TYPE_FILE) {
+				yaffs_oh_size_load(oh,
+				    object->variant.file_variant.file_size);
+				tags.extra_file_size =
+				    object->variant.file_variant.file_size;
 						}
 
-						yaffs_verify_oh(object, oh,
-								&tags, 1);
+			yaffs_verify_oh(object, oh, &tags, 1);
 						new_chunk =
-						    yaffs_write_new_chunk(dev,
-									  (u8 *)
-									  oh,
-									  &tags,
-									  1);
+			    yaffs_write_new_chunk(dev, (u8 *) oh, &tags, 1);
 					} else {
 						new_chunk =
-						    yaffs_write_new_chunk(dev,
-									  buffer,
-									  &tags,
-									  1);
+			    yaffs_write_new_chunk(dev, buffer, &tags, 1);
                                         }
 
 					if (new_chunk < 0) {
 						ret_val = YAFFS_FAIL;
 					} else {
 
-						/* Ok, now fix up the Tnodes etc. */
+			/* Now fix up the Tnodes etc. */
 
 						if (tags.chunk_id == 0) {
 							/* It's a header */
-							object->hdr_chunk =
-							    new_chunk;
-							object->serial =
-							    tags.serial_number;
+				object->hdr_chunk = new_chunk;
+				object->serial = tags.serial_number;
 						} else {
 							/* It's a data chunk */
-							int ok;
-							ok = yaffs_put_chunk_in_file(object, tags.chunk_id, new_chunk, 0);
+				yaffs_put_chunk_in_file(object, tags.chunk_id,
+							new_chunk, 0);
 						}
 					}
 				}
-
 				if (ret_val == YAFFS_OK)
-					yaffs_chunk_del(dev, old_chunk,
-							mark_flash, __LINE__);
+		yaffs_chunk_del(dev, old_chunk, mark_flash, __LINE__);
+	return ret_val;
+}
 
-			}
-		}
+static int yaffs_gc_block(struct yaffs_dev *dev, int block, int whole_block)
+{
+	int old_chunk;
+	int ret_val = YAFFS_OK;
+	int i;
+	int is_checkpt_block;
+	int max_copies;
+	int chunks_before = yaffs_get_erased_chunks(dev);
+	int chunks_after;
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, block);
+
+	is_checkpt_block = (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT);
+
+	yaffs_trace(YAFFS_TRACE_TRACING,
+		"Collecting block %d, in use %d, shrink %d, whole_block %d",
+		block, bi->pages_in_use, bi->has_shrink_hdr,
+		whole_block);
+
+	/*yaffs_verify_free_chunks(dev); */
+
+	if (bi->block_state == YAFFS_BLOCK_STATE_FULL)
+		bi->block_state = YAFFS_BLOCK_STATE_COLLECTING;
+
+	bi->has_shrink_hdr = 0;	/* clear the flag so that the block can erase */
+
+	dev->gc_disable = 1;
+
+	yaffs_summary_gc(dev, block);
+
+	if (is_checkpt_block || !yaffs_still_some_chunks(dev, block)) {
+		yaffs_trace(YAFFS_TRACE_TRACING,
+			"Collecting block %d that has no chunks in use",
+			block);
+		yaffs_block_became_dirty(dev, block);
+	} else {
+
+		u8 *buffer = yaffs_get_temp_buffer(dev);
+
+		yaffs_verify_blk(dev, bi, block);
 
-		yaffs_release_temp_buffer(dev, buffer, __LINE__);
+		max_copies = (whole_block) ? dev->param.chunks_per_block : 5;
+		old_chunk = block * dev->param.chunks_per_block + dev->gc_chunk;
 
+		for (/* init already done */ ;
+		     ret_val == YAFFS_OK &&
+		     dev->gc_chunk < dev->param.chunks_per_block &&
+		     (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) &&
+		     max_copies > 0;
+		     dev->gc_chunk++, old_chunk++) {
+			if (yaffs_check_chunk_bit(dev, block, dev->gc_chunk)) {
+				/* Page is in use and might need to be copied */
+				max_copies--;
+				ret_val = yaffs_gc_process_chunk(dev, bi,
+							old_chunk, buffer);
+			}
+		}
+		yaffs_release_temp_buffer(dev, buffer);
 	}
 
 	yaffs_verify_collected_blk(dev, bi, block);
@@ -2684,12 +2590,11 @@
 		/* Do any required cleanups */
 		for (i = 0; i < dev->n_clean_ups; i++) {
 			/* Time to delete the file too */
-			object =
+			struct yaffs_obj *object =
 			    yaffs_find_by_number(dev, dev->gc_cleanup_list[i]);
 			if (object) {
 				yaffs_free_tnode(dev,
-						 object->variant.
-						 file_variant.top);
+					  object->variant.file_variant.top);
 				object->variant.file_variant.top = NULL;
 				yaffs_trace(YAFFS_TRACE_GC,
 					"yaffs: About to finally delete object %d",
@@ -2699,7 +2604,6 @@
 			}
 
 		}
-
 		chunks_after = yaffs_get_erased_chunks(dev);
 		if (chunks_before >= chunks_after)
 			yaffs_trace(YAFFS_TRACE_GC,
@@ -2716,7 +2620,7 @@
 }
 
 /*
- * FindBlockForgarbageCollection is used to select the dirtiest block (or close enough)
+ * find_gc_block() selects the dirtiest block (or close enough)
  * for garbage collection.
  */
 
@@ -2751,8 +2655,8 @@
 
 		/*
 		 * If there is a prioritised block and none was selected then
-		 * this happened because there is at least one old dirty block gumming
-		 * up the works. Let's gc the oldest dirty block.
+		 * this happened because there is at least one old dirty block
+		 * gumming up the works. Let's gc the oldest dirty block.
 		 */
 
 		if (prioritised_exist &&
@@ -2763,9 +2667,9 @@
 			dev->has_pending_prioritised_gc = 0;
 	}
 
-	/* If we're doing aggressive GC then we are happy to take a less-dirty block, and
-	 * search harder.
-	 * else (we're doing a leasurely gc), then we only bother to do this if the
+	/* If we're doing aggressive GC then we are happy to take a less-dirty
+	 * block, and search harder.
+	 * else (leasurely gc), then we only bother to do this if the
 	 * block has only a few pages in use.
 	 */
 
@@ -2801,7 +2705,8 @@
 		for (i = 0;
 		     i < iterations &&
 		     (dev->gc_dirtiest < 1 ||
-		      dev->gc_pages_in_use > YAFFS_GC_GOOD_ENOUGH); i++) {
+		      dev->gc_pages_in_use > YAFFS_GC_GOOD_ENOUGH);
+		     i++) {
 			dev->gc_block_finder++;
 			if (dev->gc_block_finder < dev->internal_start_block ||
 			    dev->gc_block_finder > dev->internal_end_block)
@@ -2814,9 +2719,9 @@
 
 			if (bi->block_state == YAFFS_BLOCK_STATE_FULL &&
 			    pages_used < dev->param.chunks_per_block &&
-			    (dev->gc_dirtiest < 1
-			     || pages_used < dev->gc_pages_in_use)
-			    && yaffs_block_ok_for_gc(dev, bi)) {
+			    (dev->gc_dirtiest < 1 ||
+			     pages_used < dev->gc_pages_in_use) &&
+			    yaffs_block_ok_for_gc(dev, bi)) {
 				dev->gc_dirtiest = dev->gc_block_finder;
 				dev->gc_pages_in_use = pages_used;
 			}
@@ -2827,7 +2732,7 @@
 	}
 
 	/*
-	 * If nothing has been selected for a while, try selecting the oldest dirty
+	 * If nothing has been selected for a while, try the oldest dirty
 	 * because that's gumming up the works.
 	 */
 
@@ -2878,7 +2783,7 @@
  * If we're very low on erased blocks then we do aggressive garbage collection
  * otherwise we do "leasurely" garbage collection.
  * Aggressive gc looks further (whole array) and will accept less dirty blocks.
- * Passive gc only inspects smaller areas and will only accept more dirty blocks.
+ * Passive gc only inspects smaller areas and only accepts more dirty blocks.
  *
  * The idea is to help clear out space in a more spread-out manner.
  * Dunno if it really does anything useful.
@@ -2895,13 +2800,12 @@
 	if (dev->param.gc_control && (dev->param.gc_control(dev) & 1) == 0)
 		return YAFFS_OK;
 
-	if (dev->gc_disable) {
+	if (dev->gc_disable)
 		/* Bail out so we don't get recursive gc */
 		return YAFFS_OK;
-	}
 
 	/* This loop should pass the first time.
-	 * We'll only see looping here if the collection does not increase space.
+	 * Only loops here if the collection does not increase space.
 	 */
 
 	do {
@@ -2935,7 +2839,8 @@
 
 		dev->gc_skip = 5;
 
-		/* If we don't already have a block being gc'd then see if we should start another */
+		/* If we don't already have a block being gc'd then see if we
+		 * should start another */
 
 		if (dev->gc_block < 1 && !aggressive) {
 			dev->gc_block = yaffs2_find_refresh_block(dev);
@@ -2961,8 +2866,8 @@
 			gc_ok = yaffs_gc_block(dev, dev->gc_block, aggressive);
 		}
 
-		if (dev->n_erased_blocks < (dev->param.n_reserved_blocks)
-		    && dev->gc_block > 0) {
+		if (dev->n_erased_blocks < (dev->param.n_reserved_blocks) &&
+		    dev->gc_block > 0) {
 			yaffs_trace(YAFFS_TRACE_GC,
 				"yaffs: GC !!!no reclaim!!! n_erased_blocks %d after try %d block %d",
 				dev->n_erased_blocks, max_tries,
@@ -3039,10 +2944,8 @@
 	if (!dev->param.is_yaffs2 && mark_flash &&
 	    bi->block_state != YAFFS_BLOCK_STATE_COLLECTING) {
 
-		yaffs_init_tags(&tags);
-
+		memset(&tags, 0, sizeof(tags));
 		tags.is_deleted = 1;
-
 		yaffs_wr_chunk_tags_nand(dev, chunk_id, NULL, &tags);
 		yaffs_handle_chunk_update(dev, chunk_id, &tags);
 	} else {
@@ -3054,27 +2957,23 @@
 	 */
 	if (bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING ||
 	    bi->block_state == YAFFS_BLOCK_STATE_FULL ||
-	    bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
+	    bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
 	    bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) {
 		dev->n_free_chunks++;
-
 		yaffs_clear_chunk_bit(dev, block, page);
-
 		bi->pages_in_use--;
 
 		if (bi->pages_in_use == 0 &&
 		    !bi->has_shrink_hdr &&
 		    bi->block_state != YAFFS_BLOCK_STATE_ALLOCATING &&
-		    bi->block_state != YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
+		    bi->block_state != YAFFS_BLOCK_STATE_NEEDS_SCAN) {
 			yaffs_block_became_dirty(dev, block);
 		}
-
 	}
-
 }
 
 static int yaffs_wr_data_obj(struct yaffs_obj *in, int inode_chunk,
-			     const u8 * buffer, int n_bytes, int use_reserve)
+			     const u8 *buffer, int n_bytes, int use_reserve)
 {
 	/* Find old chunk Need to do this to get serial number
 	 * Write new one and patch into tree.
@@ -3083,10 +2982,8 @@
 
 	int prev_chunk_id;
 	struct yaffs_ext_tags prev_tags;
-
 	int new_chunk_id;
 	struct yaffs_ext_tags new_tags;
-
 	struct yaffs_dev *dev = in->my_dev;
 
 	yaffs_check_gc(dev, 0);
@@ -3101,7 +2998,7 @@
 		return 0;
 
 	/* Set up new tags */
-	yaffs_init_tags(&new_tags);
+	memset(&new_tags, 0, sizeof(new_tags));
 
 	new_tags.chunk_id = inode_chunk;
 	new_tags.obj_id = in->obj_id;
@@ -3113,7 +3010,7 @@
 		yaffs_trace(YAFFS_TRACE_ERROR,
 		  "Writing %d bytes to chunk!!!!!!!!!",
 		   n_bytes);
-		YBUG();
+		BUG();
 	}
 
 	new_chunk_id =
@@ -3134,11 +3031,10 @@
 
 
 static int yaffs_do_xattrib_mod(struct yaffs_obj *obj, int set,
-				const YCHAR * name, const void *value, int size,
+				const YCHAR *name, const void *value, int size,
 				int flags)
 {
 	struct yaffs_xattr_mod xmod;
-
 	int result;
 
 	xmod.set = set;
@@ -3163,7 +3059,6 @@
 	int x_offs = sizeof(struct yaffs_obj_hdr);
 	struct yaffs_dev *dev = obj->my_dev;
 	int x_size = dev->data_bytes_per_chunk - sizeof(struct yaffs_obj_hdr);
-
 	char *x_buffer = buffer + x_offs;
 
 	if (xmod->set)
@@ -3175,13 +3070,12 @@
 
 	obj->has_xattr = nval_hasvalues(x_buffer, x_size);
 	obj->xattr_known = 1;
-
 	xmod->result = retval;
 
 	return retval;
 }
 
-static int yaffs_do_xattrib_fetch(struct yaffs_obj *obj, const YCHAR * name,
+static int yaffs_do_xattrib_fetch(struct yaffs_obj *obj, const YCHAR *name,
 				  void *value, int size)
 {
 	char *buffer = NULL;
@@ -3190,9 +3084,7 @@
 	struct yaffs_dev *dev = obj->my_dev;
 	int x_offs = sizeof(struct yaffs_obj_hdr);
 	int x_size = dev->data_bytes_per_chunk - sizeof(struct yaffs_obj_hdr);
-
 	char *x_buffer;
-
 	int retval = 0;
 
 	if (obj->hdr_chunk < 1)
@@ -3208,7 +3100,7 @@
 			return 0;
 	}
 
-	buffer = (char *)yaffs_get_temp_buffer(dev, __LINE__);
+	buffer = (char *)yaffs_get_temp_buffer(dev);
 	if (!buffer)
 		return -ENOMEM;
 
@@ -3230,7 +3122,7 @@
 		else
 			retval = nval_list(x_buffer, x_size, value, size);
 	}
-	yaffs_release_temp_buffer(dev, (u8 *) buffer, __LINE__);
+	yaffs_release_temp_buffer(dev, (u8 *) buffer);
 	return retval;
 }
 
@@ -3258,26 +3150,22 @@
 
 static void yaffs_check_obj_details_loaded(struct yaffs_obj *in)
 {
-	u8 *chunk_data;
+	u8 *buf;
 	struct yaffs_obj_hdr *oh;
 	struct yaffs_dev *dev;
 	struct yaffs_ext_tags tags;
 	int result;
 	int alloc_failed = 0;
 
-	if (!in)
+	if (!in || !in->lazy_loaded || in->hdr_chunk < 1)
 		return;
 
 	dev = in->my_dev;
-
-	if (in->lazy_loaded && in->hdr_chunk > 0) {
 		in->lazy_loaded = 0;
-		chunk_data = yaffs_get_temp_buffer(dev, __LINE__);
+	buf = yaffs_get_temp_buffer(dev);
 
-		result =
-		    yaffs_rd_chunk_tags_nand(dev, in->hdr_chunk, chunk_data,
-					     &tags);
-		oh = (struct yaffs_obj_hdr *)chunk_data;
+	result = yaffs_rd_chunk_tags_nand(dev, in->hdr_chunk, buf, &tags);
+	oh = (struct yaffs_obj_hdr *)buf;
 
 		in->yst_mode = oh->yst_mode;
 		yaffs_load_attribs(in, oh);
@@ -3287,15 +3175,13 @@
 			in->variant.symlink_variant.alias =
 			    yaffs_clone_str(oh->alias);
 			if (!in->variant.symlink_variant.alias)
-				alloc_failed = 1;	/* Not returned to caller */
-		}
-
-		yaffs_release_temp_buffer(dev, chunk_data, __LINE__);
+			alloc_failed = 1;	/* Not returned */
 	}
+	yaffs_release_temp_buffer(dev, buf);
 }
 
-static void yaffs_load_name_from_oh(struct yaffs_dev *dev, YCHAR * name,
-				    const YCHAR * oh_name, int buff_size)
+static void yaffs_load_name_from_oh(struct yaffs_dev *dev, YCHAR *name,
+				    const YCHAR *oh_name, int buff_size)
 {
 #ifdef CONFIG_YAFFS_AUTO_UNICODE
 	if (dev->param.auto_unicode) {
@@ -3315,14 +3201,15 @@
                 }
 	} else {
 #else
+	(void) dev;
         {
 #endif
 		strncpy(name, oh_name, buff_size - 1);
         }
 }
 
-static void yaffs_load_oh_from_name(struct yaffs_dev *dev, YCHAR * oh_name,
-				    const YCHAR * name)
+static void yaffs_load_oh_from_name(struct yaffs_dev *dev, YCHAR *oh_name,
+				    const YCHAR *name)
 {
 #ifdef CONFIG_YAFFS_AUTO_UNICODE
 
@@ -3342,7 +3229,7 @@
 		}
 
 		if (is_ascii) {
-			/* It is an ASCII name, so do a unicode to ascii conversion */
+			/* It is an ASCII name, so convert unicode to ascii */
 			char *ascii_oh_name = (char *)oh_name;
 			int n = YAFFS_MAX_NAME_LENGTH - 1;
 			while (n > 0 && *name) {
@@ -3352,54 +3239,49 @@
 				n--;
 			}
 		} else {
-			/* It is a unicode name, so save starting at the second YCHAR */
+			/* Unicode name, so save starting at the second YCHAR */
 			*oh_name = 0;
-			strncpy(oh_name + 1, name,
-				      YAFFS_MAX_NAME_LENGTH - 2);
+			strncpy(oh_name + 1, name, YAFFS_MAX_NAME_LENGTH - 2);
 		}
 	} else {
 #else
+	dev = dev;
         {
 #endif
 		strncpy(oh_name, name, YAFFS_MAX_NAME_LENGTH - 1);
         }
-
 }
 
 /* UpdateObjectHeader updates the header on NAND for an object.
  * If name is not NULL, then that new name is used.
  */
-int yaffs_update_oh(struct yaffs_obj *in, const YCHAR * name, int force,
+int yaffs_update_oh(struct yaffs_obj *in, const YCHAR *name, int force,
 		    int is_shrink, int shadows, struct yaffs_xattr_mod *xmod)
 {
 
 	struct yaffs_block_info *bi;
-
 	struct yaffs_dev *dev = in->my_dev;
-
 	int prev_chunk_id;
 	int ret_val = 0;
 	int result = 0;
-
 	int new_chunk_id;
 	struct yaffs_ext_tags new_tags;
 	struct yaffs_ext_tags old_tags;
 	const YCHAR *alias = NULL;
-
 	u8 *buffer = NULL;
 	YCHAR old_name[YAFFS_MAX_NAME_LENGTH + 1];
-
 	struct yaffs_obj_hdr *oh = NULL;
+	loff_t file_size = 0;
 
 	strcpy(old_name, _Y("silly old name"));
 
-	if (!in->fake || in == dev->root_dir ||
-	    force || xmod) {
+	if (in->fake && in != dev->root_dir && !force && !xmod)
+		return ret_val;
 
 		yaffs_check_gc(dev, 0);
 		yaffs_check_obj_details_loaded(in);
 
-		buffer = yaffs_get_temp_buffer(in->my_dev, __LINE__);
+	buffer = yaffs_get_temp_buffer(in->my_dev);
 		oh = (struct yaffs_obj_hdr *)buffer;
 
 		prev_chunk_id = in->hdr_chunk;
@@ -3409,11 +3291,10 @@
 							  buffer, &old_tags);
 
 			yaffs_verify_oh(in, oh, &old_tags, 0);
-
 			memcpy(old_name, oh->name, sizeof(oh->name));
-			memset(buffer, 0xFF, sizeof(struct yaffs_obj_hdr));
+		memset(buffer, 0xff, sizeof(struct yaffs_obj_hdr));
 		} else {
-			memset(buffer, 0xFF, dev->data_bytes_per_chunk);
+		memset(buffer, 0xff, dev->data_bytes_per_chunk);
                 }
 
 		oh->type = in->variant_type;
@@ -3443,11 +3324,10 @@
 			/* Should not happen */
 			break;
 		case YAFFS_OBJECT_TYPE_FILE:
-			oh->file_size =
-			    (oh->parent_obj_id == YAFFS_OBJECTID_DELETED
-			     || oh->parent_obj_id ==
-			     YAFFS_OBJECTID_UNLINKED) ? 0 : in->
-			    variant.file_variant.file_size;
+		if (oh->parent_obj_id != YAFFS_OBJECTID_DELETED &&
+		    oh->parent_obj_id != YAFFS_OBJECTID_UNLINKED)
+			file_size = in->variant.file_variant.file_size;
+		yaffs_oh_size_load(oh, file_size);
 			break;
 		case YAFFS_OBJECT_TYPE_HARDLINK:
 			oh->equiv_id = in->variant.hardlink_variant.equiv_id;
@@ -3472,22 +3352,20 @@
 			yaffs_apply_xattrib_mod(in, (char *)buffer, xmod);
 
 		/* Tags */
-		yaffs_init_tags(&new_tags);
+	memset(&new_tags, 0, sizeof(new_tags));
 		in->serial++;
 		new_tags.chunk_id = 0;
 		new_tags.obj_id = in->obj_id;
 		new_tags.serial_number = in->serial;
 
 		/* Add extra info for file header */
-
 		new_tags.extra_available = 1;
 		new_tags.extra_parent_id = oh->parent_obj_id;
-		new_tags.extra_length = oh->file_size;
+	new_tags.extra_file_size = file_size;
 		new_tags.extra_is_shrink = oh->is_shrink;
 		new_tags.extra_equiv_id = oh->equiv_id;
 		new_tags.extra_shadows = (oh->shadows_obj > 0) ? 1 : 0;
 		new_tags.extra_obj_type = in->variant_type;
-
 		yaffs_verify_oh(in, oh, &new_tags, 1);
 
 		/* Create new chunk in NAND */
@@ -3495,37 +3373,31 @@
 		    yaffs_write_new_chunk(dev, buffer, &new_tags,
 					  (prev_chunk_id > 0) ? 1 : 0);
 
-		if (new_chunk_id >= 0) {
+	if (buffer)
+		yaffs_release_temp_buffer(dev, buffer);
+
+	if (new_chunk_id < 0)
+		return new_chunk_id;
 
 			in->hdr_chunk = new_chunk_id;
 
-			if (prev_chunk_id > 0) {
-				yaffs_chunk_del(dev, prev_chunk_id, 1,
-						__LINE__);
-			}
+	if (prev_chunk_id > 0)
+		yaffs_chunk_del(dev, prev_chunk_id, 1, __LINE__);
 
 			if (!yaffs_obj_cache_dirty(in))
 				in->dirty = 0;
 
-			/* If this was a shrink, then mark the block that the chunk lives on */
+	/* If this was a shrink, then mark the block
+	 * that the chunk lives on */
 			if (is_shrink) {
 				bi = yaffs_get_block_info(in->my_dev,
 							  new_chunk_id /
-							  in->my_dev->param.
-							  chunks_per_block);
+					  in->my_dev->param.chunks_per_block);
 				bi->has_shrink_hdr = 1;
 			}
 
-		}
-
-		ret_val = new_chunk_id;
-
-	}
-
-	if (buffer)
-		yaffs_release_temp_buffer(dev, buffer, __LINE__);
 
-	return ret_val;
+	return new_chunk_id;
 }
 
 /*--------------------- File read/write ------------------------
@@ -3540,21 +3412,17 @@
 
 int yaffs_file_rd(struct yaffs_obj *in, u8 * buffer, loff_t offset, int n_bytes)
 {
-
 	int chunk;
 	u32 start;
 	int n_copy;
 	int n = n_bytes;
 	int n_done = 0;
 	struct yaffs_cache *cache;
-
 	struct yaffs_dev *dev;
 
 	dev = in->my_dev;
 
 	while (n > 0) {
-		/* chunk = offset / dev->data_bytes_per_chunk + 1; */
-		/* start = offset % dev->data_bytes_per_chunk; */
 		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
 		chunk++;
 
@@ -3568,15 +3436,16 @@
 
 		cache = yaffs_find_chunk_cache(in, chunk);
 
-		/* If the chunk is already in the cache or it is less than a whole chunk
-		 * or we're using inband tags then use the cache (if there is caching)
-		 * else bypass the cache.
+		/* If the chunk is already in the cache or it is less than
+		 * a whole chunk or we're using inband tags then use the cache
+		 * (if there is caching) else bypass the cache.
 		 */
-		if (cache || n_copy != dev->data_bytes_per_chunk
-		    || dev->param.inband_tags) {
+		if (cache || n_copy != dev->data_bytes_per_chunk ||
+		    dev->param.inband_tags) {
 			if (dev->param.n_caches > 0) {
 
-				/* If we can't find the data in the cache, then load it up. */
+				/* If we can't find the data in the cache,
+				 * then load it up. */
 
 				if (!cache) {
 					cache =
@@ -3601,34 +3470,27 @@
 				/* Read into the local buffer then copy.. */
 
 				u8 *local_buffer =
-				    yaffs_get_temp_buffer(dev, __LINE__);
+				    yaffs_get_temp_buffer(dev);
 				yaffs_rd_data_obj(in, chunk, local_buffer);
 
 				memcpy(buffer, &local_buffer[start], n_copy);
 
-				yaffs_release_temp_buffer(dev, local_buffer,
-							  __LINE__);
+				yaffs_release_temp_buffer(dev, local_buffer);
 			}
-
 		} else {
-
-			/* A full chunk. Read directly into the supplied buffer. */
+			/* A full chunk. Read directly into the buffer. */
 			yaffs_rd_data_obj(in, chunk, buffer);
-
 		}
-
 		n -= n_copy;
 		offset += n_copy;
 		buffer += n_copy;
 		n_done += n_copy;
-
 	}
-
 	return n_done;
 }
 
-int yaffs_do_file_wr(struct yaffs_obj *in, const u8 * buffer, loff_t offset,
-		     int n_bytes, int write_trhrough)
+int yaffs_do_file_wr(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
+		     int n_bytes, int write_through)
 {
 
 	int chunk;
@@ -3637,11 +3499,10 @@
 	int n = n_bytes;
 	int n_done = 0;
 	int n_writeback;
-	int start_write = offset;
+	loff_t start_write = offset;
 	int chunk_written = 0;
 	u32 n_bytes_read;
-	u32 chunk_start;
-
+	loff_t chunk_start;
 	struct yaffs_dev *dev;
 
 	dev = in->my_dev;
@@ -3649,11 +3510,12 @@
 	while (n > 0 && chunk_written >= 0) {
 		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
 
-		if (chunk * dev->data_bytes_per_chunk + start != offset ||
+		if (((loff_t)chunk) *
+		    dev->data_bytes_per_chunk + start != offset ||
 		    start >= dev->data_bytes_per_chunk) {
 			yaffs_trace(YAFFS_TRACE_ERROR,
-				"AddrToChunk of offset %d gives chunk %d start %d",
-				(int)offset, chunk, start);
+				"AddrToChunk of offset %lld gives chunk %d start %d",
+				offset, chunk, start);
 		}
 		chunk++;	/* File pos to chunk in file offset */
 
@@ -3664,12 +3526,14 @@
 		if ((start + n) < dev->data_bytes_per_chunk) {
 			n_copy = n;
 
-			/* Now folks, to calculate how many bytes to write back....
-			 * If we're overwriting and not writing to then end of file then
-			 * we need to write back as much as was there before.
+			/* Now calculate how many bytes to write back....
+			 * If we're overwriting and not writing to then end of
+			 * file then we need to write back as much as was there
+			 * before.
 			 */
 
-			chunk_start = ((chunk - 1) * dev->data_bytes_per_chunk);
+			chunk_start = (((loff_t)(chunk - 1)) *
+					dev->data_bytes_per_chunk);
 
 			if (chunk_start > in->variant.file_variant.file_size)
 				n_bytes_read = 0;	/* Past end of file */
@@ -3685,27 +3549,30 @@
 			    (n_bytes_read >
 			     (start + n)) ? n_bytes_read : (start + n);
 
-			if (n_writeback < 0
-			    || n_writeback > dev->data_bytes_per_chunk)
-				YBUG();
+			if (n_writeback < 0 ||
+			    n_writeback > dev->data_bytes_per_chunk)
+				BUG();
 
 		} else {
 			n_copy = dev->data_bytes_per_chunk - start;
 			n_writeback = dev->data_bytes_per_chunk;
 		}
 
-		if (n_copy != dev->data_bytes_per_chunk
-		    || dev->param.inband_tags) {
-			/* An incomplete start or end chunk (or maybe both start and end chunk),
-			 * or we're using inband tags, so we want to use the cache buffers.
+		if (n_copy != dev->data_bytes_per_chunk ||
+		    dev->param.inband_tags) {
+			/* An incomplete start or end chunk (or maybe both
+			 * start and end chunk), or we're using inband tags,
+			 * so we want to use the cache buffers.
 			 */
 			if (dev->param.n_caches > 0) {
 				struct yaffs_cache *cache;
-				/* If we can't find the data in the cache, then load the cache */
+
+				/* If we can't find the data in the cache, then
+				 * load the cache */
 				cache = yaffs_find_chunk_cache(in, chunk);
 
-				if (!cache
-				    && yaffs_check_alloc_available(dev, 1)) {
+				if (!cache &&
+				    yaffs_check_alloc_available(dev, 1)) {
 					cache = yaffs_grab_chunk_cache(dev);
 					cache->object = in;
 					cache->chunk_id = chunk;
@@ -3717,8 +3584,9 @@
 					   !cache->dirty &&
 					   !yaffs_check_alloc_available(dev,
 									1)) {
-					/* Drop the cache if it was a read cache item and
-					 * no space check has been made for it.
+					/* Drop the cache if it was a read cache
+					 * item and no space check has been made
+					 * for it.
 					 */
 					cache = NULL;
 				}
@@ -3733,7 +3601,7 @@
 					cache->locked = 0;
 					cache->n_bytes = n_writeback;
 
-					if (write_trhrough) {
+					if (write_through) {
 						chunk_written =
 						    yaffs_wr_data_obj
 						    (cache->object,
@@ -3742,20 +3610,18 @@
 						     cache->n_bytes, 1);
 						cache->dirty = 0;
 					}
-
 				} else {
-					chunk_written = -1;	/* fail the write */
+					chunk_written = -1;	/* fail write */
 				}
 			} else {
-				/* An incomplete start or end chunk (or maybe both start and end chunk)
-				 * Read into the local buffer then copy, then copy over and write back.
+				/* An incomplete start or end chunk (or maybe
+				 * both start and end chunk). Read into the
+				 * local buffer then copy over and write back.
 				 */
 
-				u8 *local_buffer =
-				    yaffs_get_temp_buffer(dev, __LINE__);
+				u8 *local_buffer = yaffs_get_temp_buffer(dev);
 
 				yaffs_rd_data_obj(in, chunk, local_buffer);
-
 				memcpy(&local_buffer[start], buffer, n_copy);
 
 				chunk_written =
@@ -3763,19 +3629,17 @@
 						      local_buffer,
 						      n_writeback, 0);
 
-				yaffs_release_temp_buffer(dev, local_buffer,
-							  __LINE__);
-
+				yaffs_release_temp_buffer(dev, local_buffer);
 			}
-
 		} else {
-			/* A full chunk. Write directly from the supplied buffer. */
+			/* A full chunk. Write directly from the buffer. */
 
 			chunk_written =
 			    yaffs_wr_data_obj(in, chunk, buffer,
 					      dev->data_bytes_per_chunk, 0);
 
-			/* Since we've overwritten the cached data, we better invalidate it. */
+			/* Since we've overwritten the cached data,
+			 * we better invalidate it. */
 			yaffs_invalidate_chunk_cache(in, chunk);
 		}
 
@@ -3785,7 +3649,6 @@
 			buffer += n_copy;
 			n_done += n_copy;
 		}
-
 	}
 
 	/* Update file object */
@@ -3794,31 +3657,38 @@
 		in->variant.file_variant.file_size = (start_write + n_done);
 
 	in->dirty = 1;
-
 	return n_done;
 }
 
-int yaffs_wr_file(struct yaffs_obj *in, const u8 * buffer, loff_t offset,
-		  int n_bytes, int write_trhrough)
+int yaffs_wr_file(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
+		  int n_bytes, int write_through)
 {
 	yaffs2_handle_hole(in, offset);
-	return yaffs_do_file_wr(in, buffer, offset, n_bytes, write_trhrough);
+	return yaffs_do_file_wr(in, buffer, offset, n_bytes, write_through);
 }
 
 /* ---------------------- File resizing stuff ------------------ */
 
-static void yaffs_prune_chunks(struct yaffs_obj *in, int new_size)
+static void yaffs_prune_chunks(struct yaffs_obj *in, loff_t new_size)
 {
 
 	struct yaffs_dev *dev = in->my_dev;
-	int old_size = in->variant.file_variant.file_size;
-
-	int last_del = 1 + (old_size - 1) / dev->data_bytes_per_chunk;
-
-	int start_del = 1 + (new_size + dev->data_bytes_per_chunk - 1) /
-	    dev->data_bytes_per_chunk;
+	loff_t old_size = in->variant.file_variant.file_size;
 	int i;
 	int chunk_id;
+	u32 dummy;
+	int last_del;
+	int start_del;
+
+	if (old_size > 0)
+		yaffs_addr_to_chunk(dev, old_size - 1, &last_del, &dummy);
+	else
+		last_del = 0;
+
+	yaffs_addr_to_chunk(dev, new_size + dev->data_bytes_per_chunk - 1,
+				&start_del, &dummy);
+	last_del++;
+	start_del++;
 
 	/* Delete backwards so that we don't end up with holes if
 	 * power is lost part-way through the operation.
@@ -3830,13 +3700,15 @@
 		 */
 
 		chunk_id = yaffs_find_del_file_chunk(in, i, NULL);
-		if (chunk_id > 0) {
+
+		if (chunk_id < 1)
+			continue;
+
 			if (chunk_id <
-			    (dev->internal_start_block *
-			     dev->param.chunks_per_block)
-			    || chunk_id >=
-			    ((dev->internal_end_block +
-			      1) * dev->param.chunks_per_block)) {
+		    (dev->internal_start_block * dev->param.chunks_per_block) ||
+		    chunk_id >=
+		    ((dev->internal_end_block + 1) *
+		      dev->param.chunks_per_block)) {
 				yaffs_trace(YAFFS_TRACE_ALWAYS,
 					"Found daft chunk_id %d for %d",
 					chunk_id, i);
@@ -3845,8 +3717,6 @@
 				yaffs_chunk_del(dev, chunk_id, 1, __LINE__);
 			}
 		}
-	}
-
 }
 
 void yaffs_resize_file_down(struct yaffs_obj *obj, loff_t new_size)
@@ -3861,7 +3731,7 @@
 
 	if (new_partial != 0) {
 		int last_chunk = 1 + new_full;
-		u8 *local_buffer = yaffs_get_temp_buffer(dev, __LINE__);
+		u8 *local_buffer = yaffs_get_temp_buffer(dev);
 
 		/* Rewrite the last chunk with its new size and zero pad */
 		yaffs_rd_data_obj(obj, last_chunk, local_buffer);
@@ -3871,7 +3741,7 @@
 		yaffs_wr_data_obj(obj, last_chunk, local_buffer,
 				  new_partial, 1);
 
-		yaffs_release_temp_buffer(dev, local_buffer, __LINE__);
+		yaffs_release_temp_buffer(dev, local_buffer);
 	}
 
 	obj->variant.file_variant.file_size = new_size;
@@ -3882,7 +3752,7 @@
 int yaffs_resize_file(struct yaffs_obj *in, loff_t new_size)
 {
 	struct yaffs_dev *dev = in->my_dev;
-	int old_size = in->variant.file_variant.file_size;
+	loff_t old_size = in->variant.file_variant.file_size;
 
 	yaffs_flush_file_cache(in);
 	yaffs_invalidate_whole_cache(in);
@@ -3919,24 +3789,19 @@
 
 int yaffs_flush_file(struct yaffs_obj *in, int update_time, int data_sync)
 {
-	int ret_val;
-	if (in->dirty) {
+	if (!in->dirty)
+		return YAFFS_OK;
+
 		yaffs_flush_file_cache(in);
-		if (data_sync)	/* Only sync data */
-			ret_val = YAFFS_OK;
-		else {
-			if (update_time)
-				yaffs_load_current_time(in, 0, 0);
 
-			ret_val = (yaffs_update_oh(in, NULL, 0, 0, 0, NULL) >=
-				   0) ? YAFFS_OK : YAFFS_FAIL;
-		}
-	} else {
-		ret_val = YAFFS_OK;
-	}
+	if (data_sync)
+		return YAFFS_OK;
 
-	return ret_val;
+	if (update_time)
+		yaffs_load_current_time(in, 0, 0);
 
+	return (yaffs_update_oh(in, NULL, 0, 0, 0, NULL) >= 0) ?
+				YAFFS_OK : YAFFS_FAIL;
 }
 
 
@@ -3946,7 +3811,6 @@
  */
 static int yaffs_unlink_file_if_needed(struct yaffs_obj *in)
 {
-
 	int ret_val;
 	int del_now = 0;
 	struct yaffs_dev *dev = in->my_dev;
@@ -3971,11 +3835,10 @@
 		    yaffs_change_obj_name(in, in->my_dev->unlinked_dir,
 					  _Y("unlinked"), 0, 0);
 	}
-
 	return ret_val;
 }
 
-int yaffs_del_file(struct yaffs_obj *in)
+static int yaffs_del_file(struct yaffs_obj *in)
 {
 	int ret_val = YAFFS_OK;
 	int deleted;		/* Need to cache value on stack if in is freed */
@@ -4028,7 +3891,6 @@
 
 static int yaffs_del_symlink(struct yaffs_obj *in)
 {
-	if (in->variant.symlink_variant.alias)
 		kfree(in->variant.symlink_variant.alias);
 	in->variant.symlink_variant.alias = NULL;
 
@@ -4037,7 +3899,7 @@
 
 static int yaffs_del_link(struct yaffs_obj *in)
 {
-	/* remove this hardlink from the list assocaited with the equivalent
+	/* remove this hardlink from the list associated with the equivalent
 	 * object
 	 */
 	list_del_init(&in->hard_links);
@@ -4047,6 +3909,7 @@
 int yaffs_del_obj(struct yaffs_obj *obj)
 {
 	int ret_val = -1;
+
 	switch (obj->variant_type) {
 	case YAFFS_OBJECT_TYPE_FILE:
 		ret_val = yaffs_del_file(obj);
@@ -4073,19 +3936,19 @@
 		ret_val = 0;
 		break;		/* should not happen. */
 	}
-
 	return ret_val;
 }
 
 static int yaffs_unlink_worker(struct yaffs_obj *obj)
 {
-
 	int del_now = 0;
 
+	if (!obj)
+		return YAFFS_FAIL;
+
 	if (!obj->my_inode)
 		del_now = 1;
 
-	if (obj)
 		yaffs_update_parent(obj->parent);
 
 	if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
@@ -4100,7 +3963,7 @@
 		 * Instead, we do the following:
 		 * - Select a hardlink.
 		 * - Unhook it from the hard links
-		 * - Move it from its parent directory (so that the rename can work)
+		 * - Move it from its parent directory so that the rename works.
 		 * - Rename the object to the hardlink's name.
 		 * - Delete the hardlink
 		 */
@@ -4157,15 +4020,13 @@
 
 static int yaffs_unlink_obj(struct yaffs_obj *obj)
 {
-
 	if (obj && obj->unlink_allowed)
 		return yaffs_unlink_worker(obj);
 
 	return YAFFS_FAIL;
-
 }
 
-int yaffs_unlinker(struct yaffs_obj *dir, const YCHAR * name)
+int yaffs_unlinker(struct yaffs_obj *dir, const YCHAR *name)
 {
 	struct yaffs_obj *obj;
 
@@ -4176,8 +4037,8 @@
 /* Note:
  * If old_name is NULL then we take old_dir as the object to be renamed.
  */
-int yaffs_rename_obj(struct yaffs_obj *old_dir, const YCHAR * old_name,
-		     struct yaffs_obj *new_dir, const YCHAR * new_name)
+int yaffs_rename_obj(struct yaffs_obj *old_dir, const YCHAR *old_name,
+		     struct yaffs_obj *new_dir, const YCHAR *new_name)
 {
 	struct yaffs_obj *obj = NULL;
 	struct yaffs_obj *existing_target = NULL;
@@ -4185,10 +4046,14 @@
 	int result;
 	struct yaffs_dev *dev;
 
-	if (!old_dir || old_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
-		YBUG();
-	if (!new_dir || new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
-		YBUG();
+	if (!old_dir || old_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+	if (!new_dir || new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		BUG();
+		return YAFFS_FAIL;
+	}
 
 	dev = old_dir->my_dev;
 
@@ -4208,26 +4073,24 @@
 		/* ENAMETOOLONG */
 		return YAFFS_FAIL;
 
-	if(old_name)
+	if (old_name)
 		obj = yaffs_find_by_name(old_dir, old_name);
 	else{
 		obj = old_dir;
 		old_dir = obj->parent;
 	}
 
-
 	if (obj && obj->rename_allowed) {
-
-		/* Now do the handling for an existing target, if there is one */
-
+		/* Now handle an existing target, if there is one */
 		existing_target = yaffs_find_by_name(new_dir, new_name);
-		if (yaffs_is_non_empty_dir(existing_target)){
+		if (yaffs_is_non_empty_dir(existing_target)) {
 			return YAFFS_FAIL;	/* ENOTEMPTY */
 		} else if (existing_target && existing_target != obj) {
 			/* Nuke the target first, using shadowing,
 			 * but only if it isn't the same object.
 			 *
-			 * Note we must disable gc otherwise it can mess up the shadowing.
+			 * Note we must disable gc here otherwise it can mess
+			 * up the shadowing.
 			 *
 			 */
 			dev->gc_disable = 1;
@@ -4256,12 +4119,7 @@
 {
 	struct yaffs_obj *obj;
 
-	if (!backward_scanning) {
-		/* Handle YAFFS1 forward scanning case
-		 * For YAFFS1 we always do the deletion
-		 */
-
-	} else {
+	if (backward_scanning) {
 		/* Handle YAFFS2 case (backward scanning)
 		 * If the shadowed object exists then ignore.
 		 */
@@ -4270,7 +4128,8 @@
 			return;
 	}
 
-	/* Let's create it (if it does not exist) assuming it is a file so that it can do shrinking etc.
+	/* Let's create it (if it does not exist) assuming it is a file so that
+	 * it can do shrinking etc.
 	 * We put it in unlinked dir to be cleaned up after the scanning
 	 */
 	obj =
@@ -4280,22 +4139,20 @@
 	obj->is_shadowed = 1;
 	yaffs_add_obj_to_dir(dev->unlinked_dir, obj);
 	obj->variant.file_variant.shrink_size = 0;
-	obj->valid = 1;		/* So that we don't read any other info for this file */
-
+	obj->valid = 1;		/* So that we don't read any other info. */
 }
 
-void yaffs_link_fixup(struct yaffs_dev *dev, struct yaffs_obj *hard_list)
+void yaffs_link_fixup(struct yaffs_dev *dev, struct list_head *hard_list)
 {
+	struct list_head *lh;
+	struct list_head *save;
 	struct yaffs_obj *hl;
 	struct yaffs_obj *in;
 
-	while (hard_list) {
-		hl = hard_list;
-		hard_list = (struct yaffs_obj *)(hard_list->hard_links.next);
-
+	list_for_each_safe(lh, save, hard_list) {
+		hl = list_entry(lh, struct yaffs_obj, hard_links);
 		in = yaffs_find_by_number(dev,
-					  hl->variant.
-					  hardlink_variant.equiv_id);
+					hl->variant.hardlink_variant.equiv_id);
 
 		if (in) {
 			/* Add the hardlink pointers */
@@ -4307,7 +4164,6 @@
 			 */
 			hl->variant.hardlink_variant.equiv_obj = NULL;
 			INIT_LIST_HEAD(&hl->hard_links);
-
 		}
 	}
 }
@@ -4327,19 +4183,14 @@
 	/* Soft delete all the unlinked files */
 	list_for_each_safe(i, n,
 			   &dev->unlinked_dir->variant.dir_variant.children) {
-		if (i) {
 			l = list_entry(i, struct yaffs_obj, siblings);
 			yaffs_del_obj(l);
 		}
-	}
 
 	list_for_each_safe(i, n, &dev->del_dir->variant.dir_variant.children) {
-		if (i) {
 			l = list_entry(i, struct yaffs_obj, siblings);
 			yaffs_del_obj(l);
 		}
-	}
-
 }
 
 /*
@@ -4350,13 +4201,14 @@
  * - Directly or indirectly under root.
  *
  * Note:
- *  This code assumes that we don't ever change the current relationships between
- *  directories:
+ *  This code assumes that we don't ever change the current relationships
+ *  between directories:
  *   root_dir->parent == unlinked_dir->parent == del_dir->parent == NULL
  *   lost-n-found->parent == root_dir
  *
- * This fixes the problem where directories might have inadvertently been deleted
- * leaving the object "hanging" without being rooted in the directory tree.
+ * This fixes the problem where directories might have inadvertently been
+ * deleted leaving the object "hanging" without being rooted in the
+ * directory tree.
  */
 
 static int yaffs_has_null_parent(struct yaffs_dev *dev, struct yaffs_obj *obj)
@@ -4385,23 +4237,22 @@
 
 	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
 		list_for_each_safe(lh, n, &dev->obj_bucket[i].list) {
-			if (lh) {
-				obj =
-				    list_entry(lh, struct yaffs_obj, hash_link);
+			obj = list_entry(lh, struct yaffs_obj, hash_link);
 				parent = obj->parent;
 
 				if (yaffs_has_null_parent(dev, obj)) {
 					/* These directories are not hanging */
 					hanging = 0;
-				} else if (!parent
-					   || parent->variant_type !=
+			} else if (!parent ||
+				   parent->variant_type !=
 					   YAFFS_OBJECT_TYPE_DIRECTORY) {
 					hanging = 1;
 				} else if (yaffs_has_null_parent(dev, parent)) {
 					hanging = 0;
 				} else {
 					/*
-					 * Need to follow the parent chain to see if it is hanging.
+				 * Need to follow the parent chain to
+				 * see if it is hanging.
 					 */
 					hanging = 0;
 					depth_limit = 100;
@@ -4409,8 +4260,8 @@
 					while (parent != dev->root_dir &&
 					       parent->parent &&
 					       parent->parent->variant_type ==
-					       YAFFS_OBJECT_TYPE_DIRECTORY
-					       && depth_limit > 0) {
+				       YAFFS_OBJECT_TYPE_DIRECTORY &&
+				       depth_limit > 0) {
 						parent = parent->parent;
 						depth_limit--;
 					}
@@ -4421,9 +4272,7 @@
 					yaffs_trace(YAFFS_TRACE_SCAN,
 						"Hanging object %d moved to lost and found",
 						obj->obj_id);
-					yaffs_add_obj_to_dir(dev->lost_n_found,
-							     obj);
-				}
+				yaffs_add_obj_to_dir(dev->lost_n_found, obj);
 			}
 		}
 	}
@@ -4439,25 +4288,17 @@
 	struct list_head *n;
 
 	if (dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
-		YBUG();
+		BUG();
 
 	list_for_each_safe(lh, n, &dir->variant.dir_variant.children) {
-		if (lh) {
 			obj = list_entry(lh, struct yaffs_obj, siblings);
 			if (obj->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY)
 				yaffs_del_dir_contents(obj);
-
 			yaffs_trace(YAFFS_TRACE_SCAN,
 				"Deleting lost_found object %d",
 				obj->obj_id);
-
-			/* Need to use UnlinkObject since Delete would not handle
-			 * hardlinked objects correctly.
-			 */
 			yaffs_unlink_obj(obj);
 		}
-	}
-
 }
 
 static void yaffs_empty_l_n_f(struct yaffs_dev *dev)
@@ -4467,13 +4308,11 @@
 
 
 struct yaffs_obj *yaffs_find_by_name(struct yaffs_obj *directory,
-				     const YCHAR * name)
+				     const YCHAR *name)
 {
 	int sum;
-
 	struct list_head *i;
 	YCHAR buffer[YAFFS_MAX_NAME_LENGTH + 1];
-
 	struct yaffs_obj *l;
 
 	if (!name)
@@ -4483,24 +4322,23 @@
 		yaffs_trace(YAFFS_TRACE_ALWAYS,
 			"tragedy: yaffs_find_by_name: null pointer directory"
 			);
-		YBUG();
+		BUG();
 		return NULL;
 	}
 	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
 		yaffs_trace(YAFFS_TRACE_ALWAYS,
 			"tragedy: yaffs_find_by_name: non-directory"
 			);
-		YBUG();
+		BUG();
 	}
 
 	sum = yaffs_calc_name_sum(name);
 
 	list_for_each(i, &directory->variant.dir_variant.children) {
-		if (i) {
 			l = list_entry(i, struct yaffs_obj, siblings);
 
 			if (l->parent != directory)
-				YBUG();
+			BUG();
 
 			yaffs_check_obj_details_loaded(l);
 
@@ -4508,20 +4346,16 @@
 			if (l->obj_id == YAFFS_OBJECTID_LOSTNFOUND) {
 				if (!strcmp(name, YAFFS_LOSTNFOUND_NAME))
 					return l;
-			} else if (l->sum == sum
-				   || l->hdr_chunk <= 0) {
+		} else if (l->sum == sum || l->hdr_chunk <= 0) {
 				/* LostnFound chunk called Objxxx
 				 * Do a real check
 				 */
 				yaffs_get_obj_name(l, buffer,
 						   YAFFS_MAX_NAME_LENGTH + 1);
-				if (strncmp
-				    (name, buffer, YAFFS_MAX_NAME_LENGTH) == 0)
+			if (!strncmp(name, buffer, YAFFS_MAX_NAME_LENGTH))
 					return l;
 			}
 		}
-	}
-
 	return NULL;
 }
 
@@ -4532,7 +4366,6 @@
 struct yaffs_obj *yaffs_get_equivalent_obj(struct yaffs_obj *obj)
 {
 	if (obj && obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
-		/* We want the object id of the equivalent object, not this one */
 		obj = obj->variant.hardlink_variant.equiv_obj;
 		yaffs_check_obj_details_loaded(obj);
 	}
@@ -4558,7 +4391,7 @@
  *    starting at oh->name[1].
 
  */
-static void yaffs_fix_null_name(struct yaffs_obj *obj, YCHAR * name,
+static void yaffs_fix_null_name(struct yaffs_obj *obj, YCHAR *name,
 				int buffer_size)
 {
 	/* Create an object name if we could not find one. */
@@ -4580,23 +4413,17 @@
 	}
 }
 
-int yaffs_get_obj_name(struct yaffs_obj *obj, YCHAR * name, int buffer_size)
+int yaffs_get_obj_name(struct yaffs_obj *obj, YCHAR *name, int buffer_size)
 {
 	memset(name, 0, buffer_size * sizeof(YCHAR));
-
 	yaffs_check_obj_details_loaded(obj);
-
 	if (obj->obj_id == YAFFS_OBJECTID_LOSTNFOUND) {
 		strncpy(name, YAFFS_LOSTNFOUND_NAME, buffer_size - 1);
-	}
-#ifndef CONFIG_YAFFS_NO_SHORT_NAMES
-	else if (obj->short_name[0]) {
+	} else if (obj->short_name[0]) {
 		strcpy(name, obj->short_name);
-	}
-#endif
-	else if (obj->hdr_chunk > 0) {
+	} else if (obj->hdr_chunk > 0) {
 		int result;
-		u8 *buffer = yaffs_get_temp_buffer(obj->my_dev, __LINE__);
+		u8 *buffer = yaffs_get_temp_buffer(obj->my_dev);
 
 		struct yaffs_obj_hdr *oh = (struct yaffs_obj_hdr *)buffer;
 
@@ -4610,7 +4437,7 @@
 		yaffs_load_name_from_oh(obj->my_dev, name, oh->name,
 					buffer_size);
 
-		yaffs_release_temp_buffer(obj->my_dev, buffer, __LINE__);
+		yaffs_release_temp_buffer(obj->my_dev, buffer);
 	}
 
 	yaffs_fix_null_name(obj, name, buffer_size);
@@ -4618,7 +4445,7 @@
 	return strnlen(name, YAFFS_MAX_NAME_LENGTH);
 }
 
-int yaffs_get_obj_length(struct yaffs_obj *obj)
+loff_t yaffs_get_obj_length(struct yaffs_obj *obj)
 {
 	/* Dereference any hard linking */
 	obj = yaffs_get_equivalent_obj(obj);
@@ -4683,6 +4510,8 @@
 			return DT_BLK;
 		if (S_ISSOCK(obj->yst_mode))
 			return DT_SOCK;
+		return DT_REG;
+		break;
 	default:
 		return DT_REG;
 		break;
@@ -4702,13 +4531,10 @@
 
 static int yaffs_check_dev_fns(const struct yaffs_dev *dev)
 {
-
 	/* Common functions, gotta have */
 	if (!dev->param.erase_fn || !dev->param.initialise_flash_fn)
 		return 0;
 
-#ifdef CONFIG_YAFFS_YAFFS2
-
 	/* Can use the "with tags" style interface for yaffs1 or yaffs2 */
 	if (dev->param.write_chunk_tags_fn &&
 	    dev->param.read_chunk_tags_fn &&
@@ -4716,7 +4542,6 @@
 	    !dev->param.read_chunk_fn &&
 	    dev->param.bad_block_fn && dev->param.query_block_fn)
 		return 1;
-#endif
 
 	/* Can use the "spare" style interface for yaffs1 */
 	if (!dev->param.is_yaffs2 &&
@@ -4732,17 +4557,13 @@
 
 static int yaffs_create_initial_dir(struct yaffs_dev *dev)
 {
-	/* Initialise the unlinked, deleted, root and lost and found directories */
-
+	/* Initialise the unlinked, deleted, root and lost+found directories */
 	dev->lost_n_found = dev->root_dir = NULL;
 	dev->unlinked_dir = dev->del_dir = NULL;
-
 	dev->unlinked_dir =
 	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_UNLINKED, S_IFDIR);
-
 	dev->del_dir =
 	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_DELETED, S_IFDIR);
-
 	dev->root_dir =
 	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_ROOT,
 				  YAFFS_ROOT_MODE | S_IFDIR);
@@ -4755,7 +4576,6 @@
 		yaffs_add_obj_to_dir(dev->root_dir, dev->lost_n_found);
 		return YAFFS_OK;
 	}
-
 	return YAFFS_FAIL;
 }
 
@@ -4765,7 +4585,7 @@
 	unsigned x;
 	int bits;
 
-	yaffs_trace(YAFFS_TRACE_TRACING, "yaffs: yaffs_guts_initialise()" );
+	yaffs_trace(YAFFS_TRACE_TRACING, "yaffs: yaffs_guts_initialise()");
 
 	/* Check stuff that must be set */
 
@@ -4776,6 +4596,11 @@
 		return YAFFS_FAIL;
 	}
 
+	if (dev->is_mounted) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "device already mounted");
+		return YAFFS_FAIL;
+	}
+
 	dev->internal_start_block = dev->param.start_block;
 	dev->internal_end_block = dev->param.end_block;
 	dev->block_offset = 0;
@@ -4836,12 +4661,7 @@
 		return YAFFS_FAIL;
 	}
 
-	if (dev->is_mounted) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS, "device already mounted");
-		return YAFFS_FAIL;
-	}
-
-	/* Finished with most checks. One or two more checks happen later on too. */
+	/* Finished with most checks. Further checks happen later on too. */
 
 	dev->is_mounted = 1;
 
@@ -4909,7 +4729,7 @@
 		return YAFFS_FAIL;
 	}
 
-	/* OK, we've finished verifying the device, lets continue with initialisation */
+	/* Finished verifying the device, continue with initialisation */
 
 	/* More device initialisation */
 	dev->all_gcs = 0;
@@ -4929,7 +4749,8 @@
 	dev->n_erase_failures = 0;
 	dev->n_erased_blocks = 0;
 	dev->gc_disable = 0;
-	dev->has_pending_prioritised_gc = 1;	/* Assume the worst for now, will get fixed on first GC */
+	dev->has_pending_prioritised_gc = 1;
+		/* Assume the worst for now, will get fixed on first GC */
 	INIT_LIST_HEAD(&dev->dirty_dirs);
 	dev->oldest_dirty_seq = 0;
 	dev->oldest_dirty_block = 0;
@@ -4991,18 +4812,24 @@
 	if (!init_failed && !yaffs_create_initial_dir(dev))
 		init_failed = 1;
 
+	if (!init_failed && dev->param.is_yaffs2 &&
+		!dev->param.disable_summary &&
+		!yaffs_summary_init(dev))
+		init_failed = 1;
+
 	if (!init_failed) {
 		/* Now scan the flash. */
 		if (dev->param.is_yaffs2) {
 			if (yaffs2_checkpt_restore(dev)) {
 				yaffs_check_obj_details_loaded(dev->root_dir);
-				yaffs_trace(YAFFS_TRACE_CHECKPOINT | YAFFS_TRACE_MOUNT,
+				yaffs_trace(YAFFS_TRACE_CHECKPOINT |
+					YAFFS_TRACE_MOUNT,
 					"yaffs: restored from checkpoint"
 					);
 			} else {
 
-				/* Clean up the mess caused by an aborted checkpoint load
-				 * and scan backwards.
+				/* Clean up the mess caused by an aborted
+				 * checkpoint load then scan backwards.
 				 */
 				yaffs_deinit_blocks(dev);
 
@@ -5052,7 +4879,7 @@
 	dev->n_page_writes = 0;
 	dev->n_erasures = 0;
 	dev->n_gc_copies = 0;
-	dev->n_retired_writes = 0;
+	dev->n_retried_writes = 0;
 
 	dev->n_retired_blocks = 0;
 
@@ -5066,7 +4893,6 @@
 	yaffs_trace(YAFFS_TRACE_TRACING,
 	  "yaffs: yaffs_guts_initialise() done.");
 	return YAFFS_OK;
-
 }
 
 void yaffs_deinitialise(struct yaffs_dev *dev)
@@ -5076,10 +4902,11 @@
 
 		yaffs_deinit_blocks(dev);
 		yaffs_deinit_tnodes_and_objs(dev);
+		yaffs_summary_deinit(dev);
+
 		if (dev->param.n_caches > 0 && dev->cache) {
 
 			for (i = 0; i < dev->param.n_caches; i++) {
-				if (dev->cache[i].data)
 					kfree(dev->cache[i].data);
 				dev->cache[i].data = NULL;
 			}
@@ -5104,7 +4931,6 @@
 {
 	int n_free = 0;
 	int b;
-
 	struct yaffs_block_info *blk;
 
 	blk = dev->block_info;
@@ -5123,14 +4949,12 @@
 		}
 		blk++;
 	}
-
 	return n_free;
 }
 
 int yaffs_get_n_free_chunks(struct yaffs_dev *dev)
 {
 	/* This is what we report to the outside world */
-
 	int n_free;
 	int n_dirty_caches;
 	int blocks_for_checkpt;
@@ -5139,7 +4963,7 @@
 	n_free = dev->n_free_chunks;
 	n_free += dev->n_deleted_files;
 
-	/* Now count the number of dirty chunks in the cache and subtract those */
+	/* Now count and subtract the number of dirty chunks in the cache. */
 
 	for (n_dirty_caches = 0, i = 0; i < dev->param.n_caches; i++) {
 		if (dev->cache[i].dirty)
@@ -5151,7 +4975,7 @@
 	n_free -=
 	    ((dev->param.n_reserved_blocks + 1) * dev->param.chunks_per_block);
 
-	/* Now we figure out how much to reserve for the checkpoint and report that... */
+	/* Now figure checkpoint space and report that... */
 	blocks_for_checkpt = yaffs_calc_checkpt_blocks_required(dev);
 
 	n_free -= (blocks_for_checkpt * dev->param.chunks_per_block);
@@ -5160,5 +4984,27 @@
 		n_free = 0;
 
 	return n_free;
+}
+
+/*
+ * Marshalling functions to get loff_t file sizes into and out of
+ * object headers.
+ */
+void yaffs_oh_size_load(struct yaffs_obj_hdr *oh, loff_t fsize)
+{
+	oh->file_size_low = (fsize & 0xFFFFFFFF);
+	oh->file_size_high = ((fsize >> 32) & 0xFFFFFFFF);
+}
+
+loff_t yaffs_oh_to_size(struct yaffs_obj_hdr *oh)
+{
+	loff_t retval;
+
+	if (sizeof(loff_t) >= 8 && ~(oh->file_size_high))
+		retval = (((loff_t) oh->file_size_high) << 32) |
+			(((loff_t) oh->file_size_low) & 0xFFFFFFFF);
+	else
+		retval = (loff_t) oh->file_size_low;
 
+	return retval;
 }
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_guts.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_guts.h
--- linux-3.1.9/fs/yaffs2/yaffs_guts.h	2012-06-20 14:51:23.974803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_guts.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -23,12 +23,24 @@
 
 /* Give us a  Y=0x59,
  * Give us an A=0x41,
- * Give us an FF=0xFF
+ * Give us an FF=0xff
  * Give us an S=0x53
  * And what have we got...
  */
-#define YAFFS_MAGIC			0x5941FF53
+#define YAFFS_MAGIC			0x5941ff53
 
+/*
+ * Tnodes form a tree with the tnodes in "levels"
+ * Levels greater than 0 hold 8 slots which point to other tnodes.
+ * Those at level 0 hold 16 slots which point to chunks in NAND.
+ *
+ * A maximum level of 8 thust supports files of size up to:
+ *
+ * 2^(3*MAX_LEVEL+4)
+ *
+ * Thus a max level of 8 supports files with up to 2^^28 chunks which gives
+ * a maximum file size of arounf 51Gbytees with 2k chunks.
+ */
 #define YAFFS_NTNODES_LEVEL0	  	16
 #define YAFFS_TNODES_LEVEL0_BITS	4
 #define YAFFS_TNODES_LEVEL0_MASK	0xf
@@ -36,20 +48,25 @@
 #define YAFFS_NTNODES_INTERNAL 		(YAFFS_NTNODES_LEVEL0 / 2)
 #define YAFFS_TNODES_INTERNAL_BITS 	(YAFFS_TNODES_LEVEL0_BITS - 1)
 #define YAFFS_TNODES_INTERNAL_MASK	0x7
-#define YAFFS_TNODES_MAX_LEVEL		6
+#define YAFFS_TNODES_MAX_LEVEL		8
+#define YAFFS_TNODES_MAX_BITS		(YAFFS_TNODES_LEVEL0_BITS + \
+					YAFFS_TNODES_INTERNAL_BITS * \
+					YAFFS_TNODES_MAX_LEVEL)
+#define YAFFS_MAX_CHUNK_ID		((1 << YAFFS_TNODES_MAX_BITS) - 1)
+
+#define YAFFS_MAX_FILE_SIZE_32		0x7fffffff
 
-#ifndef CONFIG_YAFFS_NO_YAFFS1
+/* Constants for YAFFS1 mode */
 #define YAFFS_BYTES_PER_SPARE		16
 #define YAFFS_BYTES_PER_CHUNK		512
 #define YAFFS_CHUNK_SIZE_SHIFT		9
 #define YAFFS_CHUNKS_PER_BLOCK		32
 #define YAFFS_BYTES_PER_BLOCK		(YAFFS_CHUNKS_PER_BLOCK*YAFFS_BYTES_PER_CHUNK)
-#endif
 
 #define YAFFS_MIN_YAFFS2_CHUNK_SIZE 	1024
 #define YAFFS_MIN_YAFFS2_SPARE_SIZE	32
 
-#define YAFFS_MAX_CHUNK_ID		0x000FFFFF
+
 
 #define YAFFS_ALLOCATION_NOBJECTS	100
 #define YAFFS_ALLOCATION_NTNODES	100
@@ -58,9 +75,11 @@
 #define YAFFS_NOBJECT_BUCKETS		256
 
 #define YAFFS_OBJECT_SPACE		0x40000
-#define YAFFS_MAX_OBJECT_ID		(YAFFS_OBJECT_SPACE -1)
+#define YAFFS_MAX_OBJECT_ID		(YAFFS_OBJECT_SPACE - 1)
 
-#define YAFFS_CHECKPOINT_VERSION 	4
+/* Binary data version stamps */
+#define YAFFS_SUMMARY_VERSION		1
+#define YAFFS_CHECKPOINT_VERSION	7
 
 #ifdef CONFIG_YAFFS_UNICODE
 #define YAFFS_MAX_NAME_LENGTH		127
@@ -78,8 +97,10 @@
 #define YAFFS_OBJECTID_UNLINKED		3
 #define YAFFS_OBJECTID_DELETED		4
 
+/* Fake object Id for summary data */
+#define YAFFS_OBJECTID_SUMMARY		0x10
+
 /* Pseudo object ids for checkpointing */
-#define YAFFS_OBJECTID_SB_HEADER	0x10
 #define YAFFS_OBJECTID_CHECKPOINT_DATA	0x20
 #define YAFFS_SEQUENCE_CHECKPOINT_DATA  0x21
 
@@ -97,14 +118,14 @@
  * The range is limited slightly to help distinguish bad numbers from good.
  * This also allows us to perhaps in the future use special numbers for
  * special purposes.
- * EFFFFF00 allows the allocation of 8 blocks per second (~1Mbytes) for 15 years,
+ * EFFFFF00 allows the allocation of 8 blocks/second (~1Mbytes) for 15 years,
  * and is a larger number than the lifetime of a 2GB device.
  */
 #define YAFFS_LOWEST_SEQUENCE_NUMBER	0x00001000
-#define YAFFS_HIGHEST_SEQUENCE_NUMBER	0xEFFFFF00
+#define YAFFS_HIGHEST_SEQUENCE_NUMBER	0xefffff00
 
 /* Special sequence number for bad block that failed to be marked bad */
-#define YAFFS_SEQUENCE_BAD_BLOCK	0xFFFF0000
+#define YAFFS_SEQUENCE_BAD_BLOCK	0xffff0000
 
 /* ChunkCache is used for short read/write operations.*/
 struct yaffs_cache {
@@ -117,12 +138,11 @@
 	u8 *data;
 };
 
-/* Tags structures in RAM
- * NB This uses bitfield. Bitfields should not straddle a u32 boundary otherwise
- * the structure size will get blown out.
+/* yaffs1 tags structures in RAM
+ * NB This uses bitfield. Bitfields should not straddle a u32 boundary
+ * otherwise the structure size will get blown out.
  */
 
-#ifndef CONFIG_YAFFS_NO_YAFFS1
 struct yaffs_tags {
 	unsigned chunk_id:20;
 	unsigned serial_number:2;
@@ -137,7 +157,6 @@
 	u8 as_bytes[8];
 };
 
-#endif
 
 /* Stuff used for extended tags in YAFFS2 */
 
@@ -160,11 +179,9 @@
 #define YAFFS_OBJECT_TYPE_MAX YAFFS_OBJECT_TYPE_SPECIAL
 
 struct yaffs_ext_tags {
-
-	unsigned validity0;
 	unsigned chunk_used;	/*  Status of the chunk: used or unused */
-	unsigned obj_id;	/* If 0 then this is not part of an object (unused) */
-	unsigned chunk_id;	/* If 0 then this is a header, else a data chunk */
+	unsigned obj_id;	/* If 0 this is not used */
+	unsigned chunk_id;	/* If 0 this is a header, else a data chunk */
 	unsigned n_bytes;	/* Only valid for data chunks */
 
 	/* The following stuff only has meaning when we read */
@@ -180,18 +197,15 @@
 
 	/* Extra info if this is an object header (YAFFS2 only) */
 
-	unsigned extra_available;	/* There is extra info available if this is not zero */
+	unsigned extra_available;	/* Extra info available if not zero */
 	unsigned extra_parent_id;	/* The parent object */
 	unsigned extra_is_shrink;	/* Is it a shrink header? */
 	unsigned extra_shadows;	/* Does this shadow another object? */
 
 	enum yaffs_obj_type extra_obj_type;	/* What object type? */
 
-	unsigned extra_length;	/* Length if it is a file */
-	unsigned extra_equiv_id;	/* Equivalent object Id if it is a hard link */
-
-	unsigned validity1;
-
+	loff_t extra_file_size;		/* Length if it is a file */
+	unsigned extra_equiv_id;	/* Equivalent object for a hard link */
 };
 
 /* Spare structure for YAFFS1 */
@@ -225,12 +239,15 @@
 	YAFFS_BLOCK_STATE_SCANNING,
 	/* Being scanned */
 
-	YAFFS_BLOCK_STATE_NEEDS_SCANNING,
-	/* The block might have something on it (ie it is allocating or full, perhaps empty)
-	 * but it needs to be scanned to determine its true state.
+	YAFFS_BLOCK_STATE_NEEDS_SCAN,
+	/* The block might have something on it (ie it is allocating or full,
+	 * perhaps empty) but it needs to be scanned to determine its true
+	 * state.
 	 * This state is only valid during scanning.
-	 * NB We tolerate empty because the pre-scanner might be incapable of deciding
-	 * However, if this state is returned on a YAFFS2 device, then we expect a sequence number
+	 * NB We tolerate empty because the pre-scanner might be incapable of
+	 * deciding
+	 * However, if this state is returned on a YAFFS2 device,
+	 * then we expect a sequence number
 	 */
 
 	YAFFS_BLOCK_STATE_EMPTY,
@@ -241,7 +258,8 @@
 	 * At least one page holds valid data.
 	 * This is the one currently being used for page
 	 * allocation. Should never be more than one of these.
-	 * If a block is only partially allocated at mount it is treated as full.
+	 * If a block is only partially allocated at mount it is treated as
+	 * full.
 	 */
 
 	YAFFS_BLOCK_STATE_FULL,
@@ -271,18 +289,20 @@
 
 	int soft_del_pages:10;	/* number of soft deleted pages */
 	int pages_in_use:10;	/* number of pages in use */
-	unsigned block_state:4;	/* One of the above block states. NB use unsigned because enum is sometimes an int */
-	u32 needs_retiring:1;	/* Data has failed on this block, need to get valid data off */
-	/* and retire the block. */
-	u32 skip_erased_check:1;	/* If this is set we can skip the erased check on this block */
-	u32 gc_prioritise:1;	/* An ECC check or blank check has failed on this block.
-				   It should be prioritised for GC */
-	u32 chunk_error_strikes:3;	/* How many times we've had ecc etc failures on this block and tried to reuse it */
+	unsigned block_state:4;	/* One of the above block states. */
+				/* NB use unsigned because enum is sometimes
+				 * an int */
+	u32 needs_retiring:1;	/* Data has failed on this block, */
+				/*need to get valid data off and retire*/
+	u32 skip_erased_check:1;/* Skip the erased check on this block */
+	u32 gc_prioritise:1;	/* An ECC check or blank check has failed.
+				   Block should be prioritised for GC */
+	u32 chunk_error_strikes:3;	/* How many times we've had ecc etc
+				failures on this block and tried to reuse it */
+	u32 has_summary:1;	/* The block has a summary */
 
-#ifdef CONFIG_YAFFS_YAFFS2
-	u32 has_shrink_hdr:1;	/* This block has at least one shrink object header */
+	u32 has_shrink_hdr:1;	/* This block has at least one shrink header */
 	u32 seq_number;		/* block sequence number for yaffs2 */
-#endif
 
 };
 
@@ -297,7 +317,7 @@
 	u16 sum_no_longer_used;	/* checksum of name. No longer used */
 	YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
 
-	/* The following apply to directories, files, symlinks - not hard links */
+	/* The following apply to all object types except for hard links */
 	u32 yst_mode;		/* protection */
 
 	u32 yst_uid;
@@ -307,7 +327,7 @@
 	u32 yst_ctime;
 
 	/* File size  applies to files only */
-	int file_size;
+	u32 file_size_low;
 
 	/* Equivalent object id applies to hard links only. */
 	int equiv_id;
@@ -315,7 +335,7 @@
 	/* Alias is for symlinks only. */
 	YCHAR alias[YAFFS_MAX_ALIAS_LENGTH + 1];
 
-	u32 yst_rdev;		/* device stuff for block and char devices (major/min) */
+	u32 yst_rdev;	/* stuff for block and char devices (major/min) */
 
 	u32 win_ctime[2];
 	u32 win_atime[2];
@@ -324,10 +344,12 @@
 	u32 inband_shadowed_obj_id;
 	u32 inband_is_shrink;
 
-	u32 reserved[2];
-	int shadows_obj;	/* This object header shadows the specified object if > 0 */
+	u32 file_size_high;
+	u32 reserved[1];
+	int shadows_obj;	/* This object header shadows the
+				specified object if > 0 */
 
-	/* is_shrink applies to object headers written when we shrink the file (ie resize) */
+	/* is_shrink applies to object headers written when wemake a hole. */
 	u32 is_shrink;
 
 };
@@ -347,9 +369,9 @@
  */
 
 struct yaffs_file_var {
-	u32 file_size;
-	u32 scanned_size;
-	u32 shrink_size;
+	loff_t file_size;
+	loff_t scanned_size;
+	loff_t shrink_size;
 	int top_level;
 	struct yaffs_tnode *top;
 };
@@ -378,35 +400,43 @@
 struct yaffs_obj {
 	u8 deleted:1;		/* This should only apply to unlinked files. */
 	u8 soft_del:1;		/* it has also been soft deleted */
-	u8 unlinked:1;		/* An unlinked file. The file should be in the unlinked directory. */
+	u8 unlinked:1;		/* An unlinked file.*/
 	u8 fake:1;		/* A fake object has no presence on NAND. */
-	u8 rename_allowed:1;	/* Some objects are not allowed to be renamed. */
+	u8 rename_allowed:1;	/* Some objects cannot be renamed. */
 	u8 unlink_allowed:1;
 	u8 dirty:1;		/* the object needs to be written to flash */
 	u8 valid:1;		/* When the file system is being loaded up, this
 				 * object might be created before the data
-				 * is available (ie. file data records appear before the header).
-				 */
-	u8 lazy_loaded:1;	/* This object has been lazy loaded and is missing some detail */
-
-	u8 defered_free:1;	/* For Linux kernel. Object is removed from NAND, but is
-				 * still in the inode cache. Free of object is defered.
+				 * is available
+				 * ie. file data chunks encountered before
+				* the header.
+				 */
+	u8 lazy_loaded:1;	/* This object has been lazy loaded and
+				 * is missing some detail */
+
+	u8 defered_free:1;	/* Object is removed from NAND, but is
+				 * still in the inode cache.
+				 * Free of object is defered.
 				 * until the inode is released.
 				 */
-	u8 being_created:1;	/* This object is still being created so skip some checks. */
-	u8 is_shadowed:1;	/* This object is shadowed on the way to being renamed. */
-
-	u8 xattr_known:1;	/* We know if this has object has xattribs or not. */
-	u8 has_xattr:1;		/* This object has xattribs. Valid if xattr_known. */
+	u8 being_created:1;	/* This object is still being created
+				 * so skip some verification checks. */
+	u8 is_shadowed:1;	/* This object is shadowed on the way
+				 * to being renamed. */
+
+	u8 xattr_known:1;	/* We know if this has object has xattribs
+				 * or not. */
+	u8 has_xattr:1;		/* This object has xattribs.
+				 * Only valid if xattr_known. */
 
-	u8 serial;		/* serial number of chunk in NAND. Cached here */
+	u8 serial;		/* serial number of chunk in NAND.*/
 	u16 sum;		/* sum of the name to speed searching */
 
 	struct yaffs_dev *my_dev;	/* The device I'm on */
 
-	struct list_head hash_link;	/* list of objects in this hash bucket */
+	struct list_head hash_link;	/* list of objects in hash bucket */
 
-	struct list_head hard_links;	/* all the equivalent hard linked objects */
+	struct list_head hard_links;	/* hard linked object chain*/
 
 	/* directory structure stuff */
 	/* also used for linking up the free list */
@@ -416,15 +446,13 @@
 	/* Where's my object header in NAND? */
 	int hdr_chunk;
 
-	int n_data_chunks;	/* Number of data chunks attached to the file. */
+	int n_data_chunks;	/* Number of data chunks for this file. */
 
 	u32 obj_id;		/* the object id value */
 
 	u32 yst_mode;
 
-#ifndef CONFIG_YAFFS_NO_SHORT_NAMES
 	YCHAR short_name[YAFFS_SHORT_NAME_LENGTH + 1];
-#endif
 
 #ifdef CONFIG_YAFFS_WINCE
 	u32 win_ctime[2];
@@ -471,18 +499,17 @@
 	u8 unlink_allowed:1;
 	u8 serial;
 	int n_data_chunks;
-	u32 size_or_equiv_obj;
+	loff_t size_or_equiv_obj;
 };
 
 /*--------------------- Temporary buffers ----------------
  *
- * These are chunk-sized working buffers. Each device has a few
+ * These are chunk-sized working buffers. Each device has a few.
  */
 
 struct yaffs_buffer {
 	u8 *buffer;
-	int line;		/* track from whence this buffer was allocated */
-	int max_line;
+	int in_use;
 };
 
 /*----------------- Device ---------------------------------*/
@@ -497,26 +524,29 @@
 	 */
 
 	int inband_tags;	/* Use unband tags */
-	u32 total_bytes_per_chunk;	/* Should be >= 512, does not need to be a power of 2 */
+	u32 total_bytes_per_chunk;	/* Should be >= 512, does not need to
+					 be a power of 2 */
 	int chunks_per_block;	/* does not need to be a power of 2 */
 	int spare_bytes_per_chunk;	/* spare area size */
 	int start_block;	/* Start block we're allowed to use */
 	int end_block;		/* End block we're allowed to use */
-	int n_reserved_blocks;	/* We want this tuneable so that we can reduce */
-	/* reserved blocks on NOR and RAM. */
+	int n_reserved_blocks;	/* Tuneable so that we can reduce
+				 * reserved blocks on NOR and RAM. */
 
-	int n_caches;		/* If <= 0, then short op caching is disabled, else
-				 * the number of short op caches (don't use too many).
-				 * 10 to 20 is a good bet.
+	int n_caches;		/* If <= 0, then short op caching is disabled,
+				 * else the number of short op caches.
 				 */
-	int use_nand_ecc;	/* Flag to decide whether or not to use NANDECC on data (yaffs1) */
-	int no_tags_ecc;	/* Flag to decide whether or not to do ECC on packed tags (yaffs2) */
+	int use_nand_ecc;	/* Flag to decide whether or not to use
+				 * NAND driver ECC on data (yaffs1) */
+	int tags_9bytes;	/* Use 9 byte tags */
+	int no_tags_ecc;	/* Flag to decide whether or not to do ECC
+				 * on packed tags (yaffs2) */
 
 	int is_yaffs2;		/* Use yaffs2 mode on this device */
 
 	int empty_lost_n_found;	/* Auto-empty lost+found directory on mount */
 
-	int refresh_period;	/* How often we should check to do a block refresh */
+	int refresh_period;	/* How often to check for a block refresh */
 
 	/* Checkpoint control. Can be set before or after initialisation */
 	u8 skip_checkpt_rd;
@@ -526,47 +556,48 @@
 
 	/* NAND access functions (Must be set before calling YAFFS) */
 
-	int (*write_chunk_fn) (struct yaffs_dev * dev,
-			       int nand_chunk, const u8 * data,
-			       const struct yaffs_spare * spare);
-	int (*read_chunk_fn) (struct yaffs_dev * dev,
-			      int nand_chunk, u8 * data,
-			      struct yaffs_spare * spare);
-	int (*erase_fn) (struct yaffs_dev * dev, int flash_block);
-	int (*initialise_flash_fn) (struct yaffs_dev * dev);
-	int (*deinitialise_flash_fn) (struct yaffs_dev * dev);
-
-#ifdef CONFIG_YAFFS_YAFFS2
-	int (*write_chunk_tags_fn) (struct yaffs_dev * dev,
-				    int nand_chunk, const u8 * data,
-				    const struct yaffs_ext_tags * tags);
-	int (*read_chunk_tags_fn) (struct yaffs_dev * dev,
-				   int nand_chunk, u8 * data,
-				   struct yaffs_ext_tags * tags);
-	int (*bad_block_fn) (struct yaffs_dev * dev, int block_no);
-	int (*query_block_fn) (struct yaffs_dev * dev, int block_no,
-			       enum yaffs_block_state * state,
-			       u32 * seq_number);
-#endif
+	int (*write_chunk_fn) (struct yaffs_dev *dev,
+			       int nand_chunk, const u8 *data,
+			       const struct yaffs_spare *spare);
+	int (*read_chunk_fn) (struct yaffs_dev *dev,
+			      int nand_chunk, u8 *data,
+			      struct yaffs_spare *spare);
+	int (*erase_fn) (struct yaffs_dev *dev, int flash_block);
+	int (*initialise_flash_fn) (struct yaffs_dev *dev);
+	int (*deinitialise_flash_fn) (struct yaffs_dev *dev);
+
+	/* yaffs2 mode functions */
+	int (*write_chunk_tags_fn) (struct yaffs_dev *dev,
+				    int nand_chunk, const u8 *data,
+				    const struct yaffs_ext_tags *tags);
+	int (*read_chunk_tags_fn) (struct yaffs_dev *dev,
+				   int nand_chunk, u8 *data,
+				   struct yaffs_ext_tags *tags);
+	int (*bad_block_fn) (struct yaffs_dev *dev, int block_no);
+	int (*query_block_fn) (struct yaffs_dev *dev, int block_no,
+			       enum yaffs_block_state *state,
+			       u32 *seq_number);
 
 	/* The remove_obj_fn function must be supplied by OS flavours that
 	 * need it.
 	 * yaffs direct uses it to implement the faster readdir.
 	 * Linux uses it to protect the directory during unlocking.
 	 */
-	void (*remove_obj_fn) (struct yaffs_obj * obj);
+	void (*remove_obj_fn) (struct yaffs_obj *obj);
 
 	/* Callback to mark the superblock dirty */
-	void (*sb_dirty_fn) (struct yaffs_dev * dev);
+	void (*sb_dirty_fn) (struct yaffs_dev *dev);
 
 	/*  Callback to control garbage collection. */
-	unsigned (*gc_control) (struct yaffs_dev * dev);
+	unsigned (*gc_control) (struct yaffs_dev *dev);
 
 	/* Debug control flags. Don't use unless you know what you're doing */
-	int use_header_file_size;	/* Flag to determine if we should use file sizes from the header */
+	int use_header_file_size;	/* Flag to determine if we should use
+					 * file sizes from the header */
 	int disable_lazy_load;	/* Disable lazy loading on this device */
 	int wide_tnodes_disabled;	/* Set to disable wide tnodes */
-	int disable_soft_del;	/* yaffs 1 only: Set to disable the use of softdeletion. */
+	int disable_soft_del;	/* yaffs 1 only: Set to disable the use of
+				 * softdeletion. */
 
 	int defered_dir_update;	/* Set to defer directory updates */
 
@@ -574,6 +605,13 @@
 	int auto_unicode;
 #endif
 	int always_check_erased;	/* Force chunk erased check always on */
+
+	int disable_summary;
+
+	int max_objects;	/*
+				 * Set to limit the number of objects created.
+				 * 0 = no limit.
+				*/
 };
 
 struct yaffs_dev {
@@ -602,7 +640,7 @@
 
 	/* Stuff for figuring out file offset to chunk conversions */
 	u32 chunk_shift;	/* Shift value */
-	u32 chunk_div;		/* Divisor after shifting: 1 for power-of-2 sizes */
+	u32 chunk_div;		/* Divisor after shifting: 1 for 2^n sizes */
 	u32 chunk_mask;		/* Mask to use for power-of-2 case */
 
 	int is_mounted;
@@ -616,7 +654,7 @@
 	int chunk_offset;
 
 	/* Runtime checkpointing stuff */
-	int checkpt_page_seq;	/* running sequence number of checkpoint pages */
+	int checkpt_page_seq;	/* running sequence number of checkpt pages */
 	int checkpt_byte_count;
 	int checkpt_byte_offs;
 	u8 *checkpt_buffer;
@@ -630,13 +668,14 @@
 	u32 checkpt_sum;
 	u32 checkpt_xor;
 
-	int checkpoint_blocks_required;	/* Number of blocks needed to store current checkpoint set */
+	int checkpoint_blocks_required;	/* Number of blocks needed to store
+					 * current checkpoint set */
 
 	/* Block Info */
 	struct yaffs_block_info *block_info;
 	u8 *chunk_bits;		/* bitmap of chunks in use */
-	unsigned block_info_alt:1;	/* was allocated using alternative strategy */
-	unsigned chunk_bits_alt:1;	/* was allocated using alternative strategy */
+	unsigned block_info_alt:1;	/* allocated using alternative alloc */
+	unsigned chunk_bits_alt:1;	/* allocated using alternative alloc */
 	int chunk_bit_stride;	/* Number of bytes of chunk_bits per block.
 				 * Must be consistent with chunks_per_block.
 				 */
@@ -662,7 +701,8 @@
 	u32 *gc_cleanup_list;	/* objects to delete at the end of a GC. */
 	u32 n_clean_ups;
 
-	unsigned has_pending_prioritised_gc;	/* We think this device might have pending prioritised gcs */
+	unsigned has_pending_prioritised_gc;	/* We think this device might
+						have pending prioritised gcs */
 	unsigned gc_disable;
 	unsigned gc_block_finder;
 	unsigned gc_dirtiest;
@@ -671,16 +711,12 @@
 	unsigned gc_block;
 	unsigned gc_chunk;
 	unsigned gc_skip;
+	struct yaffs_summary_tags *gc_sum_tags;
 
 	/* Special directories */
 	struct yaffs_obj *root_dir;
 	struct yaffs_obj *lost_n_found;
 
-	/* Buffer areas for storing data to recover from write failures TODO
-	 *      u8            buffered_data[YAFFS_CHUNKS_PER_BLOCK][YAFFS_BYTES_PER_CHUNK];
-	 *      struct yaffs_spare buffered_spare[YAFFS_CHUNKS_PER_BLOCK];
-	 */
-
 	int buffered_block;	/* Which block is buffered here? */
 	int doing_buffered_block_rewrite;
 
@@ -688,9 +724,12 @@
 	int cache_last_use;
 
 	/* Stuff for background deletion and unlinked files. */
-	struct yaffs_obj *unlinked_dir;	/* Directory where unlinked and deleted files live. */
-	struct yaffs_obj *del_dir;	/* Directory where deleted objects are sent to disappear. */
-	struct yaffs_obj *unlinked_deletion;	/* Current file being background deleted. */
+	struct yaffs_obj *unlinked_dir;	/* Directory where unlinked and deleted
+					 files live. */
+	struct yaffs_obj *del_dir;	/* Directory where deleted objects are
+					sent to disappear. */
+	struct yaffs_obj *unlinked_deletion;	/* Current file being
+							background deleted. */
 	int n_deleted_files;	/* Count of files awaiting deletion; */
 	int n_unlinked_files;	/* Count of unlinked files. */
 	int n_bg_deletions;	/* Count of background deletions. */
@@ -703,17 +742,23 @@
 	int unmanaged_buffer_deallocs;
 
 	/* yaffs2 runtime stuff */
-	unsigned seq_number;	/* Sequence number of currently allocating block */
+	unsigned seq_number;	/* Sequence number of currently
+					allocating block */
 	unsigned oldest_dirty_seq;
 	unsigned oldest_dirty_block;
 
 	/* Block refreshing */
-	int refresh_skip;	/* A skip down counter. Refresh happens when this gets to zero. */
+	int refresh_skip;	/* A skip down counter.
+				 * Refresh happens when this gets to zero. */
 
 	/* Dirty directory handling */
 	struct list_head dirty_dirs;	/* List of dirty directories */
 
-	/* Statistcs */
+	/* Summary */
+	int chunks_per_summary;
+	struct yaffs_summary_tags *sum_tags;
+
+	/* Statistics */
 	u32 n_page_writes;
 	u32 n_page_reads;
 	u32 n_erasures;
@@ -724,7 +769,7 @@
 	u32 oldest_dirty_gc_count;
 	u32 n_gc_blocks;
 	u32 bg_gcs;
-	u32 n_retired_writes;
+	u32 n_retried_writes;
 	u32 n_retired_blocks;
 	u32 n_ecc_fixed;
 	u32 n_ecc_unfixed;
@@ -734,11 +779,13 @@
 	u32 n_unmarked_deletions;
 	u32 refresh_count;
 	u32 cache_hits;
+	u32 tags_used;
+	u32 summary_used;
 
 };
 
-/* The CheckpointDevice structure holds the device information that changes at runtime and
- * must be preserved over unmount/mount cycles.
+/* The CheckpointDevice structure holds the device information that changes
+ *at runtime and must be preserved over unmount/mount cycles.
  */
 struct yaffs_checkpt_dev {
 	int struct_type;
@@ -752,7 +799,8 @@
 	int n_bg_deletions;	/* Count of background deletions. */
 
 	/* yaffs2 runtime stuff */
-	unsigned seq_number;	/* Sequence number of currently allocating block */
+	unsigned seq_number;	/* Sequence number of currently
+				 * allocating block */
 
 };
 
@@ -793,7 +841,7 @@
 int yaffs_del_obj(struct yaffs_obj *obj);
 
 int yaffs_get_obj_name(struct yaffs_obj *obj, YCHAR * name, int buffer_size);
-int yaffs_get_obj_length(struct yaffs_obj *obj);
+loff_t yaffs_get_obj_length(struct yaffs_obj *obj);
 int yaffs_get_obj_inode(struct yaffs_obj *obj);
 unsigned yaffs_get_obj_type(struct yaffs_obj *obj);
 int yaffs_get_obj_link_count(struct yaffs_obj *obj);
@@ -806,7 +854,7 @@
 int yaffs_resize_file(struct yaffs_obj *obj, loff_t new_size);
 
 struct yaffs_obj *yaffs_create_file(struct yaffs_obj *parent,
-				    const YCHAR * name, u32 mode, u32 uid,
+				    const YCHAR *name, u32 mode, u32 uid,
 				    u32 gid);
 
 int yaffs_flush_file(struct yaffs_obj *obj, int update_time, int data_sync);
@@ -818,35 +866,35 @@
 int yaffs_checkpoint_restore(struct yaffs_dev *dev);
 
 /* Directory operations */
-struct yaffs_obj *yaffs_create_dir(struct yaffs_obj *parent, const YCHAR * name,
+struct yaffs_obj *yaffs_create_dir(struct yaffs_obj *parent, const YCHAR *name,
 				   u32 mode, u32 uid, u32 gid);
 struct yaffs_obj *yaffs_find_by_name(struct yaffs_obj *the_dir,
-				     const YCHAR * name);
+				     const YCHAR *name);
 struct yaffs_obj *yaffs_find_by_number(struct yaffs_dev *dev, u32 number);
 
 /* Link operations */
-struct yaffs_obj *yaffs_link_obj(struct yaffs_obj *parent, const YCHAR * name,
+struct yaffs_obj *yaffs_link_obj(struct yaffs_obj *parent, const YCHAR *name,
 				 struct yaffs_obj *equiv_obj);
 
 struct yaffs_obj *yaffs_get_equivalent_obj(struct yaffs_obj *obj);
 
 /* Symlink operations */
 struct yaffs_obj *yaffs_create_symlink(struct yaffs_obj *parent,
-				       const YCHAR * name, u32 mode, u32 uid,
-				       u32 gid, const YCHAR * alias);
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, const YCHAR *alias);
 YCHAR *yaffs_get_symlink_alias(struct yaffs_obj *obj);
 
 /* Special inodes (fifos, sockets and devices) */
 struct yaffs_obj *yaffs_create_special(struct yaffs_obj *parent,
-				       const YCHAR * name, u32 mode, u32 uid,
+				       const YCHAR *name, u32 mode, u32 uid,
 				       u32 gid, u32 rdev);
 
-int yaffs_set_xattrib(struct yaffs_obj *obj, const YCHAR * name,
+int yaffs_set_xattrib(struct yaffs_obj *obj, const YCHAR *name,
 		      const void *value, int size, int flags);
-int yaffs_get_xattrib(struct yaffs_obj *obj, const YCHAR * name, void *value,
+int yaffs_get_xattrib(struct yaffs_obj *obj, const YCHAR *name, void *value,
 		      int size);
 int yaffs_list_xattrib(struct yaffs_obj *obj, char *buffer, int size);
-int yaffs_remove_xattrib(struct yaffs_obj *obj, const YCHAR * name);
+int yaffs_remove_xattrib(struct yaffs_obj *obj, const YCHAR *name);
 
 /* Special directories */
 struct yaffs_obj *yaffs_root(struct yaffs_dev *dev);
@@ -866,26 +914,26 @@
 /* A few useful functions to be used within the core files*/
 void yaffs_chunk_del(struct yaffs_dev *dev, int chunk_id, int mark_flash,
 		     int lyn);
-int yaffs_check_ff(u8 * buffer, int n_bytes);
+int yaffs_check_ff(u8 *buffer, int n_bytes);
 void yaffs_handle_chunk_error(struct yaffs_dev *dev,
 			      struct yaffs_block_info *bi);
 
-u8 *yaffs_get_temp_buffer(struct yaffs_dev *dev, int line_no);
-void yaffs_release_temp_buffer(struct yaffs_dev *dev, u8 * buffer, int line_no);
+u8 *yaffs_get_temp_buffer(struct yaffs_dev *dev);
+void yaffs_release_temp_buffer(struct yaffs_dev *dev, u8 *buffer);
 
 struct yaffs_obj *yaffs_find_or_create_by_number(struct yaffs_dev *dev,
 						 int number,
 						 enum yaffs_obj_type type);
 int yaffs_put_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
 			    int nand_chunk, int in_scan);
-void yaffs_set_obj_name(struct yaffs_obj *obj, const YCHAR * name);
+void yaffs_set_obj_name(struct yaffs_obj *obj, const YCHAR *name);
 void yaffs_set_obj_name_from_oh(struct yaffs_obj *obj,
 				const struct yaffs_obj_hdr *oh);
 void yaffs_add_obj_to_dir(struct yaffs_obj *directory, struct yaffs_obj *obj);
-YCHAR *yaffs_clone_str(const YCHAR * str);
-void yaffs_link_fixup(struct yaffs_dev *dev, struct yaffs_obj *hard_list);
+YCHAR *yaffs_clone_str(const YCHAR *str);
+void yaffs_link_fixup(struct yaffs_dev *dev, struct list_head *hard_list);
 void yaffs_block_became_dirty(struct yaffs_dev *dev, int block_no);
-int yaffs_update_oh(struct yaffs_obj *in, const YCHAR * name,
+int yaffs_update_oh(struct yaffs_obj *in, const YCHAR *name,
 		    int force, int is_shrink, int shadows,
 		    struct yaffs_xattr_mod *xop);
 void yaffs_handle_shadowed_obj(struct yaffs_dev *dev, int obj_id,
@@ -897,7 +945,7 @@
 					   u32 chunk_id,
 					   struct yaffs_tnode *passed_tn);
 
-int yaffs_do_file_wr(struct yaffs_obj *in, const u8 * buffer, loff_t offset,
+int yaffs_do_file_wr(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
 		     int n_bytes, int write_trhrough);
 void yaffs_resize_file_down(struct yaffs_obj *obj, loff_t new_size);
 void yaffs_skip_rest_of_block(struct yaffs_dev *dev);
@@ -912,4 +960,16 @@
 			 unsigned pos);
 
 int yaffs_is_non_empty_dir(struct yaffs_obj *obj);
+
+void yaffs_addr_to_chunk(struct yaffs_dev *dev, loff_t addr,
+				int *chunk_out, u32 *offset_out);
+/*
+ * Marshalling functions to get loff_t file sizes into aand out of
+ * object headers.
+ */
+void yaffs_oh_size_load(struct yaffs_obj_hdr *oh, loff_t fsize);
+loff_t yaffs_oh_to_size(struct yaffs_obj_hdr *oh);
+loff_t yaffs_max_file_size(struct yaffs_dev *dev);
+
+
 #endif
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_linux.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_linux.h
--- linux-3.1.9/fs/yaffs2/yaffs_linux.h	2012-06-20 14:51:23.974803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_linux.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -25,11 +25,11 @@
 	struct task_struct *bg_thread;	/* Background thread for this device */
 	int bg_running;
 	struct mutex gross_lock;	/* Gross locking mutex*/
-	u8 *spare_buffer;	/* For mtdif2 use. Don't know the size of the buffer
+	u8 *spare_buffer;	/* For mtdif2 use. Don't know the buffer size
 				 * at compile time so we have to allocate it.
 				 */
 	struct list_head search_contexts;
-	void (*put_super_fn) (struct super_block * sb);
+	void (*put_super_fn) (struct super_block *sb);
 
 	struct task_struct *readdir_process;
 	unsigned mount_id;
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_mtdif1.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif1.c
--- linux-3.1.9/fs/yaffs2/yaffs_mtdif1.c	2012-06-20 14:51:23.974803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif1.c	2012-06-28 17:13:42.731665002 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another FFS. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -36,10 +36,36 @@
 #include "linux/types.h"
 #include "linux/mtd/mtd.h"
 
-#ifndef CONFIG_YAFFS_9BYTE_TAGS
-# define YTAG1_SIZE 8
-#else
-# define YTAG1_SIZE 9
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
+#define MTD_OPS_AUTO_OOB MTD_OOB_AUTO
+#endif
+
+
+/* Don't compile this module if we don't have MTD's mtd_oob_ops interface */
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+
+
+#if 0
+/* Use the following nand_ecclayout with MTD when using
+ * 9 byte tags and the older on-NAND tags layout.
+ * If you have existing Yaffs images and the byte order differs from this,
+ * adjust 'oobfree' to match your existing Yaffs data.
+ *
+ * This nand_ecclayout scatters/gathers to/from the old-yaffs layout with the
+ * page_status byte (at NAND spare offset 4) scattered/gathered from/to
+ * the 9th byte.
+ *
+ * Old-style on-NAND format: T0,T1,T2,T3,P,B,T4,T5,E0,E1,E2,T6,T7,E3,E4,E5
+ * We have/need packed_tags1 plus page_status: T0,T1,T2,T3,T4,T5,T6,T7,P
+ * where Tn are the tag bytes, En are MTD's ECC bytes, P is the page_status
+ * byte and B is the small-page bad-block indicator byte.
+ */
+static struct nand_ecclayout nand_oob_16 = {
+	.eccbytes = 6,
+	.eccpos = {8, 9, 10, 13, 14, 15},
+	.oobavail = 9,
+	.oobfree = {{0, 4}, {6, 2}, {11, 2}, {4, 1} }
+};
 #endif
 
 /* Write a chunk (page) of data to NAND.
@@ -64,7 +90,7 @@
  * Returns YAFFS_OK or YAFFS_FAIL.
  */
 int nandmtd1_write_chunk_tags(struct yaffs_dev *dev,
-			      int nand_chunk, const u8 * data,
+			      int nand_chunk, const u8 *data,
 			      const struct yaffs_ext_tags *etags)
 {
 	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
@@ -87,27 +113,27 @@
 	 * that only zeroed-bits stick and set tag bytes to all-ones and
 	 * zero just the (not) deleted bit.
 	 */
-#ifndef CONFIG_YAFFS_9BYTE_TAGS
+	if(dev->param.tags_9bytes) {
+        	((u8 *) &pt1)[8] = 0xff;
 	if (etags->is_deleted) {
 		memset(&pt1, 0xff, 8);
-		/* clear delete status bit to indicate deleted */
-		pt1.deleted = 0;
+        		/* zero page_status byte to indicate deleted */
+	        	((u8 *) &pt1)[8] = 0;
 	}
-#else
-	((u8 *) & pt1)[8] = 0xff;
+        } else {
 	if (etags->is_deleted) {
 		memset(&pt1, 0xff, 8);
-		/* zero page_status byte to indicate deleted */
-		((u8 *) & pt1)[8] = 0;
+	        	/* clear delete status bit to indicate deleted */
+        		pt1.deleted = 0;
+                }
 	}
-#endif
 
 	memset(&ops, 0, sizeof(ops));
-	ops.mode = MTD_OOB_AUTO;
+	ops.mode = MTD_OPS_AUTO_OOB;
 	ops.len = (data) ? chunk_bytes : 0;
-	ops.ooblen = YTAG1_SIZE;
+	ops.ooblen = dev->param.tags_9bytes ? 9 : 8;
 	ops.datbuf = (u8 *) data;
-	ops.oobbuf = (u8 *) & pt1;
+	ops.oobbuf = (u8 *) &pt1;
 
 	retval = mtd->write_oob(mtd, addr, &ops);
 	if (retval) {
@@ -143,7 +169,7 @@
  * Returns YAFFS_OK or YAFFS_FAIL.
  */
 int nandmtd1_read_chunk_tags(struct yaffs_dev *dev,
-			     int nand_chunk, u8 * data,
+			     int nand_chunk, u8 *data,
 			     struct yaffs_ext_tags *etags)
 {
 	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
@@ -156,21 +182,26 @@
 	int deleted;
 
 	memset(&ops, 0, sizeof(ops));
-	ops.mode = MTD_OOB_AUTO;
+	ops.mode = MTD_OPS_AUTO_OOB;
 	ops.len = (data) ? chunk_bytes : 0;
-	ops.ooblen = YTAG1_SIZE;
+	ops.ooblen = dev->param.tags_9bytes ? 9 : 8;
 	ops.datbuf = data;
-	ops.oobbuf = (u8 *) & pt1;
+	ops.oobbuf = (u8 *) &pt1;
 
+#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 20))
+	/* In MTD 2.6.18 to 2.6.19 nand_base.c:nand_do_read_oob() has a bug;
+	 * help it out with ops.len = ops.ooblen when ops.datbuf == NULL.
+	 */
+	ops.len = (ops.datbuf) ? ops.len : ops.ooblen;
+#endif
 	/* Read page and oob using MTD.
 	 * Check status and determine ECC result.
 	 */
 	retval = mtd->read_oob(mtd, addr, &ops);
-	if (retval) {
+	if (retval)
 		yaffs_trace(YAFFS_TRACE_MTD,
 			"read_oob failed, chunk %d, mtd error %d",
 			nand_chunk, retval);
-	}
 
 	switch (retval) {
 	case 0:
@@ -195,20 +226,21 @@
 
 	/* Check for a blank/erased chunk.
 	 */
-	if (yaffs_check_ff((u8 *) & pt1, 8)) {
+	if (yaffs_check_ff((u8 *) &pt1, 8)) {
 		/* when blank, upper layers want ecc_result to be <= NO_ERROR */
 		return rettags(etags, YAFFS_ECC_RESULT_NO_ERROR, YAFFS_OK);
 	}
-#ifndef CONFIG_YAFFS_9BYTE_TAGS
+
+	if(dev->param.tags_9bytes) {
+        	deleted = (hweight8(((u8 *) &pt1)[8]) < 7);
+        } else {
 	/* Read deleted status (bit) then return it to it's non-deleted
 	 * state before performing tags mini-ECC check. pt1.deleted is
 	 * inverted.
 	 */
 	deleted = !pt1.deleted;
 	pt1.deleted = 1;
-#else
-	deleted = (yaffs_count_bits(((u8 *) & pt1)[8]) < 7);
-#endif
+        }
 
 	/* Check the packed tags mini-ECC and correct if necessary/possible.
 	 */
@@ -232,7 +264,7 @@
 	/* Unpack the tags to extended form and set ECC result.
 	 * [set should_be_ff just to keep yaffs_unpack_tags1 happy]
 	 */
-	pt1.should_be_ff = 0xFFFFFFFF;
+	pt1.should_be_ff = 0xffffffff;
 	yaffs_unpack_tags1(etags, &pt1);
 	etags->ecc_result = eccres;
 
@@ -254,8 +286,7 @@
 	int blocksize = dev->param.chunks_per_block * dev->data_bytes_per_chunk;
 	int retval;
 
-	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
-		"marking block %d bad", block_no);
+	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, "marking block %d bad", block_no);
 
 	retval = mtd->block_markbad(mtd, (loff_t) blocksize * block_no);
 	return (retval) ? YAFFS_FAIL : YAFFS_OK;
@@ -265,16 +296,16 @@
  *
  * Returns YAFFS_OK or YAFFS_FAIL.
  */
-static int nandmtd1_test_prerequists(struct mtd_info *mtd)
+static int nandmtd1_test_prerequists(struct yaffs_dev *dev, struct mtd_info *mtd)
 {
 	/* 2.6.18 has mtd->ecclayout->oobavail */
 	/* 2.6.21 has mtd->ecclayout->oobavail and mtd->oobavail */
 	int oobavail = mtd->ecclayout->oobavail;
 
-	if (oobavail < YTAG1_SIZE) {
+	if (oobavail < (dev->param.tags_9bytes ? 9 : 8)) {
 		yaffs_trace(YAFFS_TRACE_ERROR,
 			"mtd device has only %d bytes for tags, need %d",
-			oobavail, YTAG1_SIZE);
+			oobavail, dev->param.tags_9bytes ? 9 : 8);
 		return YAFFS_FAIL;
 	}
 	return YAFFS_OK;
@@ -284,7 +315,7 @@
  *
  * Examine the tags of the first chunk of the block and return the state:
  *  - YAFFS_BLOCK_STATE_DEAD, the block is marked bad
- *  - YAFFS_BLOCK_STATE_NEEDS_SCANNING, the block is in use
+ *  - YAFFS_BLOCK_STATE_NEEDS_SCAN, the block is in use
  *  - YAFFS_BLOCK_STATE_EMPTY, the block is clean
  *
  * Always returns YAFFS_OK.
@@ -303,20 +334,21 @@
 	/* We don't yet have a good place to test for MTD config prerequists.
 	 * Do it here as we are called during the initial scan.
 	 */
-	if (nandmtd1_test_prerequists(mtd) != YAFFS_OK)
+	if (nandmtd1_test_prerequists(dev, mtd) != YAFFS_OK)
 		return YAFFS_FAIL;
 
 	retval = nandmtd1_read_chunk_tags(dev, chunk_num, NULL, &etags);
 	etags.block_bad = (mtd->block_isbad) (mtd, addr);
 	if (etags.block_bad) {
 		yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
-			"block %d is marked bad", block_no);
+			"block %d is marked bad",
+			block_no);
 		state = YAFFS_BLOCK_STATE_DEAD;
 	} else if (etags.ecc_result != YAFFS_ECC_RESULT_NO_ERROR) {
 		/* bad tags, need to look more closely */
-		state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+		state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
 	} else if (etags.chunk_used) {
-		state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+		state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
 		seqnum = etags.seq_number;
 	} else {
 		state = YAFFS_BLOCK_STATE_EMPTY;
@@ -328,3 +360,5 @@
 	/* query always succeeds */
 	return YAFFS_OK;
 }
+
+#endif /*MTD_VERSION */
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_mtdif1.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif1.h
--- linux-3.1.9/fs/yaffs2/yaffs_mtdif1.h	2012-06-20 14:51:23.974803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif1.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * This program is free software; you can redistribute it and/or modify
@@ -15,15 +15,15 @@
 #define __YAFFS_MTDIF1_H__
 
 int nandmtd1_write_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
-			      const u8 * data,
+			      const u8 *data,
 			      const struct yaffs_ext_tags *tags);
 
 int nandmtd1_read_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
-			     u8 * data, struct yaffs_ext_tags *tags);
+			     u8 *data, struct yaffs_ext_tags *tags);
 
 int nandmtd1_mark_block_bad(struct yaffs_dev *dev, int block_no);
 
 int nandmtd1_query_block(struct yaffs_dev *dev, int block_no,
-			 enum yaffs_block_state *state, u32 * seq_number);
+			 enum yaffs_block_state *state, u32 *seq_number);
 
 #endif
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_mtdif1_multi.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif1_multi.c
--- linux-3.1.9/fs/yaffs2/yaffs_mtdif1_multi.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif1_multi.c	2012-06-28 16:54:39.719622577 -0600
@@ -0,0 +1,364 @@
+/*
+ * YAFFS: Yet another FFS. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This module provides the interface between yaffs_nand.c and the
+ * MTD API.  This version is used when the MTD interface supports the
+ * 'mtd_oob_ops' style calls to read_oob and write_oob, circa 2.6.17,
+ * and we have small-page NAND device.
+ *
+ * These functions are invoked via function pointers in yaffs_nand.c.
+ * This replaces functionality provided by functions in yaffs_mtdif.c
+ * and the yaffs_tags compatability functions in yaffs_tagscompat.c that are
+ * called in yaffs_mtdif.c when the function pointers are NULL.
+ * We assume the MTD layer is performing ECC (use_nand_ecc is true).
+ */
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+#include "yaffs_packedtags1.h"
+#include "yaffs_tagscompat.h"	/* for yaffs_calc_tags_ecc */
+#include "yaffs_linux.h"
+
+#include "linux/kernel.h"
+#include "linux/version.h"
+#include "linux/types.h"
+#include "linux/mtd/mtd.h"
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
+#define MTD_OPS_AUTO_OOB MTD_OOB_AUTO
+#endif
+
+
+/* Don't compile this module if we don't have MTD's mtd_oob_ops interface */
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+
+
+#if 0
+/* Use the following nand_ecclayout with MTD when using
+ * 9 byte tags and the older on-NAND tags layout.
+ * If you have existing Yaffs images and the byte order differs from this,
+ * adjust 'oobfree' to match your existing Yaffs data.
+ *
+ * This nand_ecclayout scatters/gathers to/from the old-yaffs layout with the
+ * page_status byte (at NAND spare offset 4) scattered/gathered from/to
+ * the 9th byte.
+ *
+ * Old-style on-NAND format: T0,T1,T2,T3,P,B,T4,T5,E0,E1,E2,T6,T7,E3,E4,E5
+ * We have/need packed_tags1 plus page_status: T0,T1,T2,T3,T4,T5,T6,T7,P
+ * where Tn are the tag bytes, En are MTD's ECC bytes, P is the page_status
+ * byte and B is the small-page bad-block indicator byte.
+ */
+static struct nand_ecclayout nand_oob_16 = {
+	.eccbytes = 6,
+	.eccpos = {8, 9, 10, 13, 14, 15},
+	.oobavail = 9,
+	.oobfree = {{0, 4}, {6, 2}, {11, 2}, {4, 1} }
+};
+#endif
+
+/* Write a chunk (page) of data to NAND.
+ *
+ * Caller always provides ExtendedTags data which are converted to a more
+ * compact (packed) form for storage in NAND.  A mini-ECC runs over the
+ * contents of the tags meta-data; used to valid the tags when read.
+ *
+ *  - Pack ExtendedTags to packed_tags1 form
+ *  - Compute mini-ECC for packed_tags1
+ *  - Write data and packed tags to NAND.
+ *
+ * Note: Due to the use of the packed_tags1 meta-data which does not include
+ * a full sequence number (as found in the larger packed_tags2 form) it is
+ * necessary for Yaffs to re-write a chunk/page (just once) to mark it as
+ * discarded and dirty.  This is not ideal: newer NAND parts are supposed
+ * to be written just once.  When Yaffs performs this operation, this
+ * function is called with a NULL data pointer -- calling MTD write_oob
+ * without data is valid usage (2.6.17).
+ *
+ * Any underlying MTD error results in YAFFS_FAIL.
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_write_chunk_tags(struct yaffs_dev *dev,
+			      int nand_chunk, const u8 *data,
+			      const struct yaffs_ext_tags *etags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int chunk_bytes = dev->data_bytes_per_chunk;
+	loff_t addr = ((loff_t) nand_chunk) * chunk_bytes;
+	struct mtd_oob_ops ops;
+	struct yaffs_packed_tags1 pt1;
+	int retval;
+
+	/* we assume that packed_tags1 and struct yaffs_tags are compatible */
+	compile_time_assertion(sizeof(struct yaffs_packed_tags1) == 12);
+	compile_time_assertion(sizeof(struct yaffs_tags) == 8);
+
+	yaffs_pack_tags1(&pt1, etags);
+	yaffs_calc_tags_ecc((struct yaffs_tags *)&pt1);
+
+	/* When deleting a chunk, the upper layer provides only skeletal
+	 * etags, one with is_deleted set.  However, we need to update the
+	 * tags, not erase them completely.  So we use the NAND write property
+	 * that only zeroed-bits stick and set tag bytes to all-ones and
+	 * zero just the (not) deleted bit.
+	 */
+	if(dev->param.tags_9bytes) {
+        	((u8 *) &pt1)[8] = 0xff;
+        	if (etags->is_deleted) {
+		        memset(&pt1, 0xff, 8);
+        		/* zero page_status byte to indicate deleted */
+	        	((u8 *) &pt1)[8] = 0;
+                }
+        } else {
+        	if (etags->is_deleted) {
+	        	memset(&pt1, 0xff, 8);
+	        	/* clear delete status bit to indicate deleted */
+        		pt1.deleted = 0;
+                }
+	}
+
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OPS_AUTO_OOB;
+	ops.len = (data) ? chunk_bytes : 0;
+	ops.ooblen = dev->param.tags_9bytes ? 9 : 8;
+	ops.datbuf = (u8 *) data;
+	ops.oobbuf = (u8 *) &pt1;
+
+	retval = mtd->write_oob(mtd, addr, &ops);
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"write_oob failed, chunk %d, mtd error %d",
+			nand_chunk, retval);
+	}
+	return retval ? YAFFS_FAIL : YAFFS_OK;
+}
+
+/* Return with empty ExtendedTags but add ecc_result.
+ */
+static int rettags(struct yaffs_ext_tags *etags, int ecc_result, int retval)
+{
+	if (etags) {
+		memset(etags, 0, sizeof(*etags));
+		etags->ecc_result = ecc_result;
+	}
+	return retval;
+}
+
+/* Read a chunk (page) from NAND.
+ *
+ * Caller expects ExtendedTags data to be usable even on error; that is,
+ * all members except ecc_result and block_bad are zeroed.
+ *
+ *  - Check ECC results for data (if applicable)
+ *  - Check for blank/erased block (return empty ExtendedTags if blank)
+ *  - Check the packed_tags1 mini-ECC (correct if necessary/possible)
+ *  - Convert packed_tags1 to ExtendedTags
+ *  - Update ecc_result and block_bad members to refect state.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_read_chunk_tags(struct yaffs_dev *dev,
+			     int nand_chunk, u8 *data,
+			     struct yaffs_ext_tags *etags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int chunk_bytes = dev->data_bytes_per_chunk;
+	loff_t addr = ((loff_t) nand_chunk) * chunk_bytes;
+	int eccres = YAFFS_ECC_RESULT_NO_ERROR;
+	struct mtd_oob_ops ops;
+	struct yaffs_packed_tags1 pt1;
+	int retval;
+	int deleted;
+
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OPS_AUTO_OOB;
+	ops.len = (data) ? chunk_bytes : 0;
+	ops.ooblen = dev->param.tags_9bytes ? 9 : 8;
+	ops.datbuf = data;
+	ops.oobbuf = (u8 *) &pt1;
+
+#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 20))
+	/* In MTD 2.6.18 to 2.6.19 nand_base.c:nand_do_read_oob() has a bug;
+	 * help it out with ops.len = ops.ooblen when ops.datbuf == NULL.
+	 */
+	ops.len = (ops.datbuf) ? ops.len : ops.ooblen;
+#endif
+	/* Read page and oob using MTD.
+	 * Check status and determine ECC result.
+	 */
+	retval = mtd->read_oob(mtd, addr, &ops);
+	if (retval)
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"read_oob failed, chunk %d, mtd error %d",
+			nand_chunk, retval);
+
+	switch (retval) {
+	case 0:
+		/* no error */
+		break;
+
+	case -EUCLEAN:
+		/* MTD's ECC fixed the data */
+		eccres = YAFFS_ECC_RESULT_FIXED;
+		dev->n_ecc_fixed++;
+		break;
+
+	case -EBADMSG:
+		/* MTD's ECC could not fix the data */
+		dev->n_ecc_unfixed++;
+		/* fall into... */
+	default:
+		rettags(etags, YAFFS_ECC_RESULT_UNFIXED, 0);
+		etags->block_bad = (mtd->block_isbad) (mtd, addr);
+		return YAFFS_FAIL;
+	}
+
+	/* Check for a blank/erased chunk.
+	 */
+	if (yaffs_check_ff((u8 *) &pt1, 8)) {
+		/* when blank, upper layers want ecc_result to be <= NO_ERROR */
+		return rettags(etags, YAFFS_ECC_RESULT_NO_ERROR, YAFFS_OK);
+	}
+
+	if(dev->param.tags_9bytes) {
+        	deleted = (hweight8(((u8 *) &pt1)[8]) < 7);
+        } else {
+        	/* Read deleted status (bit) then return it to it's non-deleted
+	         * state before performing tags mini-ECC check. pt1.deleted is
+        	 * inverted.
+	         */
+        	deleted = !pt1.deleted;
+        	pt1.deleted = 1;
+        }
+
+	/* Check the packed tags mini-ECC and correct if necessary/possible.
+	 */
+	retval = yaffs_check_tags_ecc((struct yaffs_tags *)&pt1);
+	switch (retval) {
+	case 0:
+		/* no tags error, use MTD result */
+		break;
+	case 1:
+		/* recovered tags-ECC error */
+		dev->n_tags_ecc_fixed++;
+		if (eccres == YAFFS_ECC_RESULT_NO_ERROR)
+			eccres = YAFFS_ECC_RESULT_FIXED;
+		break;
+	default:
+		/* unrecovered tags-ECC error */
+		dev->n_tags_ecc_unfixed++;
+		return rettags(etags, YAFFS_ECC_RESULT_UNFIXED, YAFFS_FAIL);
+	}
+
+	/* Unpack the tags to extended form and set ECC result.
+	 * [set should_be_ff just to keep yaffs_unpack_tags1 happy]
+	 */
+	pt1.should_be_ff = 0xffffffff;
+	yaffs_unpack_tags1(etags, &pt1);
+	etags->ecc_result = eccres;
+
+	/* Set deleted state */
+	etags->is_deleted = deleted;
+	return YAFFS_OK;
+}
+
+/* Mark a block bad.
+ *
+ * This is a persistant state.
+ * Use of this function should be rare.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_mark_block_bad(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int blocksize = dev->param.chunks_per_block * dev->data_bytes_per_chunk;
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, "marking block %d bad", block_no);
+
+	retval = mtd->block_markbad(mtd, (loff_t) blocksize * block_no);
+	return (retval) ? YAFFS_FAIL : YAFFS_OK;
+}
+
+/* Check any MTD prerequists.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+static int nandmtd1_test_prerequists(struct yaffs_dev *dev, struct mtd_info *mtd)
+{
+	/* 2.6.18 has mtd->ecclayout->oobavail */
+	/* 2.6.21 has mtd->ecclayout->oobavail and mtd->oobavail */
+	int oobavail = mtd->ecclayout->oobavail;
+
+	if (oobavail < (dev->param.tags_9bytes ? 9 : 8)) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"mtd device has only %d bytes for tags, need %d",
+			oobavail, dev->param.tags_9bytes ? 9 : 8);
+		return YAFFS_FAIL;
+	}
+	return YAFFS_OK;
+}
+
+/* Query for the current state of a specific block.
+ *
+ * Examine the tags of the first chunk of the block and return the state:
+ *  - YAFFS_BLOCK_STATE_DEAD, the block is marked bad
+ *  - YAFFS_BLOCK_STATE_NEEDS_SCAN, the block is in use
+ *  - YAFFS_BLOCK_STATE_EMPTY, the block is clean
+ *
+ * Always returns YAFFS_OK.
+ */
+int nandmtd1_query_block(struct yaffs_dev *dev, int block_no,
+			 enum yaffs_block_state *state_ptr, u32 * seq_ptr)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int chunk_num = block_no * dev->param.chunks_per_block;
+	loff_t addr = (loff_t) chunk_num * dev->data_bytes_per_chunk;
+	struct yaffs_ext_tags etags;
+	int state = YAFFS_BLOCK_STATE_DEAD;
+	int seqnum = 0;
+	int retval;
+
+	/* We don't yet have a good place to test for MTD config prerequists.
+	 * Do it here as we are called during the initial scan.
+	 */
+	if (nandmtd1_test_prerequists(dev, mtd) != YAFFS_OK)
+		return YAFFS_FAIL;
+
+	retval = nandmtd1_read_chunk_tags(dev, chunk_num, NULL, &etags);
+	etags.block_bad = (mtd->block_isbad) (mtd, addr);
+	if (etags.block_bad) {
+		yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+			"block %d is marked bad",
+			block_no);
+		state = YAFFS_BLOCK_STATE_DEAD;
+	} else if (etags.ecc_result != YAFFS_ECC_RESULT_NO_ERROR) {
+		/* bad tags, need to look more closely */
+		state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+	} else if (etags.chunk_used) {
+		state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+		seqnum = etags.seq_number;
+	} else {
+		state = YAFFS_BLOCK_STATE_EMPTY;
+	}
+
+	*state_ptr = state;
+	*seq_ptr = seqnum;
+
+	/* query always succeeds */
+	return YAFFS_OK;
+}
+
+#endif /*MTD_VERSION */
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_mtdif1_single.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif1_single.c
--- linux-3.1.9/fs/yaffs2/yaffs_mtdif1_single.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif1_single.c	2012-06-28 16:54:39.719622577 -0600
@@ -0,0 +1,325 @@
+/*
+ * YAFFS: Yet another FFS. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This module provides the interface between yaffs_nand.c and the
+ * MTD API.  This version is used when the MTD interface supports the
+ * 'mtd_oob_ops' style calls to read_oob and write_oob, circa 2.6.17,
+ * and we have small-page NAND device.
+ *
+ * These functions are invoked via function pointers in yaffs_nand.c.
+ * This replaces functionality provided by functions in yaffs_mtdif.c
+ * and the yaffs_tags compatability functions in yaffs_tagscompat.c that are
+ * called in yaffs_mtdif.c when the function pointers are NULL.
+ * We assume the MTD layer is performing ECC (use_nand_ecc is true).
+ */
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+#include "yaffs_packedtags1.h"
+#include "yaffs_tagscompat.h"	/* for yaffs_calc_tags_ecc */
+#include "yaffs_linux.h"
+#include "linux/kernel.h"
+#include "linux/version.h"
+#include "linux/types.h"
+#include "linux/mtd/mtd.h"
+
+/* Write a chunk (page) of data to NAND.
+ *
+ * Caller always provides ExtendedTags data which are converted to a more
+ * compact (packed) form for storage in NAND.  A mini-ECC runs over the
+ * contents of the tags meta-data; used to valid the tags when read.
+ *
+ *  - Pack ExtendedTags to packed_tags1 form
+ *  - Compute mini-ECC for packed_tags1
+ *  - Write data and packed tags to NAND.
+ *
+ * Note: Due to the use of the packed_tags1 meta-data which does not include
+ * a full sequence number (as found in the larger packed_tags2 form) it is
+ * necessary for Yaffs to re-write a chunk/page (just once) to mark it as
+ * discarded and dirty.  This is not ideal: newer NAND parts are supposed
+ * to be written just once.  When Yaffs performs this operation, this
+ * function is called with a NULL data pointer -- calling MTD write_oob
+ * without data is valid usage (2.6.17).
+ *
+ * Any underlying MTD error results in YAFFS_FAIL.
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_write_chunk_tags(struct yaffs_dev *dev,
+			      int nand_chunk, const u8 *data,
+			      const struct yaffs_ext_tags *etags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int chunk_bytes = dev->data_bytes_per_chunk;
+	loff_t addr = ((loff_t) nand_chunk) * chunk_bytes;
+	struct mtd_oob_ops ops;
+	struct yaffs_packed_tags1 pt1;
+	int retval;
+
+	/* we assume that packed_tags1 and struct yaffs_tags are compatible */
+	compile_time_assertion(sizeof(struct yaffs_packed_tags1) == 12);
+	compile_time_assertion(sizeof(struct yaffs_tags) == 8);
+
+	yaffs_pack_tags1(&pt1, etags);
+	yaffs_calc_tags_ecc((struct yaffs_tags *)&pt1);
+
+	/* When deleting a chunk, the upper layer provides only skeletal
+	 * etags, one with is_deleted set.  However, we need to update the
+	 * tags, not erase them completely.  So we use the NAND write property
+	 * that only zeroed-bits stick and set tag bytes to all-ones and
+	 * zero just the (not) deleted bit.
+	 */
+
+	if (dev->param.tags_9bytes) {
+		((u8 *) &pt1)[8] = 0xff;
+		if (etags->is_deleted) {
+			memset(&pt1, 0xff, 8);
+			/* zero page_status byte to indicate deleted */
+			((u8 *) &pt1)[8] = 0;
+		}
+	} else {
+		if (etags->is_deleted) {
+			memset(&pt1, 0xff, 8);
+			/* clear delete status bit to indicate deleted */
+			pt1.deleted = 0;
+		}
+	}
+
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OPS_AUTO_OOB;
+	ops.len = (data) ? chunk_bytes : 0;
+	ops.ooblen = dev->param.tags_9bytes ? 9 : 8;
+	ops.datbuf = (u8 *) data;
+	ops.oobbuf = (u8 *) &pt1;
+
+	retval = mtd->write_oob(mtd, addr, &ops);
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"write_oob failed, chunk %d, mtd error %d",
+			nand_chunk, retval);
+	}
+	return retval ? YAFFS_FAIL : YAFFS_OK;
+}
+
+/* Return with empty ExtendedTags but add ecc_result.
+ */
+static int rettags(struct yaffs_ext_tags *etags, int ecc_result, int retval)
+{
+	if (etags) {
+		memset(etags, 0, sizeof(*etags));
+		etags->ecc_result = ecc_result;
+	}
+	return retval;
+}
+
+/* Read a chunk (page) from NAND.
+ *
+ * Caller expects ExtendedTags data to be usable even on error; that is,
+ * all members except ecc_result and block_bad are zeroed.
+ *
+ *  - Check ECC results for data (if applicable)
+ *  - Check for blank/erased block (return empty ExtendedTags if blank)
+ *  - Check the packed_tags1 mini-ECC (correct if necessary/possible)
+ *  - Convert packed_tags1 to ExtendedTags
+ *  - Update ecc_result and block_bad members to refect state.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_read_chunk_tags(struct yaffs_dev *dev,
+			     int nand_chunk, u8 *data,
+			     struct yaffs_ext_tags *etags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int chunk_bytes = dev->data_bytes_per_chunk;
+	loff_t addr = ((loff_t) nand_chunk) * chunk_bytes;
+	int eccres = YAFFS_ECC_RESULT_NO_ERROR;
+	struct mtd_oob_ops ops;
+	struct yaffs_packed_tags1 pt1;
+	int retval;
+	int deleted;
+
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OPS_AUTO_OOB;
+	ops.len = (data) ? chunk_bytes : 0;
+	ops.ooblen =  dev->param.tags_9bytes ? 9 : 8;
+	ops.datbuf = data;
+	ops.oobbuf = (u8 *) &pt1;
+
+	/* Read page and oob using MTD.
+	 * Check status and determine ECC result.
+	 */
+	retval = mtd->read_oob(mtd, addr, &ops);
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"read_oob failed, chunk %d, mtd error %d",
+			nand_chunk, retval);
+	}
+
+	switch (retval) {
+	case 0:
+		/* no error */
+		break;
+
+	case -EUCLEAN:
+		/* MTD's ECC fixed the data */
+		eccres = YAFFS_ECC_RESULT_FIXED;
+		dev->n_ecc_fixed++;
+		break;
+
+	case -EBADMSG:
+		/* MTD's ECC could not fix the data */
+		dev->n_ecc_unfixed++;
+		/* fall into... */
+	default:
+		rettags(etags, YAFFS_ECC_RESULT_UNFIXED, 0);
+		etags->block_bad = (mtd->block_isbad) (mtd, addr);
+		return YAFFS_FAIL;
+	}
+
+	/* Check for a blank/erased chunk.
+	 */
+	if (yaffs_check_ff((u8 *) &pt1, 8)) {
+		/* when blank, upper layers want ecc_result to be <= NO_ERROR */
+		return rettags(etags, YAFFS_ECC_RESULT_NO_ERROR, YAFFS_OK);
+	}
+#ifndef CONFIG_YAFFS_9BYTE_TAGS
+	/* Read deleted status (bit) then return it to it's non-deleted
+	 * state before performing tags mini-ECC check. pt1.deleted is
+	 * inverted.
+	 */
+	deleted = !pt1.deleted;
+	pt1.deleted = 1;
+#else
+	deleted = (hweight8(((u8 *) &pt1)[8]) < 7);
+#endif
+
+	/* Check the packed tags mini-ECC and correct if necessary/possible.
+	 */
+	retval = yaffs_check_tags_ecc((struct yaffs_tags *)&pt1);
+	switch (retval) {
+	case 0:
+		/* no tags error, use MTD result */
+		break;
+	case 1:
+		/* recovered tags-ECC error */
+		dev->n_tags_ecc_fixed++;
+		if (eccres == YAFFS_ECC_RESULT_NO_ERROR)
+			eccres = YAFFS_ECC_RESULT_FIXED;
+		break;
+	default:
+		/* unrecovered tags-ECC error */
+		dev->n_tags_ecc_unfixed++;
+		return rettags(etags, YAFFS_ECC_RESULT_UNFIXED, YAFFS_FAIL);
+	}
+
+	/* Unpack the tags to extended form and set ECC result.
+	 * [set should_be_ff just to keep yaffs_unpack_tags1 happy]
+	 */
+	pt1.should_be_ff = 0xffffffff;
+	yaffs_unpack_tags1(etags, &pt1);
+	etags->ecc_result = eccres;
+
+	/* Set deleted state */
+	etags->is_deleted = deleted;
+	return YAFFS_OK;
+}
+
+/* Mark a block bad.
+ *
+ * This is a persistant state.
+ * Use of this function should be rare.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_mark_block_bad(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int blocksize = dev->param.chunks_per_block * dev->data_bytes_per_chunk;
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+		"marking block %d bad", block_no);
+
+	retval = mtd->block_markbad(mtd, (loff_t) blocksize * block_no);
+	return (retval) ? YAFFS_FAIL : YAFFS_OK;
+}
+
+/* Check any MTD prerequists.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+static int nandmtd1_test_prerequists(struct yaffs_dev *dev,
+					struct mtd_info *mtd)
+{
+	/* 2.6.18 has mtd->ecclayout->oobavail */
+	/* 2.6.21 has mtd->ecclayout->oobavail and mtd->oobavail */
+	int oobavail = mtd->ecclayout->oobavail;
+
+	if (oobavail < (dev->param.tags_9bytes ? 9 : 8)) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"mtd device has only %d bytes for tags, need %d",
+			oobavail, (dev->param.tags_9bytes ? 9 : 8));
+		return YAFFS_FAIL;
+	}
+	return YAFFS_OK;
+}
+
+/* Query for the current state of a specific block.
+ *
+ * Examine the tags of the first chunk of the block and return the state:
+ *  - YAFFS_BLOCK_STATE_DEAD, the block is marked bad
+ *  - YAFFS_BLOCK_STATE_NEEDS_SCAN, the block is in use
+ *  - YAFFS_BLOCK_STATE_EMPTY, the block is clean
+ *
+ * Always returns YAFFS_OK.
+ */
+int nandmtd1_query_block(struct yaffs_dev *dev, int block_no,
+			 enum yaffs_block_state *state_ptr, u32 * seq_ptr)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int chunk_num = block_no * dev->param.chunks_per_block;
+	loff_t addr = (loff_t) chunk_num * dev->data_bytes_per_chunk;
+	struct yaffs_ext_tags etags;
+	int state = YAFFS_BLOCK_STATE_DEAD;
+	int seqnum = 0;
+	int retval;
+
+	/* We don't yet have a good place to test for MTD config prerequists.
+	 * Do it here as we are called during the initial scan.
+	 */
+	if (nandmtd1_test_prerequists(dev, mtd) != YAFFS_OK)
+		return YAFFS_FAIL;
+
+	retval = nandmtd1_read_chunk_tags(dev, chunk_num, NULL, &etags);
+	etags.block_bad = (mtd->block_isbad) (mtd, addr);
+	if (etags.block_bad) {
+		yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+			"block %d is marked bad", block_no);
+		state = YAFFS_BLOCK_STATE_DEAD;
+	} else if (etags.ecc_result != YAFFS_ECC_RESULT_NO_ERROR) {
+		/* bad tags, need to look more closely */
+		state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+	} else if (etags.chunk_used) {
+		state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+		seqnum = etags.seq_number;
+	} else {
+		state = YAFFS_BLOCK_STATE_EMPTY;
+	}
+
+	*state_ptr = state;
+	*seq_ptr = seqnum;
+
+	/* query always succeeds */
+	return YAFFS_OK;
+}
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_mtdif2.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif2.c
--- linux-3.1.9/fs/yaffs2/yaffs_mtdif2.c	2012-06-20 14:51:23.974803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif2.c	2012-06-28 17:13:47.999665198 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -26,16 +26,26 @@
 
 #include "yaffs_linux.h"
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
+#define MTD_OPS_AUTO_OOB MTD_OOB_AUTO
+#endif
+
+
+
 /* NB For use with inband tags....
- * We assume that the data buffer is of size total_bytes_per_chunk so that we can also
- * use it to load the tags.
+ * We assume that the data buffer is of size total_bytes_per_chunk so
+ * that we can also use it to load the tags.
  */
 int nandmtd2_write_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
-			      const u8 * data,
+			      const u8 *data,
 			      const struct yaffs_ext_tags *tags)
 {
 	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
 	struct mtd_oob_ops ops;
+#else
+	size_t dummy;
+#endif
 	int retval = 0;
 
 	loff_t addr;
@@ -70,7 +80,8 @@
 		yaffs_pack_tags2(&pt, tags, !dev->param.no_tags_ecc);
         }
 
-	ops.mode = MTD_OOB_AUTO;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+	ops.mode = MTD_OPS_AUTO_OOB;
 	ops.ooblen = (dev->param.inband_tags) ? 0 : packed_tags_size;
 	ops.len = dev->param.total_bytes_per_chunk;
 	ops.ooboffs = 0;
@@ -78,6 +89,18 @@
 	ops.oobbuf = (dev->param.inband_tags) ? NULL : packed_tags_ptr;
 	retval = mtd->write_oob(mtd, addr, &ops);
 
+#else
+	if (!dev->param.inband_tags) {
+		retval =
+		    mtd->write_ecc(mtd, addr, dev->data_bytes_per_chunk,
+				   &dummy, data, (u8 *) packed_tags_ptr, NULL);
+	} else {
+		retval =
+		    mtd->write(mtd, addr, dev->param.total_bytes_per_chunk,
+			       &dummy, data);
+	}
+#endif
+
 	if (retval == 0)
 		return YAFFS_OK;
 	else
@@ -85,11 +108,12 @@
 }
 
 int nandmtd2_read_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
-			     u8 * data, struct yaffs_ext_tags *tags)
+			     u8 *data, struct yaffs_ext_tags *tags)
 {
 	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
 	struct mtd_oob_ops ops;
-
+#endif
 	size_t dummy;
 	int retval = 0;
 	int local_data = 0;
@@ -111,16 +135,17 @@
 
 		if (!data) {
 			local_data = 1;
-			data = yaffs_get_temp_buffer(dev, __LINE__);
+			data = yaffs_get_temp_buffer(dev);
 		}
 
 	}
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
 	if (dev->param.inband_tags || (data && !tags))
 		retval = mtd->read(mtd, addr, dev->param.total_bytes_per_chunk,
 				   &dummy, data);
 	else if (tags) {
-		ops.mode = MTD_OOB_AUTO;
+		ops.mode = MTD_OPS_AUTO_OOB;
 		ops.ooblen = packed_tags_size;
 		ops.len = data ? dev->data_bytes_per_chunk : packed_tags_size;
 		ops.ooboffs = 0;
@@ -128,13 +153,29 @@
 		ops.oobbuf = yaffs_dev_to_lc(dev)->spare_buffer;
 		retval = mtd->read_oob(mtd, addr, &ops);
 	}
+#else
+	if (!dev->param.inband_tags && data && tags) {
+
+		retval = mtd->read_ecc(mtd, addr, dev->data_bytes_per_chunk,
+				       &dummy, data, dev->spare_buffer, NULL);
+	} else {
+		if (data)
+			retval =
+			    mtd->read(mtd, addr, dev->data_bytes_per_chunk,
+				      &dummy, data);
+		if (!dev->param.inband_tags && tags)
+			retval =
+			    mtd->read_oob(mtd, addr, mtd->oobsize, &dummy,
+					  dev->spare_buffer);
+	}
+#endif
 
 	if (dev->param.inband_tags) {
 		if (tags) {
 			struct yaffs_packed_tags2_tags_only *pt2tp;
 			pt2tp =
-			    (struct yaffs_packed_tags2_tags_only *)&data[dev->
-									 data_bytes_per_chunk];
+				(struct yaffs_packed_tags2_tags_only *)
+				&data[dev->data_bytes_per_chunk];
 			yaffs_unpack_tags2_tags_only(tags, pt2tp);
 		}
 	} else {
@@ -147,7 +188,7 @@
 	}
 
 	if (local_data)
-		yaffs_release_temp_buffer(dev, data, __LINE__);
+		yaffs_release_temp_buffer(dev, data);
 
 	if (tags && retval == -EBADMSG
 	    && tags->ecc_result == YAFFS_ECC_RESULT_NO_ERROR) {
@@ -170,7 +211,8 @@
 	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
 	int retval;
 	yaffs_trace(YAFFS_TRACE_MTD,
-		"nandmtd2_mark_block_bad %d", block_no);
+		"nandmtd2_mark_block_bad %d",
+		block_no);
 
 	retval =
 	    mtd->block_markbad(mtd,
@@ -185,7 +227,7 @@
 }
 
 int nandmtd2_query_block(struct yaffs_dev *dev, int block_no,
-			 enum yaffs_block_state *state, u32 * seq_number)
+			 enum yaffs_block_state *state, u32 *seq_number)
 {
 	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
 	int retval;
@@ -208,14 +250,15 @@
 
 		if (t.chunk_used) {
 			*seq_number = t.seq_number;
-			*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+			*state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
 		} else {
 			*seq_number = 0;
 			*state = YAFFS_BLOCK_STATE_EMPTY;
 		}
 	}
 	yaffs_trace(YAFFS_TRACE_MTD,
-		"block is bad seq %d state %d", *seq_number, *state);
+		"block is bad seq %d state %d",
+		*seq_number, *state);
 
 	if (retval == 0)
 		return YAFFS_OK;
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_mtdif2.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif2.h
--- linux-3.1.9/fs/yaffs2/yaffs_mtdif2.h	2012-06-20 14:51:23.974803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif2.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -18,12 +18,12 @@
 
 #include "yaffs_guts.h"
 int nandmtd2_write_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
-			      const u8 * data,
+			      const u8 *data,
 			      const struct yaffs_ext_tags *tags);
 int nandmtd2_read_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
-			     u8 * data, struct yaffs_ext_tags *tags);
+			     u8 *data, struct yaffs_ext_tags *tags);
 int nandmtd2_mark_block_bad(struct yaffs_dev *dev, int block_no);
 int nandmtd2_query_block(struct yaffs_dev *dev, int block_no,
-			 enum yaffs_block_state *state, u32 * seq_number);
+			 enum yaffs_block_state *state, u32 *seq_number);
 
 #endif
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_mtdif2_multi.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif2_multi.c
--- linux-3.1.9/fs/yaffs2/yaffs_mtdif2_multi.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif2_multi.c	2012-06-28 16:54:39.719622577 -0600
@@ -0,0 +1,268 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* mtd interface for YAFFS2 */
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+
+#include "yaffs_mtdif2.h"
+
+#include "linux/mtd/mtd.h"
+#include "linux/types.h"
+#include "linux/time.h"
+
+#include "yaffs_packedtags2.h"
+
+#include "yaffs_linux.h"
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
+#define MTD_OPS_AUTO_OOB MTD_OOB_AUTO
+#endif
+
+
+
+/* NB For use with inband tags....
+ * We assume that the data buffer is of size total_bytes_per_chunk so
+ * that we can also use it to load the tags.
+ */
+int nandmtd2_write_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			      const u8 *data,
+			      const struct yaffs_ext_tags *tags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#else
+	size_t dummy;
+#endif
+	int retval = 0;
+
+	loff_t addr;
+
+	struct yaffs_packed_tags2 pt;
+
+	int packed_tags_size =
+	    dev->param.no_tags_ecc ? sizeof(pt.t) : sizeof(pt);
+	void *packed_tags_ptr =
+	    dev->param.no_tags_ecc ? (void *)&pt.t : (void *)&pt;
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"nandmtd2_write_chunk_tags chunk %d data %p tags %p",
+		nand_chunk, data, tags);
+
+	addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
+
+	/* For yaffs2 writing there must be both data and tags.
+	 * If we're using inband tags, then the tags are stuffed into
+	 * the end of the data buffer.
+	 */
+	if (!data || !tags)
+		BUG();
+	else if (dev->param.inband_tags) {
+		struct yaffs_packed_tags2_tags_only *pt2tp;
+		pt2tp =
+		    (struct yaffs_packed_tags2_tags_only *)(data +
+							dev->
+							data_bytes_per_chunk);
+		yaffs_pack_tags2_tags_only(pt2tp, tags);
+	} else {
+		yaffs_pack_tags2(&pt, tags, !dev->param.no_tags_ecc);
+	}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+	ops.mode = MTD_OPS_AUTO_OOB;
+	ops.ooblen = (dev->param.inband_tags) ? 0 : packed_tags_size;
+	ops.len = dev->param.total_bytes_per_chunk;
+	ops.ooboffs = 0;
+	ops.datbuf = (u8 *) data;
+	ops.oobbuf = (dev->param.inband_tags) ? NULL : packed_tags_ptr;
+	retval = mtd->write_oob(mtd, addr, &ops);
+
+#else
+	if (!dev->param.inband_tags) {
+		retval =
+		    mtd->write_ecc(mtd, addr, dev->data_bytes_per_chunk,
+				   &dummy, data, (u8 *) packed_tags_ptr, NULL);
+	} else {
+		retval =
+		    mtd->write(mtd, addr, dev->param.total_bytes_per_chunk,
+			       &dummy, data);
+	}
+#endif
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd2_read_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *data, struct yaffs_ext_tags *tags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#endif
+	size_t dummy;
+	int retval = 0;
+	int local_data = 0;
+
+	loff_t addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
+
+	struct yaffs_packed_tags2 pt;
+
+	int packed_tags_size =
+	    dev->param.no_tags_ecc ? sizeof(pt.t) : sizeof(pt);
+	void *packed_tags_ptr =
+	    dev->param.no_tags_ecc ? (void *)&pt.t : (void *)&pt;
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"nandmtd2_read_chunk_tags chunk %d data %p tags %p",
+		nand_chunk, data, tags);
+
+	if (dev->param.inband_tags) {
+
+		if (!data) {
+			local_data = 1;
+			data = yaffs_get_temp_buffer(dev);
+		}
+
+	}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+	if (dev->param.inband_tags || (data && !tags))
+		retval = mtd->read(mtd, addr, dev->param.total_bytes_per_chunk,
+				   &dummy, data);
+	else if (tags) {
+		ops.mode = MTD_OPS_AUTO_OOB;
+		ops.ooblen = packed_tags_size;
+		ops.len = data ? dev->data_bytes_per_chunk : packed_tags_size;
+		ops.ooboffs = 0;
+		ops.datbuf = data;
+		ops.oobbuf = yaffs_dev_to_lc(dev)->spare_buffer;
+		retval = mtd->read_oob(mtd, addr, &ops);
+	}
+#else
+	if (!dev->param.inband_tags && data && tags) {
+
+		retval = mtd->read_ecc(mtd, addr, dev->data_bytes_per_chunk,
+				       &dummy, data, dev->spare_buffer, NULL);
+	} else {
+		if (data)
+			retval =
+			    mtd->read(mtd, addr, dev->data_bytes_per_chunk,
+				      &dummy, data);
+		if (!dev->param.inband_tags && tags)
+			retval =
+			    mtd->read_oob(mtd, addr, mtd->oobsize, &dummy,
+					  dev->spare_buffer);
+	}
+#endif
+
+	if (dev->param.inband_tags) {
+		if (tags) {
+			struct yaffs_packed_tags2_tags_only *pt2tp;
+			pt2tp =
+				(struct yaffs_packed_tags2_tags_only *)
+				&data[dev->data_bytes_per_chunk];
+			yaffs_unpack_tags2_tags_only(tags, pt2tp);
+		}
+	} else {
+		if (tags) {
+			memcpy(packed_tags_ptr,
+			       yaffs_dev_to_lc(dev)->spare_buffer,
+			       packed_tags_size);
+			yaffs_unpack_tags2(tags, &pt, !dev->param.no_tags_ecc);
+		}
+	}
+
+	if (local_data)
+		yaffs_release_temp_buffer(dev, data);
+
+	if (tags && retval == -EBADMSG
+	    && tags->ecc_result == YAFFS_ECC_RESULT_NO_ERROR) {
+		tags->ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+		dev->n_ecc_unfixed++;
+	}
+	if (tags && retval == -EUCLEAN
+	    && tags->ecc_result == YAFFS_ECC_RESULT_NO_ERROR) {
+		tags->ecc_result = YAFFS_ECC_RESULT_FIXED;
+		dev->n_ecc_fixed++;
+	}
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd2_mark_block_bad(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int retval;
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"nandmtd2_mark_block_bad %d",
+		block_no);
+
+	retval =
+	    mtd->block_markbad(mtd,
+			       block_no * dev->param.chunks_per_block *
+			       dev->param.total_bytes_per_chunk);
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+
+}
+
+int nandmtd2_query_block(struct yaffs_dev *dev, int block_no,
+			 enum yaffs_block_state *state, u32 *seq_number)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_MTD, "nandmtd2_query_block %d", block_no);
+	retval =
+	    mtd->block_isbad(mtd,
+			     block_no * dev->param.chunks_per_block *
+			     dev->param.total_bytes_per_chunk);
+
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD, "block is bad");
+
+		*state = YAFFS_BLOCK_STATE_DEAD;
+		*seq_number = 0;
+	} else {
+		struct yaffs_ext_tags t;
+		nandmtd2_read_chunk_tags(dev, block_no *
+					 dev->param.chunks_per_block, NULL, &t);
+
+		if (t.chunk_used) {
+			*seq_number = t.seq_number;
+			*state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+		} else {
+			*seq_number = 0;
+			*state = YAFFS_BLOCK_STATE_EMPTY;
+		}
+	}
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"block is bad seq %d state %d",
+		*seq_number, *state);
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_mtdif2_single.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif2_single.c
--- linux-3.1.9/fs/yaffs2/yaffs_mtdif2_single.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif2_single.c	2012-06-28 16:54:39.719622577 -0600
@@ -0,0 +1,210 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* mtd interface for YAFFS2 */
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_mtdif2.h"
+#include "yaffs_packedtags2.h"
+#include "yaffs_linux.h"
+#include "linux/mtd/mtd.h"
+#include "linux/types.h"
+#include "linux/time.h"
+#include "mtd/mtd-abi.h"
+
+
+/* NB For use with inband tags....
+ * We assume that the data buffer is of size total_bytes_per_chunk so that
+ * we can also use it to load the tags.
+ */
+int nandmtd2_write_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			      const u8 *data,
+			      const struct yaffs_ext_tags *tags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	struct mtd_oob_ops ops;
+	int retval = 0;
+	loff_t addr;
+	struct yaffs_packed_tags2 pt;
+	int packed_tags_size =
+	    dev->param.no_tags_ecc ? sizeof(pt.t) : sizeof(pt);
+	void *packed_tags_ptr =
+	    dev->param.no_tags_ecc ? (void *)&pt.t : (void *)&pt;
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"nandmtd2_write_chunk_tags chunk %d data %p tags %p",
+		nand_chunk, data, tags);
+
+	addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
+
+	/* For yaffs2 writing there must be both data and tags.
+	 * If we're using inband tags, then the tags are stuffed into
+	 * the end of the data buffer.
+	 */
+	if (!data || !tags)
+		BUG();
+	else if (dev->param.inband_tags) {
+		struct yaffs_packed_tags2_tags_only *pt2tp;
+
+		pt2tp =
+		    (struct yaffs_packed_tags2_tags_only *)
+			(data + dev->data_bytes_per_chunk);
+		yaffs_pack_tags2_tags_only(pt2tp, tags);
+	} else {
+		yaffs_pack_tags2(&pt, tags, !dev->param.no_tags_ecc);
+	}
+
+	ops.mode = MTD_OPS_AUTO_OOB;
+	ops.ooblen = (dev->param.inband_tags) ? 0 : packed_tags_size;
+	ops.len = dev->param.total_bytes_per_chunk;
+	ops.ooboffs = 0;
+	ops.datbuf = (u8 *) data;
+	ops.oobbuf = (dev->param.inband_tags) ? NULL : packed_tags_ptr;
+	retval = mtd->write_oob(mtd, addr, &ops);
+
+	if (retval == 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
+
+int nandmtd2_read_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *data, struct yaffs_ext_tags *tags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	struct mtd_oob_ops ops;
+	size_t dummy;
+	int retval = 0;
+	int local_data = 0;
+	loff_t addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
+	struct yaffs_packed_tags2 pt;
+	int packed_tags_size =
+	    dev->param.no_tags_ecc ? sizeof(pt.t) : sizeof(pt);
+	void *packed_tags_ptr =
+	    dev->param.no_tags_ecc ? (void *)&pt.t : (void *)&pt;
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"nandmtd2_read_chunk_tags chunk %d data %p tags %p",
+		nand_chunk, data, tags);
+
+	if (dev->param.inband_tags && !data) {
+		local_data = 1;
+		data = yaffs_get_temp_buffer(dev);
+	}
+
+	if (dev->param.inband_tags || (data && !tags)) {
+		retval = mtd->read(mtd, addr, dev->param.total_bytes_per_chunk,
+				   &dummy, data);
+	} else if (tags) {
+		ops.mode = MTD_OPS_AUTO_OOB;
+		ops.ooblen = packed_tags_size;
+		ops.len = data ? dev->data_bytes_per_chunk : packed_tags_size;
+		ops.ooboffs = 0;
+		ops.datbuf = data;
+		ops.oobbuf = yaffs_dev_to_lc(dev)->spare_buffer;
+		retval = mtd->read_oob(mtd, addr, &ops);
+	}
+
+	if (dev->param.inband_tags && tags) {
+		struct yaffs_packed_tags2_tags_only *pt2tp;
+
+		pt2tp =
+			(struct yaffs_packed_tags2_tags_only *)
+				&data[dev->data_bytes_per_chunk];
+		yaffs_unpack_tags2_tags_only(tags, pt2tp);
+	} else if (tags) {
+		memcpy(packed_tags_ptr,
+		       yaffs_dev_to_lc(dev)->spare_buffer,
+		       packed_tags_size);
+		yaffs_unpack_tags2(tags, &pt, !dev->param.no_tags_ecc);
+	}
+
+	if (local_data)
+		yaffs_release_temp_buffer(dev, data);
+
+	if (tags && retval == -EBADMSG &&
+	    tags->ecc_result == YAFFS_ECC_RESULT_NO_ERROR) {
+		tags->ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+		dev->n_ecc_unfixed++;
+	}
+	if (tags && retval == -EUCLEAN &&
+	    tags->ecc_result == YAFFS_ECC_RESULT_NO_ERROR) {
+		tags->ecc_result = YAFFS_ECC_RESULT_FIXED;
+		dev->n_ecc_fixed++;
+	}
+
+	if (retval == 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
+
+int nandmtd2_mark_block_bad(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"nandmtd2_mark_block_bad %d", block_no);
+
+	retval =
+	    mtd->block_markbad(mtd,
+			       block_no * dev->param.chunks_per_block *
+			       dev->param.total_bytes_per_chunk);
+
+	if (retval == 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
+
+int nandmtd2_query_block(struct yaffs_dev *dev, int block_no,
+			 enum yaffs_block_state *state, u32 * seq_number)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_MTD, "nandmtd2_query_block %d", block_no);
+	retval =
+	    mtd->block_isbad(mtd,
+			     block_no * dev->param.chunks_per_block *
+			     dev->param.total_bytes_per_chunk);
+
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD, "block is bad");
+
+		*state = YAFFS_BLOCK_STATE_DEAD;
+		*seq_number = 0;
+	} else {
+		struct yaffs_ext_tags t;
+
+		nandmtd2_read_chunk_tags(dev, block_no *
+					 dev->param.chunks_per_block, NULL, &t);
+
+		if (t.chunk_used) {
+			*seq_number = t.seq_number;
+			*state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+		} else {
+			*seq_number = 0;
+			*state = YAFFS_BLOCK_STATE_EMPTY;
+		}
+	}
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"block is bad seq %d state %d", *seq_number, *state);
+
+	if (retval == 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_mtdif.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif.c
--- linux-3.1.9/fs/yaffs2/yaffs_mtdif.c	2012-06-20 14:51:23.974803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif.c	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -26,10 +26,9 @@
 {
 	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
 	u32 addr =
-	    ((loff_t) block_no) * dev->param.total_bytes_per_chunk
-	    * dev->param.chunks_per_block;
+	    ((loff_t) block_no) * dev->param.total_bytes_per_chunk *
+	    dev->param.chunks_per_block;
 	struct erase_info ei;
-
 	int retval = 0;
 
 	ei.mtd = mtd;
@@ -44,7 +43,7 @@
 
 	if (retval == 0)
 		return YAFFS_OK;
-	else
+
 		return YAFFS_FAIL;
 }
 
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_mtdif.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif.h
--- linux-3.1.9/fs/yaffs2/yaffs_mtdif.h	2012-06-20 14:51:23.974803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_mtdif.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_nameval.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_nameval.c
--- linux-3.1.9/fs/yaffs2/yaffs_nameval.c	2012-06-20 14:51:23.974803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_nameval.c	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -12,8 +12,8 @@
  */
 
 /*
- * This simple implementation of a name-value store assumes a small number of values and fits
- * into a small finite buffer.
+ * This simple implementation of a name-value store assumes a small number of
+* values and fits into a small finite buffer.
  *
  * Each attribute is stored as a record:
  *  sizeof(int) bytes   record size.
@@ -29,7 +29,7 @@
 
 #include "yportenv.h"
 
-static int nval_find(const char *xb, int xb_size, const YCHAR * name,
+static int nval_find(const char *xb, int xb_size, const YCHAR *name,
 		     int *exist_size)
 {
 	int pos = 0;
@@ -37,8 +37,8 @@
 
 	memcpy(&size, xb, sizeof(int));
 	while (size > 0 && (size < xb_size) && (pos + size < xb_size)) {
-		if (strncmp
-		    ((YCHAR *) (xb + pos + sizeof(int)), name, size) == 0) {
+		if (!strncmp((YCHAR *) (xb + pos + sizeof(int)),
+				name, size)) {
 			if (exist_size)
 				*exist_size = size;
 			return pos;
@@ -51,7 +51,7 @@
 	}
 	if (exist_size)
 		*exist_size = 0;
-	return -1;
+	return -ENODATA;
 }
 
 static int nval_used(const char *xb, int xb_size)
@@ -70,23 +70,23 @@
 	return pos;
 }
 
-int nval_del(char *xb, int xb_size, const YCHAR * name)
+int nval_del(char *xb, int xb_size, const YCHAR *name)
 {
 	int pos = nval_find(xb, xb_size, name, NULL);
 	int size;
 
-	if (pos >= 0 && pos < xb_size) {
-		/* Find size, shift rest over this record, then zero out the rest of buffer */
+	if (pos < 0 || pos >= xb_size)
+		return -ENODATA;
+
+	/* Find size, shift rest over this record,
+	 * then zero out the rest of buffer */
 		memcpy(&size, xb + pos, sizeof(int));
 		memcpy(xb + pos, xb + pos + size, xb_size - (pos + size));
 		memset(xb + (xb_size - size), 0, size);
 		return 0;
-	} else {
-		return -ENODATA;
-        }
 }
 
-int nval_set(char *xb, int xb_size, const YCHAR * name, const char *buf,
+int nval_set(char *xb, int xb_size, const YCHAR *name, const char *buf,
 	     int bsize, int flags)
 {
 	int pos;
@@ -147,15 +147,20 @@
 		pos++;
 		size--;
 
+		/* If bsize is zero then this is a size query.
+		 * Return the size, but don't copy.
+		 */
+		if (!bsize)
+			return size;
+
 		if (size <= bsize) {
 			memcpy(buf, xb + pos, size);
 			return size;
 		}
-
 	}
 	if (pos >= 0)
 		return -ERANGE;
-	else
+
 		return -ENODATA;
 }
 
@@ -168,8 +173,10 @@
 	int filled = 0;
 
 	memcpy(&size, xb + pos, sizeof(int));
-	while (size > sizeof(int) && size <= xb_size && (pos + size) < xb_size
-	       && !filled) {
+	while (size > sizeof(int) &&
+		size <= xb_size &&
+		(pos + size) < xb_size &&
+		!filled) {
 		pos += sizeof(int);
 		size -= sizeof(int);
 		name_len = strnlen((YCHAR *) (xb + pos), size);
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_nameval.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_nameval.h
--- linux-3.1.9/fs/yaffs2/yaffs_nameval.h	2012-06-20 14:51:23.974803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_nameval.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_nand.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_nand.c
--- linux-3.1.9/fs/yaffs2/yaffs_nand.c	2012-06-20 14:51:23.974803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_nand.c	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -13,31 +13,30 @@
 
 #include "yaffs_nand.h"
 #include "yaffs_tagscompat.h"
-#include "yaffs_tagsvalidity.h"
 
 #include "yaffs_getblockinfo.h"
+#include "yaffs_summary.h"
 
 int yaffs_rd_chunk_tags_nand(struct yaffs_dev *dev, int nand_chunk,
-			     u8 * buffer, struct yaffs_ext_tags *tags)
+			     u8 *buffer, struct yaffs_ext_tags *tags)
 {
 	int result;
 	struct yaffs_ext_tags local_tags;
-
-	int realigned_chunk = nand_chunk - dev->chunk_offset;
+	int flash_chunk = nand_chunk - dev->chunk_offset;
 
 	dev->n_page_reads++;
 
-	/* If there are no tags provided, use local tags to get prioritised gc working */
+	/* If there are no tags provided use local tags. */
 	if (!tags)
 		tags = &local_tags;
 
 	if (dev->param.read_chunk_tags_fn)
 		result =
-		    dev->param.read_chunk_tags_fn(dev, realigned_chunk, buffer,
+		    dev->param.read_chunk_tags_fn(dev, flash_chunk, buffer,
 						  tags);
 	else
 		result = yaffs_tags_compat_rd(dev,
-					      realigned_chunk, buffer, tags);
+					      flash_chunk, buffer, tags);
 	if (tags && tags->ecc_result > YAFFS_ECC_RESULT_NO_ERROR) {
 
 		struct yaffs_block_info *bi;
@@ -46,64 +45,61 @@
 					  dev->param.chunks_per_block);
 		yaffs_handle_chunk_error(dev, bi);
 	}
-
 	return result;
 }
 
 int yaffs_wr_chunk_tags_nand(struct yaffs_dev *dev,
 			     int nand_chunk,
-			     const u8 * buffer, struct yaffs_ext_tags *tags)
+				const u8 *buffer, struct yaffs_ext_tags *tags)
 {
+	int result;
+	int flash_chunk = nand_chunk - dev->chunk_offset;
 
 	dev->n_page_writes++;
 
-	nand_chunk -= dev->chunk_offset;
-
 	if (tags) {
 		tags->seq_number = dev->seq_number;
 		tags->chunk_used = 1;
-		if (!yaffs_validate_tags(tags)) {
-			yaffs_trace(YAFFS_TRACE_ERROR, "Writing uninitialised tags");
-			YBUG();
-		}
 		yaffs_trace(YAFFS_TRACE_WRITE,
 			"Writing chunk %d tags %d %d",
 			nand_chunk, tags->obj_id, tags->chunk_id);
 	} else {
 		yaffs_trace(YAFFS_TRACE_ERROR, "Writing with no tags");
-		YBUG();
+		BUG();
+		return YAFFS_FAIL;
 	}
 
 	if (dev->param.write_chunk_tags_fn)
-		return dev->param.write_chunk_tags_fn(dev, nand_chunk, buffer,
-						      tags);
+		result = dev->param.write_chunk_tags_fn(dev, flash_chunk,
+							buffer, tags);
 	else
-		return yaffs_tags_compat_wr(dev, nand_chunk, buffer, tags);
+		result = yaffs_tags_compat_wr(dev, flash_chunk, buffer, tags);
+
+	yaffs_summary_add(dev, tags, nand_chunk);
+
+	return result;
 }
 
 int yaffs_mark_bad(struct yaffs_dev *dev, int block_no)
 {
 	block_no -= dev->block_offset;
-
 	if (dev->param.bad_block_fn)
 		return dev->param.bad_block_fn(dev, block_no);
-	else
+
 		return yaffs_tags_compat_mark_bad(dev, block_no);
 }
 
 int yaffs_query_init_block_state(struct yaffs_dev *dev,
 				 int block_no,
 				 enum yaffs_block_state *state,
-				 u32 * seq_number)
+				 u32 *seq_number)
 {
 	block_no -= dev->block_offset;
-
 	if (dev->param.query_block_fn)
 		return dev->param.query_block_fn(dev, block_no, state,
 						 seq_number);
-	else
-		return yaffs_tags_compat_query_block(dev, block_no,
-						     state, seq_number);
+
+	return yaffs_tags_compat_query_block(dev, block_no, state, seq_number);
 }
 
 int yaffs_erase_block(struct yaffs_dev *dev, int flash_block)
@@ -111,11 +107,8 @@
 	int result;
 
 	flash_block -= dev->block_offset;
-
 	dev->n_erasures++;
-
 	result = dev->param.erase_fn(dev, flash_block);
-
 	return result;
 }
 
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_nand.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_nand.h
--- linux-3.1.9/fs/yaffs2/yaffs_nand.h	2012-06-20 14:51:23.974803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_nand.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -18,11 +18,11 @@
 #include "yaffs_guts.h"
 
 int yaffs_rd_chunk_tags_nand(struct yaffs_dev *dev, int nand_chunk,
-			     u8 * buffer, struct yaffs_ext_tags *tags);
+			     u8 *buffer, struct yaffs_ext_tags *tags);
 
 int yaffs_wr_chunk_tags_nand(struct yaffs_dev *dev,
 			     int nand_chunk,
-			     const u8 * buffer, struct yaffs_ext_tags *tags);
+			     const u8 *buffer, struct yaffs_ext_tags *tags);
 
 int yaffs_mark_bad(struct yaffs_dev *dev, int block_no);
 
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_packedtags1.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_packedtags1.c
--- linux-3.1.9/fs/yaffs2/yaffs_packedtags1.c	2012-06-20 14:51:23.978803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_packedtags1.c	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -14,6 +14,14 @@
 #include "yaffs_packedtags1.h"
 #include "yportenv.h"
 
+static const u8 all_ff[20] = {
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff
+};
+
 void yaffs_pack_tags1(struct yaffs_packed_tags1 *pt,
 		      const struct yaffs_ext_tags *t)
 {
@@ -24,21 +32,16 @@
 	pt->ecc = 0;
 	pt->deleted = (t->is_deleted) ? 0 : 1;
 	pt->unused_stuff = 0;
-	pt->should_be_ff = 0xFFFFFFFF;
-
+	pt->should_be_ff = 0xffffffff;
 }
 
 void yaffs_unpack_tags1(struct yaffs_ext_tags *t,
 			const struct yaffs_packed_tags1 *pt)
 {
-	static const u8 all_ff[] =
-	    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-		0xff
-	};
 
 	if (memcmp(all_ff, pt, sizeof(struct yaffs_packed_tags1))) {
 		t->block_bad = 0;
-		if (pt->should_be_ff != 0xFFFFFFFF)
+		if (pt->should_be_ff != 0xffffffff)
 			t->block_bad = 1;
 		t->chunk_used = 1;
 		t->obj_id = pt->obj_id;
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_packedtags1.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_packedtags1.h
--- linux-3.1.9/fs/yaffs2/yaffs_packedtags1.h	2012-06-20 14:51:23.978803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_packedtags1.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_packedtags2.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_packedtags2.c
--- linux-3.1.9/fs/yaffs2/yaffs_packedtags2.c	2012-06-20 14:51:23.978803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_packedtags2.c	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -14,7 +14,6 @@
 #include "yaffs_packedtags2.h"
 #include "yportenv.h"
 #include "yaffs_trace.h"
-#include "yaffs_tagsvalidity.h"
 
 /* This code packs a set of extended tags into a binary structure for
  * NAND storage
@@ -32,14 +31,14 @@
 #define EXTRA_SHADOWS_FLAG	0x20000000
 #define EXTRA_SPARE_FLAGS	0x10000000
 
-#define ALL_EXTRA_FLAGS		0xF0000000
+#define ALL_EXTRA_FLAGS		0xf0000000
 
 /* Also, the top 4 bits of the object Id are set to the object type. */
 #define EXTRA_OBJECT_TYPE_SHIFT (28)
-#define EXTRA_OBJECT_TYPE_MASK  ((0x0F) << EXTRA_OBJECT_TYPE_SHIFT)
+#define EXTRA_OBJECT_TYPE_MASK  ((0x0f) << EXTRA_OBJECT_TYPE_SHIFT)
 
-static void yaffs_dump_packed_tags2_tags_only(const struct
-					      yaffs_packed_tags2_tags_only *ptt)
+static void yaffs_dump_packed_tags2_tags_only(
+				const struct yaffs_packed_tags2_tags_only *ptt)
 {
 	yaffs_trace(YAFFS_TRACE_MTD,
 		"packed tags obj %d chunk %d byte %d seq %d",
@@ -61,6 +60,18 @@
 
 }
 
+static int yaffs_check_tags_extra_packable(const struct yaffs_ext_tags *t)
+{
+	if (t->chunk_id != 0 || !t->extra_available)
+		return 0;
+
+	/* Check if the file size is too long to store */
+	if (t->extra_obj_type == YAFFS_OBJECT_TYPE_FILE &&
+	    (t->extra_file_size >> 31) != 0)
+		return 0;
+	return 1;
+}
+
 void yaffs_pack_tags2_tags_only(struct yaffs_packed_tags2_tags_only *ptt,
 				const struct yaffs_ext_tags *t)
 {
@@ -69,7 +80,11 @@
 	ptt->n_bytes = t->n_bytes;
 	ptt->obj_id = t->obj_id;
 
-	if (t->chunk_id == 0 && t->extra_available) {
+	/* Only store extra tags for object headers.
+	 * If it is a file then only store  if the file size is short\
+	 * enough to fit.
+	 */
+	if (yaffs_check_tags_extra_packable(t)) {
 		/* Store the extra header info instead */
 		/* We save the parent object in the chunk_id */
 		ptt->chunk_id = EXTRA_HEADER_INFO_FLAG | t->extra_parent_id;
@@ -84,7 +99,7 @@
 		if (t->extra_obj_type == YAFFS_OBJECT_TYPE_HARDLINK)
 			ptt->n_bytes = t->extra_equiv_id;
 		else if (t->extra_obj_type == YAFFS_OBJECT_TYPE_FILE)
-			ptt->n_bytes = t->extra_length;
+			ptt->n_bytes = (unsigned) t->extra_file_size;
 		else
 			ptt->n_bytes = 0;
 	}
@@ -100,20 +115,18 @@
 
 	if (tags_ecc)
 		yaffs_ecc_calc_other((unsigned char *)&pt->t,
-				     sizeof(struct
-					    yaffs_packed_tags2_tags_only),
+				    sizeof(struct yaffs_packed_tags2_tags_only),
 				     &pt->ecc);
 }
 
 void yaffs_unpack_tags2_tags_only(struct yaffs_ext_tags *t,
 				  struct yaffs_packed_tags2_tags_only *ptt)
 {
-
 	memset(t, 0, sizeof(struct yaffs_ext_tags));
 
-	yaffs_init_tags(t);
+	if (ptt->seq_number == 0xffffffff)
+		return;
 
-	if (ptt->seq_number != 0xFFFFFFFF) {
 		t->block_bad = 0;
 		t->chunk_used = 1;
 		t->obj_id = ptt->obj_id;
@@ -124,53 +137,42 @@
 		t->seq_number = ptt->seq_number;
 
 		/* Do extra header info stuff */
-
 		if (ptt->chunk_id & EXTRA_HEADER_INFO_FLAG) {
 			t->chunk_id = 0;
 			t->n_bytes = 0;
 
 			t->extra_available = 1;
-			t->extra_parent_id =
-			    ptt->chunk_id & (~(ALL_EXTRA_FLAGS));
-			t->extra_is_shrink =
-			    (ptt->chunk_id & EXTRA_SHRINK_FLAG) ? 1 : 0;
-			t->extra_shadows =
-			    (ptt->chunk_id & EXTRA_SHADOWS_FLAG) ? 1 : 0;
-			t->extra_obj_type =
-			    ptt->obj_id >> EXTRA_OBJECT_TYPE_SHIFT;
+		t->extra_parent_id = ptt->chunk_id & (~(ALL_EXTRA_FLAGS));
+		t->extra_is_shrink = ptt->chunk_id & EXTRA_SHRINK_FLAG ? 1 : 0;
+		t->extra_shadows = ptt->chunk_id & EXTRA_SHADOWS_FLAG ? 1 : 0;
+		t->extra_obj_type = ptt->obj_id >> EXTRA_OBJECT_TYPE_SHIFT;
 			t->obj_id &= ~EXTRA_OBJECT_TYPE_MASK;
 
 			if (t->extra_obj_type == YAFFS_OBJECT_TYPE_HARDLINK)
 				t->extra_equiv_id = ptt->n_bytes;
 			else
-				t->extra_length = ptt->n_bytes;
-		}
+			t->extra_file_size = ptt->n_bytes;
 	}
-
 	yaffs_dump_packed_tags2_tags_only(ptt);
 	yaffs_dump_tags2(t);
-
 }
 
 void yaffs_unpack_tags2(struct yaffs_ext_tags *t, struct yaffs_packed_tags2 *pt,
 			int tags_ecc)
 {
-
 	enum yaffs_ecc_result ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
 
-	if (pt->t.seq_number != 0xFFFFFFFF && tags_ecc) {
+	if (pt->t.seq_number != 0xffffffff && tags_ecc) {
 		/* Chunk is in use and we need to do ECC */
 
 		struct yaffs_ecc_other ecc;
 		int result;
 		yaffs_ecc_calc_other((unsigned char *)&pt->t,
-				     sizeof(struct
-					    yaffs_packed_tags2_tags_only),
+				sizeof(struct yaffs_packed_tags2_tags_only),
 				     &ecc);
 		result =
 		    yaffs_ecc_correct_other((unsigned char *)&pt->t,
-					    sizeof(struct
-						   yaffs_packed_tags2_tags_only),
+				sizeof(struct yaffs_packed_tags2_tags_only),
 					    &pt->ecc, &ecc);
 		switch (result) {
 		case 0:
@@ -186,7 +188,6 @@
 			ecc_result = YAFFS_ECC_RESULT_UNKNOWN;
 		}
 	}
-
 	yaffs_unpack_tags2_tags_only(t, &pt->t);
 
 	t->ecc_result = ecc_result;
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_packedtags2.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_packedtags2.h
--- linux-3.1.9/fs/yaffs2/yaffs_packedtags2.h	2012-06-20 14:51:23.978803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_packedtags2.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_summary.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_summary.c
--- linux-3.1.9/fs/yaffs2/yaffs_summary.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_summary.c	2012-06-28 16:54:39.719622577 -0600
@@ -0,0 +1,313 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Summaries write the useful part of the tags for the chunks in a block into an
+ * an array which is written to the last n chunks of the block.
+ * Reading the summaries gives all the tags for the block in one read. Much
+ * faster.
+ *
+ * Chunks holding summaries are marked with tags making it look like
+ * they are part of a fake file.
+ *
+ * The summary could also be used during gc.
+ *
+ */
+
+#include "yaffs_summary.h"
+#include "yaffs_packedtags2.h"
+#include "yaffs_nand.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_bitmap.h"
+
+/*
+ * The summary is built up in an array of summary tags.
+ * This gets written to the last one or two (maybe more) chunks in a block.
+ * A summary header is written as the first part of each chunk of summary data.
+ * The summary header must match or the summary is rejected.
+ */
+
+/* Summary tags don't need the sequence number because that is redundant. */
+struct yaffs_summary_tags {
+	unsigned obj_id;
+	unsigned chunk_id;
+	unsigned n_bytes;
+};
+
+/* Summary header */
+struct yaffs_summary_header {
+	unsigned version;	/* Must match current version */
+	unsigned block;		/* Must be this block */
+	unsigned seq;		/* Must be this sequence number */
+	unsigned sum;		/* Just add up all the bytes in the tags */
+};
+
+
+static void yaffs_summary_clear(struct yaffs_dev *dev)
+{
+	if (!dev->sum_tags)
+		return;
+	memset(dev->sum_tags, 0, dev->chunks_per_summary *
+		sizeof(struct yaffs_summary_tags));
+}
+
+
+void yaffs_summary_deinit(struct yaffs_dev *dev)
+{
+	kfree(dev->sum_tags);
+	dev->sum_tags = NULL;
+	kfree(dev->gc_sum_tags);
+	dev->gc_sum_tags = NULL;
+	dev->chunks_per_summary = 0;
+}
+
+int yaffs_summary_init(struct yaffs_dev *dev)
+{
+	int sum_bytes;
+	int chunks_used; /* Number of chunks used by summary */
+	int sum_tags_bytes;
+
+	sum_bytes = dev->param.chunks_per_block *
+			sizeof(struct yaffs_summary_tags);
+
+	chunks_used = (sum_bytes + dev->data_bytes_per_chunk - 1)/
+			(dev->data_bytes_per_chunk -
+				sizeof(struct yaffs_summary_header));
+
+	dev->chunks_per_summary = dev->param.chunks_per_block - chunks_used;
+	sum_tags_bytes = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	dev->sum_tags = kmalloc(sum_tags_bytes, GFP_NOFS);
+	dev->gc_sum_tags = kmalloc(sum_tags_bytes, GFP_NOFS);
+	if (!dev->sum_tags || !dev->gc_sum_tags) {
+		yaffs_summary_deinit(dev);
+		return YAFFS_FAIL;
+	}
+
+	yaffs_summary_clear(dev);
+
+	return YAFFS_OK;
+}
+
+static unsigned yaffs_summary_sum(struct yaffs_dev *dev)
+{
+	u8 *sum_buffer = (u8 *)dev->sum_tags;
+	int i;
+	unsigned sum = 0;
+
+	i = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	while (i > 0) {
+		sum += *sum_buffer;
+		sum_buffer++;
+		i--;
+	}
+
+	return sum;
+}
+
+static int yaffs_summary_write(struct yaffs_dev *dev, int blk)
+{
+	struct yaffs_ext_tags tags;
+	u8 *buffer;
+	u8 *sum_buffer = (u8 *)dev->sum_tags;
+	int n_bytes;
+	int chunk_in_nand;
+	int chunk_in_block;
+	int result;
+	int this_tx;
+	struct yaffs_summary_header hdr;
+	int sum_bytes_per_chunk = dev->data_bytes_per_chunk - sizeof(hdr);
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, blk);
+
+	buffer = yaffs_get_temp_buffer(dev);
+	n_bytes = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	memset(&tags, 0, sizeof(struct yaffs_ext_tags));
+	tags.obj_id = YAFFS_OBJECTID_SUMMARY;
+	tags.chunk_id = 1;
+	chunk_in_block = dev->chunks_per_summary;
+	chunk_in_nand = dev->alloc_block * dev->param.chunks_per_block +
+						dev->chunks_per_summary;
+	hdr.version = YAFFS_SUMMARY_VERSION;
+	hdr.block = blk;
+	hdr.seq = bi->seq_number;
+	hdr.sum = yaffs_summary_sum(dev);
+
+	do {
+		this_tx = n_bytes;
+		if (this_tx > sum_bytes_per_chunk)
+			this_tx = sum_bytes_per_chunk;
+		memcpy(buffer, &hdr, sizeof(hdr));
+		memcpy(buffer + sizeof(hdr), sum_buffer, this_tx);
+		tags.n_bytes = this_tx + sizeof(hdr);
+		result = yaffs_wr_chunk_tags_nand(dev, chunk_in_nand,
+						buffer, &tags);
+
+		if (result != YAFFS_OK)
+			break;
+		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+		bi->pages_in_use++;
+		dev->n_free_chunks--;
+
+		n_bytes -= this_tx;
+		sum_buffer += this_tx;
+		chunk_in_nand++;
+		chunk_in_block++;
+		tags.chunk_id++;
+	} while (result == YAFFS_OK && n_bytes > 0);
+	yaffs_release_temp_buffer(dev, buffer);
+
+
+	if (result == YAFFS_OK)
+		bi->has_summary = 1;
+
+
+	return result;
+}
+
+int yaffs_summary_read(struct yaffs_dev *dev,
+			struct yaffs_summary_tags *st,
+			int blk)
+{
+	struct yaffs_ext_tags tags;
+	u8 *buffer;
+	u8 *sum_buffer = (u8 *)st;
+	int n_bytes;
+	int chunk_id;
+	int chunk_in_nand;
+	int chunk_in_block;
+	int result;
+	int this_tx;
+	struct yaffs_summary_header hdr;
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, blk);
+	int sum_bytes_per_chunk = dev->data_bytes_per_chunk - sizeof(hdr);
+	int sum_tags_bytes;
+
+	sum_tags_bytes = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	buffer = yaffs_get_temp_buffer(dev);
+	n_bytes = sizeof(struct yaffs_summary_tags) * dev->chunks_per_summary;
+	chunk_in_block = dev->chunks_per_summary;
+	chunk_in_nand = blk * dev->param.chunks_per_block +
+							dev->chunks_per_summary;
+	chunk_id = 1;
+	do {
+		this_tx = n_bytes;
+		if (this_tx > sum_bytes_per_chunk)
+			this_tx = sum_bytes_per_chunk;
+		result = yaffs_rd_chunk_tags_nand(dev, chunk_in_nand,
+						buffer, &tags);
+
+		if (tags.chunk_id != chunk_id ||
+			tags.obj_id != YAFFS_OBJECTID_SUMMARY ||
+			tags.chunk_used == 0 ||
+			tags.ecc_result > YAFFS_ECC_RESULT_FIXED ||
+			tags.n_bytes != (this_tx + sizeof(hdr)))
+				result = YAFFS_FAIL;
+		if (result != YAFFS_OK)
+			break;
+
+		if (st == dev->sum_tags) {
+			/* If we're scanning then update the block info */
+			yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+			bi->pages_in_use++;
+		}
+		memcpy(&hdr, buffer, sizeof(hdr));
+		memcpy(sum_buffer, buffer + sizeof(hdr), this_tx);
+		n_bytes -= this_tx;
+		sum_buffer += this_tx;
+		chunk_in_nand++;
+		chunk_in_block++;
+		chunk_id++;
+	} while (result == YAFFS_OK && n_bytes > 0);
+	yaffs_release_temp_buffer(dev, buffer);
+
+	if (result == YAFFS_OK) {
+		/* Verify header */
+		if (hdr.version != YAFFS_SUMMARY_VERSION ||
+		    hdr.block != blk ||
+		    hdr.seq != bi->seq_number ||
+		    hdr.sum != yaffs_summary_sum(dev))
+			result = YAFFS_FAIL;
+	}
+
+	if (st == dev->sum_tags && result == YAFFS_OK)
+		bi->has_summary = 1;
+
+	return result;
+}
+
+int yaffs_summary_add(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_nand)
+{
+	struct yaffs_packed_tags2_tags_only tags_only;
+	struct yaffs_summary_tags *sum_tags;
+	int block_in_nand = chunk_in_nand / dev->param.chunks_per_block;
+	int chunk_in_block = chunk_in_nand % dev->param.chunks_per_block;
+
+	if (!dev->sum_tags)
+		return YAFFS_OK;
+
+	if (chunk_in_block >= 0 && chunk_in_block < dev->chunks_per_summary) {
+		yaffs_pack_tags2_tags_only(&tags_only, tags);
+		sum_tags = &dev->sum_tags[chunk_in_block];
+		sum_tags->chunk_id = tags_only.chunk_id;
+		sum_tags->n_bytes = tags_only.n_bytes;
+		sum_tags->obj_id = tags_only.obj_id;
+
+		if (chunk_in_block == dev->chunks_per_summary - 1) {
+			/* Time to write out the summary */
+			yaffs_summary_write(dev, block_in_nand);
+			yaffs_summary_clear(dev);
+			yaffs_skip_rest_of_block(dev);
+		}
+	}
+	return YAFFS_OK;
+}
+
+int yaffs_summary_fetch(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_block)
+{
+	struct yaffs_packed_tags2_tags_only tags_only;
+	struct yaffs_summary_tags *sum_tags;
+	if (chunk_in_block >= 0 && chunk_in_block < dev->chunks_per_summary) {
+		sum_tags = &dev->sum_tags[chunk_in_block];
+		tags_only.chunk_id = sum_tags->chunk_id;
+		tags_only.n_bytes = sum_tags->n_bytes;
+		tags_only.obj_id = sum_tags->obj_id;
+		yaffs_unpack_tags2_tags_only(tags, &tags_only);
+		return YAFFS_OK;
+	}
+	return YAFFS_FAIL;
+}
+
+void yaffs_summary_gc(struct yaffs_dev *dev, int blk)
+{
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, blk);
+	int i;
+
+	if (!bi->has_summary)
+		return;
+
+	for (i = dev->chunks_per_summary;
+	     i < dev->param.chunks_per_block;
+	     i++) {
+		if (yaffs_check_chunk_bit(dev, blk, i)) {
+			yaffs_clear_chunk_bit(dev, blk, i);
+			bi->pages_in_use--;
+			dev->n_free_chunks++;
+		}
+	}
+}
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_summary.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_summary.h
--- linux-3.1.9/fs/yaffs2/yaffs_summary.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_summary.h	2012-06-28 16:54:39.719622577 -0600
@@ -0,0 +1,37 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_SUMMARY_H__
+#define __YAFFS_SUMMARY_H__
+
+#include "yaffs_packedtags2.h"
+
+
+int yaffs_summary_init(struct yaffs_dev *dev);
+void yaffs_summary_deinit(struct yaffs_dev *dev);
+
+int yaffs_summary_add(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_block);
+int yaffs_summary_fetch(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_block);
+int yaffs_summary_read(struct yaffs_dev *dev,
+			struct yaffs_summary_tags *st,
+			int blk);
+void yaffs_summary_gc(struct yaffs_dev *dev, int blk);
+
+
+#endif
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_tagscompat.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_tagscompat.c
--- linux-3.1.9/fs/yaffs2/yaffs_tagscompat.c	2012-06-20 14:51:23.978803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_tagscompat.c	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -22,16 +22,15 @@
 
 /********** Tags ECC calculations  *********/
 
-void yaffs_calc_ecc(const u8 * data, struct yaffs_spare *spare)
+static void yaffs_calc_ecc(const u8 *data, struct yaffs_spare *spare)
 {
-	yaffs_ecc_cacl(data, spare->ecc1);
-	yaffs_ecc_cacl(&data[256], spare->ecc2);
+	yaffs_ecc_calc(data, spare->ecc1);
+	yaffs_ecc_calc(&data[256], spare->ecc2);
 }
 
 void yaffs_calc_tags_ecc(struct yaffs_tags *tags)
 {
 	/* Calculate an ecc */
-
 	unsigned char *b = ((union yaffs_tags_union *)tags)->as_bytes;
 	unsigned i, j;
 	unsigned ecc = 0;
@@ -46,9 +45,7 @@
 				ecc ^= bit;
 		}
 	}
-
 	tags->ecc = ecc;
-
 }
 
 int yaffs_check_tags_ecc(struct yaffs_tags *tags)
@@ -76,7 +73,6 @@
 		/* TODO Need to do somethiong here */
 		return -1;	/* unrecovered error */
 	}
-
 	return 0;
 }
 
@@ -124,11 +120,11 @@
 
 static void yaffs_spare_init(struct yaffs_spare *spare)
 {
-	memset(spare, 0xFF, sizeof(struct yaffs_spare));
+	memset(spare, 0xff, sizeof(struct yaffs_spare));
 }
 
 static int yaffs_wr_nand(struct yaffs_dev *dev,
-			 int nand_chunk, const u8 * data,
+			 int nand_chunk, const u8 *data,
 			 struct yaffs_spare *spare)
 {
 	if (nand_chunk < dev->param.start_block * dev->param.chunks_per_block) {
@@ -143,7 +139,7 @@
 
 static int yaffs_rd_chunk_nand(struct yaffs_dev *dev,
 			       int nand_chunk,
-			       u8 * data,
+			       u8 *data,
 			       struct yaffs_spare *spare,
 			       enum yaffs_ecc_result *ecc_result,
 			       int correct_errors)
@@ -151,7 +147,7 @@
 	int ret_val;
 	struct yaffs_spare local_spare;
 
-	if (!spare && data) {
+	if (!spare) {
 		/* If we don't have a real spare, then we use a local one. */
 		/* Need this for the calculation of the ecc */
 		spare = &local_spare;
@@ -166,10 +162,10 @@
 			int ecc_result1, ecc_result2;
 			u8 calc_ecc[3];
 
-			yaffs_ecc_cacl(data, calc_ecc);
+			yaffs_ecc_calc(data, calc_ecc);
 			ecc_result1 =
 			    yaffs_ecc_correct(data, spare->ecc1, calc_ecc);
-			yaffs_ecc_cacl(&data[256], calc_ecc);
+			yaffs_ecc_calc(&data[256], calc_ecc);
 			ecc_result2 =
 			    yaffs_ecc_correct(&data[256], spare->ecc2,
 					      calc_ecc);
@@ -268,9 +264,8 @@
 	int flash_block = nand_chunk / dev->param.chunks_per_block;
 
 	/* Mark the block for retirement */
-	yaffs_get_block_info(dev,
-			     flash_block + dev->block_offset)->needs_retiring =
-	    1;
+	yaffs_get_block_info(dev, flash_block + dev->block_offset)->
+		needs_retiring = 1;
 	yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
 		"**>>Block %d marked for retirement",
 		flash_block);
@@ -284,7 +279,7 @@
 
 int yaffs_tags_compat_wr(struct yaffs_dev *dev,
 			 int nand_chunk,
-			 const u8 * data, const struct yaffs_ext_tags *ext_tags)
+			 const u8 *data, const struct yaffs_ext_tags *ext_tags)
 {
 	struct yaffs_spare spare;
 	struct yaffs_tags tags;
@@ -297,7 +292,7 @@
 		tags.obj_id = ext_tags->obj_id;
 		tags.chunk_id = ext_tags->chunk_id;
 
-		tags.n_bytes_lsb = ext_tags->n_bytes & 0x3ff;
+		tags.n_bytes_lsb = ext_tags->n_bytes & (1024 - 1);
 
 		if (dev->data_bytes_per_chunk >= 1024)
 			tags.n_bytes_msb = (ext_tags->n_bytes >> 10) & 3;
@@ -310,69 +305,61 @@
 			yaffs_calc_ecc(data, &spare);
 
 		yaffs_load_tags_to_spare(&spare, &tags);
-
 	}
-
 	return yaffs_wr_nand(dev, nand_chunk, data, &spare);
 }
 
 int yaffs_tags_compat_rd(struct yaffs_dev *dev,
 			 int nand_chunk,
-			 u8 * data, struct yaffs_ext_tags *ext_tags)
+			 u8 *data, struct yaffs_ext_tags *ext_tags)
 {
-
 	struct yaffs_spare spare;
 	struct yaffs_tags tags;
 	enum yaffs_ecc_result ecc_result = YAFFS_ECC_RESULT_UNKNOWN;
-
 	static struct yaffs_spare spare_ff;
 	static int init;
+	int deleted;
 
 	if (!init) {
-		memset(&spare_ff, 0xFF, sizeof(spare_ff));
+		memset(&spare_ff, 0xff, sizeof(spare_ff));
 		init = 1;
 	}
 
-	if (yaffs_rd_chunk_nand(dev, nand_chunk, data, &spare, &ecc_result, 1)) {
+	if (!yaffs_rd_chunk_nand(dev, nand_chunk,
+					data, &spare, &ecc_result, 1))
+		return YAFFS_FAIL;
+
 		/* ext_tags may be NULL */
-		if (ext_tags) {
+	if (!ext_tags)
+		return YAFFS_OK;
 
-			int deleted =
-			    (hweight8(spare.page_status) < 7) ? 1 : 0;
+	deleted = (hweight8(spare.page_status) < 7) ? 1 : 0;
 
 			ext_tags->is_deleted = deleted;
 			ext_tags->ecc_result = ecc_result;
 			ext_tags->block_bad = 0;	/* We're reading it */
 			/* therefore it is not a bad block */
 			ext_tags->chunk_used =
-			    (memcmp(&spare_ff, &spare, sizeof(spare_ff)) !=
-			     0) ? 1 : 0;
+		memcmp(&spare_ff, &spare, sizeof(spare_ff)) ? 1 : 0;
 
 			if (ext_tags->chunk_used) {
 				yaffs_get_tags_from_spare(dev, &spare, &tags);
-
 				ext_tags->obj_id = tags.obj_id;
 				ext_tags->chunk_id = tags.chunk_id;
 				ext_tags->n_bytes = tags.n_bytes_lsb;
 
 				if (dev->data_bytes_per_chunk >= 1024)
 					ext_tags->n_bytes |=
-					    (((unsigned)tags.
-					      n_bytes_msb) << 10);
+				(((unsigned)tags.n_bytes_msb) << 10);
 
 				ext_tags->serial_number = tags.serial_number;
 			}
-		}
 
 		return YAFFS_OK;
-	} else {
-		return YAFFS_FAIL;
-	}
 }
 
 int yaffs_tags_compat_mark_bad(struct yaffs_dev *dev, int flash_block)
 {
-
 	struct yaffs_spare spare;
 
 	memset(&spare, 0xff, sizeof(struct yaffs_spare));
@@ -385,22 +372,20 @@
 		      NULL, &spare);
 
 	return YAFFS_OK;
-
 }
 
 int yaffs_tags_compat_query_block(struct yaffs_dev *dev,
 				  int block_no,
 				  enum yaffs_block_state *state,
-				  u32 * seq_number)
+				  u32 *seq_number)
 {
-
 	struct yaffs_spare spare0, spare1;
 	static struct yaffs_spare spare_ff;
 	static int init;
 	enum yaffs_ecc_result dummy;
 
 	if (!init) {
-		memset(&spare_ff, 0xFF, sizeof(spare_ff));
+		memset(&spare_ff, 0xff, sizeof(spare_ff));
 		init = 1;
 	}
 
@@ -416,7 +401,7 @@
 	else if (memcmp(&spare_ff, &spare0, sizeof(spare_ff)) == 0)
 		*state = YAFFS_BLOCK_STATE_EMPTY;
 	else
-		*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;
+		*state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
 
 	return YAFFS_OK;
 }
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_tagscompat.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_tagscompat.h
--- linux-3.1.9/fs/yaffs2/yaffs_tagscompat.h	2012-06-20 14:51:23.978803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_tagscompat.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -19,15 +19,15 @@
 #include "yaffs_guts.h"
 int yaffs_tags_compat_wr(struct yaffs_dev *dev,
 			 int nand_chunk,
-			 const u8 * data, const struct yaffs_ext_tags *tags);
+			 const u8 *data, const struct yaffs_ext_tags *tags);
 int yaffs_tags_compat_rd(struct yaffs_dev *dev,
 			 int nand_chunk,
-			 u8 * data, struct yaffs_ext_tags *tags);
+			 u8 *data, struct yaffs_ext_tags *tags);
 int yaffs_tags_compat_mark_bad(struct yaffs_dev *dev, int block_no);
 int yaffs_tags_compat_query_block(struct yaffs_dev *dev,
 				  int block_no,
 				  enum yaffs_block_state *state,
-				  u32 * seq_number);
+				  u32 *seq_number);
 
 void yaffs_calc_tags_ecc(struct yaffs_tags *tags);
 int yaffs_check_tags_ecc(struct yaffs_tags *tags);
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_tagsvalidity.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_tagsvalidity.c
--- linux-3.1.9/fs/yaffs2/yaffs_tagsvalidity.c	2012-06-20 14:51:23.978803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_tagsvalidity.c	1969-12-31 17:00:00.000000000 -0700
@@ -1,27 +0,0 @@
-/*
- * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
- *
- * Copyright (C) 2002-2010 Aleph One Ltd.
- *   for Toby Churchill Ltd and Brightstar Engineering
- *
- * Created by Charles Manning <charles@aleph1.co.uk>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include "yaffs_tagsvalidity.h"
-
-void yaffs_init_tags(struct yaffs_ext_tags *tags)
-{
-	memset(tags, 0, sizeof(struct yaffs_ext_tags));
-	tags->validity0 = 0xAAAAAAAA;
-	tags->validity1 = 0x55555555;
-}
-
-int yaffs_validate_tags(struct yaffs_ext_tags *tags)
-{
-	return (tags->validity0 == 0xAAAAAAAA && tags->validity1 == 0x55555555);
-
-}
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_tagsvalidity.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_tagsvalidity.h
--- linux-3.1.9/fs/yaffs2/yaffs_tagsvalidity.h	2012-06-20 14:51:23.978803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_tagsvalidity.h	1969-12-31 17:00:00.000000000 -0700
@@ -1,23 +0,0 @@
-/*
- * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
- *
- * Copyright (C) 2002-2010 Aleph One Ltd.
- *   for Toby Churchill Ltd and Brightstar Engineering
- *
- * Created by Charles Manning <charles@aleph1.co.uk>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 2.1 as
- * published by the Free Software Foundation.
- *
- * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
- */
-
-#ifndef __YAFFS_TAGS_VALIDITY_H__
-#define __YAFFS_TAGS_VALIDITY_H__
-
-#include "yaffs_guts.h"
-
-void yaffs_init_tags(struct yaffs_ext_tags *tags);
-int yaffs_validate_tags(struct yaffs_ext_tags *tags);
-#endif
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_trace.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_trace.h
--- linux-3.1.9/fs/yaffs2/yaffs_trace.h	2012-06-20 14:51:23.978803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_trace.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -43,7 +43,7 @@
 #define YAFFS_TRACE_VERIFY		0x00010000
 #define YAFFS_TRACE_VERIFY_NAND		0x00020000
 #define YAFFS_TRACE_VERIFY_FULL		0x00040000
-#define YAFFS_TRACE_VERIFY_ALL		0x000F0000
+#define YAFFS_TRACE_VERIFY_ALL		0x000f0000
 
 #define YAFFS_TRACE_SYNC		0x00100000
 #define YAFFS_TRACE_BACKGROUND		0x00200000
@@ -52,6 +52,6 @@
 
 #define YAFFS_TRACE_ERROR		0x40000000
 #define YAFFS_TRACE_BUG			0x80000000
-#define YAFFS_TRACE_ALWAYS		0xF0000000
+#define YAFFS_TRACE_ALWAYS		0xf0000000
 
 #endif
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_verify.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_verify.c
--- linux-3.1.9/fs/yaffs2/yaffs_verify.c	2012-06-20 14:51:23.978803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_verify.c	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -19,26 +19,26 @@
 
 int yaffs_skip_verification(struct yaffs_dev *dev)
 {
-	dev = dev;
+	(void) dev;
 	return !(yaffs_trace_mask &
 		 (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));
 }
 
 static int yaffs_skip_full_verification(struct yaffs_dev *dev)
 {
-	dev = dev;
+	(void) dev;
 	return !(yaffs_trace_mask & (YAFFS_TRACE_VERIFY_FULL));
 }
 
 static int yaffs_skip_nand_verification(struct yaffs_dev *dev)
 {
-	dev = dev;
+	(void) dev;
 	return !(yaffs_trace_mask & (YAFFS_TRACE_VERIFY_NAND));
 }
 
-static const char *block_state_name[] = {
+static const char * const block_state_name[] = {
 	"Unknown",
-	"Needs scanning",
+	"Needs scan",
 	"Scanning",
 	"Empty",
 	"Allocating",
@@ -66,7 +66,7 @@
 	switch (bi->block_state) {
 	case YAFFS_BLOCK_STATE_UNKNOWN:
 	case YAFFS_BLOCK_STATE_SCANNING:
-	case YAFFS_BLOCK_STATE_NEEDS_SCANNING:
+	case YAFFS_BLOCK_STATE_NEEDS_SCAN:
 		yaffs_trace(YAFFS_TRACE_VERIFY,
 			"Block %d has bad run-state %s",
 			n, block_state_name[bi->block_state]);
@@ -76,11 +76,11 @@
 
 	actually_used = bi->pages_in_use - bi->soft_del_pages;
 
-	if (bi->pages_in_use < 0
-	    || bi->pages_in_use > dev->param.chunks_per_block
-	    || bi->soft_del_pages < 0
-	    || bi->soft_del_pages > dev->param.chunks_per_block
-	    || actually_used < 0 || actually_used > dev->param.chunks_per_block)
+	if (bi->pages_in_use < 0 ||
+	    bi->pages_in_use > dev->param.chunks_per_block ||
+	    bi->soft_del_pages < 0 ||
+	    bi->soft_del_pages > dev->param.chunks_per_block ||
+	    actually_used < 0 || actually_used > dev->param.chunks_per_block)
 		yaffs_trace(YAFFS_TRACE_VERIFY,
 			"Block %d has illegal values pages_in_used %d soft_del_pages %d",
 			n, bi->pages_in_use, bi->soft_del_pages);
@@ -91,7 +91,6 @@
 		yaffs_trace(YAFFS_TRACE_VERIFY,
 			"Block %d has inconsistent values pages_in_use %d counted chunk bits %d",
 			n, bi->pages_in_use, in_use);
-
 }
 
 void yaffs_verify_collected_blk(struct yaffs_dev *dev,
@@ -163,8 +162,8 @@
 }
 
 /*
- * Verify the object header. oh must be valid, but obj and tags may be NULL in which
- * case those tests will not be performed.
+ * Verify the object header. oh must be valid, but obj and tags may be NULL in
+ * which case those tests will not be performed.
  */
 void yaffs_verify_oh(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh,
 		     struct yaffs_ext_tags *tags, int parent_check)
@@ -215,18 +214,21 @@
 			"Obj %d header name is NULL",
 			obj->obj_id);
 
-	if (tags->obj_id > 1 && ((u8) (oh->name[0])) == 0xff)	/* Trashed name */
+	if (tags->obj_id > 1 && ((u8) (oh->name[0])) == 0xff)	/* Junk name */
 		yaffs_trace(YAFFS_TRACE_VERIFY,
-			"Obj %d header name is 0xFF",
+			"Obj %d header name is 0xff",
 			obj->obj_id);
 }
 
 void yaffs_verify_file(struct yaffs_obj *obj)
 {
+	u32 x;
 	int required_depth;
 	int actual_depth;
-	u32 last_chunk;
-	u32 x;
+	int last_chunk;
+	u32 offset_in_chunk;
+	u32 the_chunk;
+
 	u32 i;
 	struct yaffs_dev *dev;
 	struct yaffs_ext_tags tags;
@@ -242,9 +244,11 @@
 	dev = obj->my_dev;
 	obj_id = obj->obj_id;
 
+
 	/* Check file size is consistent with tnode depth */
-	last_chunk =
-	    obj->variant.file_variant.file_size / dev->data_bytes_per_chunk + 1;
+	yaffs_addr_to_chunk(dev, obj->variant.file_variant.file_size,
+				&last_chunk, &offset_in_chunk);
+	last_chunk++;
 	x = last_chunk >> YAFFS_TNODES_LEVEL0_BITS;
 	required_depth = 0;
 	while (x > 0) {
@@ -265,8 +269,10 @@
 	for (i = 1; i <= last_chunk; i++) {
 		tn = yaffs_find_tnode_0(dev, &obj->variant.file_variant, i);
 
-		if (tn) {
-			u32 the_chunk = yaffs_get_group_base(dev, tn, i);
+		if (!tn)
+			continue;
+
+		the_chunk = yaffs_get_group_base(dev, tn, i);
 			if (the_chunk > 0) {
 				yaffs_rd_chunk_tags_nand(dev, the_chunk, NULL,
 							 &tags);
@@ -277,7 +283,6 @@
 					 tags.obj_id, tags.chunk_id);
 			}
 		}
-	}
 }
 
 void yaffs_verify_link(struct yaffs_obj *obj)
@@ -305,10 +310,8 @@
 void yaffs_verify_obj(struct yaffs_obj *obj)
 {
 	struct yaffs_dev *dev;
-
 	u32 chunk_min;
 	u32 chunk_max;
-
 	u32 chunk_id_ok;
 	u32 chunk_in_range;
 	u32 chunk_wrongly_deleted;
@@ -350,7 +353,7 @@
 	if (chunk_valid && !yaffs_skip_nand_verification(dev)) {
 		struct yaffs_ext_tags tags;
 		struct yaffs_obj_hdr *oh;
-		u8 *buffer = yaffs_get_temp_buffer(dev, __LINE__);
+		u8 *buffer = yaffs_get_temp_buffer(dev);
 
 		oh = (struct yaffs_obj_hdr *)buffer;
 
@@ -358,7 +361,7 @@
 
 		yaffs_verify_oh(obj, oh, &tags, 1);
 
-		yaffs_release_temp_buffer(dev, buffer, __LINE__);
+		yaffs_release_temp_buffer(dev, buffer);
 	}
 
 	/* Verify it has a parent */
@@ -369,8 +372,8 @@
 	}
 
 	/* Verify parent is a directory */
-	if (obj->parent
-	    && obj->parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+	if (obj->parent &&
+	    obj->parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
 		yaffs_trace(YAFFS_TRACE_VERIFY,
 			"Obj %d's parent is not a directory (type %d)",
 			obj->obj_id, obj->parent->variant_type);
@@ -414,25 +417,21 @@
 
 	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
 		list_for_each(lh, &dev->obj_bucket[i].list) {
-			if (lh) {
-				obj =
-				    list_entry(lh, struct yaffs_obj, hash_link);
+			obj = list_entry(lh, struct yaffs_obj, hash_link);
 				yaffs_verify_obj(obj);
 			}
 		}
-	}
 }
 
 void yaffs_verify_obj_in_dir(struct yaffs_obj *obj)
 {
 	struct list_head *lh;
 	struct yaffs_obj *list_obj;
-
 	int count = 0;
 
 	if (!obj) {
 		yaffs_trace(YAFFS_TRACE_ALWAYS, "No object to verify");
-		YBUG();
+		BUG();
 		return;
 	}
 
@@ -440,32 +439,30 @@
 		return;
 
 	if (!obj->parent) {
-		yaffs_trace(YAFFS_TRACE_ALWAYS, "Object does not have parent" );
-		YBUG();
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "Object does not have parent");
+		BUG();
 		return;
 	}
 
 	if (obj->parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
 		yaffs_trace(YAFFS_TRACE_ALWAYS, "Parent is not directory");
-		YBUG();
+		BUG();
 	}
 
 	/* Iterate through the objects in each hash entry */
 
 	list_for_each(lh, &obj->parent->variant.dir_variant.children) {
-		if (lh) {
 			list_obj = list_entry(lh, struct yaffs_obj, siblings);
 			yaffs_verify_obj(list_obj);
 			if (obj == list_obj)
 				count++;
 		}
-	}
 
 	if (count != 1) {
 		yaffs_trace(YAFFS_TRACE_ALWAYS,
 			"Object in directory %d times",
 			count);
-		YBUG();
+		BUG();
 	}
 }
 
@@ -475,7 +472,7 @@
 	struct yaffs_obj *list_obj;
 
 	if (!directory) {
-		YBUG();
+		BUG();
 		return;
 	}
 
@@ -486,23 +483,21 @@
 		yaffs_trace(YAFFS_TRACE_ALWAYS,
 			"Directory has wrong type: %d",
 			directory->variant_type);
-		YBUG();
+		BUG();
 	}
 
 	/* Iterate through the objects in each hash entry */
 
 	list_for_each(lh, &directory->variant.dir_variant.children) {
-		if (lh) {
 			list_obj = list_entry(lh, struct yaffs_obj, siblings);
 			if (list_obj->parent != directory) {
 				yaffs_trace(YAFFS_TRACE_ALWAYS,
 					"Object in directory list has wrong parent %p",
 					list_obj->parent);
-				YBUG();
+			BUG();
 			}
 			yaffs_verify_obj_in_dir(list_obj);
 		}
-	}
 }
 
 static int yaffs_free_verification_failures;
@@ -529,7 +524,6 @@
 
 int yaffs_verify_file_sane(struct yaffs_obj *in)
 {
-	in = in;
+	(void) in;
 	return YAFFS_OK;
 }
-
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_verify.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_verify.h
--- linux-3.1.9/fs/yaffs2/yaffs_verify.h	2012-06-20 14:51:23.978803634 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_verify.h	2012-06-28 16:54:39.719622577 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_vfs.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_vfs.c
--- linux-3.1.9/fs/yaffs2/yaffs_vfs.c	2012-06-20 14:51:23.982803635 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_vfs.c	2012-06-28 17:13:59.343665621 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -32,51 +32,138 @@
  */
 
 /*
- * NB There are two variants of Linux VFS glue code. This variant supports
- * a single version and should not include any multi-version code.
+ * There are two variants of the VFS glue code. This variant should compile
+ * for any version of Linux.
  */
 #include <linux/version.h>
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 10))
+#define YAFFS_COMPILE_BACKGROUND
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23))
+#define YAFFS_COMPILE_FREEZER
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28))
+#define YAFFS_COMPILE_EXPORTFS
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#define YAFFS_USE_SETATTR_COPY
+#define YAFFS_USE_TRUNCATE_SETSIZE
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#define YAFFS_HAS_EVICT_INODE
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+#define YAFFS_NEW_FOLLOW_LINK 1
+#else
+#define YAFFS_NEW_FOLLOW_LINK 0
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/fs.h>
 #include <linux/proc_fs.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 39))
 #include <linux/smp_lock.h>
+#endif
 #include <linux/pagemap.h>
 #include <linux/mtd/mtd.h>
 #include <linux/interrupt.h>
 #include <linux/string.h>
 #include <linux/ctype.h>
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
 #include <linux/namei.h>
+#endif
+
+#ifdef YAFFS_COMPILE_EXPORTFS
 #include <linux/exportfs.h>
+#endif
+
+#ifdef YAFFS_COMPILE_BACKGROUND
 #include <linux/kthread.h>
 #include <linux/delay.h>
+#endif
+#ifdef YAFFS_COMPILE_FREEZER
 #include <linux/freezer.h>
+#endif
 
 #include <asm/div64.h>
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
 #include <linux/statfs.h>
 
 #define UnlockPage(p) unlock_page(p)
 #define Page_Uptodate(page)	test_bit(PG_uptodate, &(page)->flags)
 
+/* FIXME: use sb->s_id instead ? */
 #define yaffs_devname(sb, buf)	bdevname(sb->s_bdev, buf)
 
+#else
+
+#include <linux/locks.h>
+#define	BDEVNAME_SIZE		0
+#define	yaffs_devname(sb, buf)	kdevname(sb->s_dev)
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0))
+/* added NCB 26/5/2006 for 2.4.25-vrs2-tcl1 kernel */
+#define __user
+#endif
+
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define YPROC_ROOT  (&proc_root)
+#else
 #define YPROC_ROOT  NULL
+#endif
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define Y_INIT_TIMER(a)	init_timer(a)
+#else
 #define Y_INIT_TIMER(a)	init_timer_on_stack(a)
+#endif
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
 #define WRITE_SIZE_STR "writesize"
 #define WRITE_SIZE(mtd) ((mtd)->writesize)
+#else
+#define WRITE_SIZE_STR "oobblock"
+#define WRITE_SIZE(mtd) ((mtd)->oobblock)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27))
+#define YAFFS_USE_WRITE_BEGIN_END 1
+#else
+#define YAFFS_USE_WRITE_BEGIN_END 0
+#endif
+
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
+#define set_nlink(inode, count)  do { (inode)->i_nlink = (count); } while(0)
+#endif
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 28))
 static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
 {
 	uint64_t result = partition_size;
 	do_div(result, block_size);
 	return (uint32_t) result;
 }
+#else
+#define YCALCBLOCKS(s, b) ((s)/(b))
+#endif
 
 #include <linux/uaccess.h>
 #include <linux/mtd/mtd.h>
@@ -97,702 +184,1321 @@
 unsigned int yaffs_auto_checkpoint = 1;
 unsigned int yaffs_gc_control = 1;
 unsigned int yaffs_bg_enable = 1;
-
+unsigned int yaffs_auto_select = 1;
 /* Module Parameters */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
 module_param(yaffs_trace_mask, uint, 0644);
 module_param(yaffs_wr_attempts, uint, 0644);
 module_param(yaffs_auto_checkpoint, uint, 0644);
 module_param(yaffs_gc_control, uint, 0644);
 module_param(yaffs_bg_enable, uint, 0644);
+#else
+MODULE_PARM(yaffs_trace_mask, "i");
+MODULE_PARM(yaffs_wr_attempts, "i");
+MODULE_PARM(yaffs_auto_checkpoint, "i");
+MODULE_PARM(yaffs_gc_control, "i");
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+/* use iget and read_inode */
+#define Y_IGET(sb, inum) iget((sb), (inum))
+static void yaffs_read_inode(struct inode *inode);
+
+#else
+/* Call local equivalent */
+#define YAFFS_USE_OWN_IGET
+#define Y_IGET(sb, inum) yaffs_iget((sb), (inum))
 
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino);
+#endif
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
 #define yaffs_inode_to_obj_lv(iptr) ((iptr)->i_private)
-#define yaffs_inode_to_obj(iptr) ((struct yaffs_obj *)(yaffs_inode_to_obj_lv(iptr)))
+#else
+#define yaffs_inode_to_obj_lv(iptr) ((iptr)->u.generic_ip)
+#endif
+
+#define yaffs_inode_to_obj(iptr) \
+	((struct yaffs_obj *)(yaffs_inode_to_obj_lv(iptr)))
 #define yaffs_dentry_to_obj(dptr) yaffs_inode_to_obj((dptr)->d_inode)
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
 #define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->s_fs_info)
+#else
+#define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->u.generic_sbp)
+#endif
 
 #define update_dir_time(dir) do {\
 			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
-		} while(0)
+		} while (0)
 
+static void yaffs_put_super(struct super_block *sb);
 
-static unsigned yaffs_gc_control_callback(struct yaffs_dev *dev)
-{
-	return yaffs_gc_control;
-}
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t *pos);
+static ssize_t yaffs_hold_space(struct file *f);
+static void yaffs_release_space(struct file *f);
 
-static void yaffs_gross_lock(struct yaffs_dev *dev)
-{
-	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locking %p", current);
-	mutex_lock(&(yaffs_dev_to_lc(dev)->gross_lock));
-	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locked %p", current);
-}
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id);
+#else
+static int yaffs_file_flush(struct file *file);
+#endif
 
-static void yaffs_gross_unlock(struct yaffs_dev *dev)
-{
-	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs unlocking %p", current);
-	mutex_unlock(&(yaffs_dev_to_lc(dev)->gross_lock));
-}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static int yaffs_sync_object(struct file *file, loff_t start, loff_t end, int datasync);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+static int yaffs_sync_object(struct file *file, int datasync);
+#else
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+			     int datasync);
+#endif
 
-static void yaffs_fill_inode_from_obj(struct inode *inode,
-				      struct yaffs_obj *obj);
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir);
 
-static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino)
-{
-	struct inode *inode;
-	struct yaffs_obj *obj;
-	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n);
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *n);
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode);
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry);
+#endif
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+		      struct dentry *dentry);
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry);
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			 const char *symname);
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode);
 
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_iget for %lu", ino);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       dev_t dev);
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       int dev);
+#endif
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry);
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr);
 
-	inode = iget_locked(sb, ino);
-	if (!inode)
-		return ERR_PTR(-ENOMEM);
-	if (!(inode->i_state & I_NEW))
-		return inode;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_sync_fs(struct super_block *sb, int wait);
+static void yaffs_write_super(struct super_block *sb);
+#else
+static int yaffs_sync_fs(struct super_block *sb);
+static int yaffs_write_super(struct super_block *sb);
+#endif
 
-	/* NB This is called as a side effect of other functions, but
-	 * we had to release the lock to prevent deadlocks, so
-	 * need to lock again.
-	 */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf);
+#endif
 
-	yaffs_gross_lock(dev);
+#ifdef YAFFS_HAS_PUT_INODE
+static void yaffs_put_inode(struct inode *inode);
+#endif
 
-	obj = yaffs_find_by_number(dev, inode->i_ino);
+#ifdef YAFFS_HAS_EVICT_INODE
+static void yaffs_evict_inode(struct inode *);
+#else
+static void yaffs_delete_inode(struct inode *);
+static void yaffs_clear_inode(struct inode *);
+#endif
 
-	yaffs_fill_inode_from_obj(inode, obj);
+static int yaffs_readpage(struct file *file, struct page *page);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc);
+#else
+static int yaffs_writepage(struct page *page);
+#endif
 
-	yaffs_gross_unlock(dev);
+static int yaffs_setxattr(struct dentry *dentry, const char *name,
+		   const void *value, size_t size, int flags);
+static ssize_t yaffs_getxattr(struct dentry *dentry, const char *name,
+				void *buff, size_t size);
+static int yaffs_removexattr(struct dentry *dentry, const char *name);
+static ssize_t yaffs_listxattr(struct dentry *dentry, char *buff, size_t size);
 
-	unlock_new_inode(inode);
-	return inode;
-}
+#if (YAFFS_USE_WRITE_BEGIN_END != 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+			     loff_t pos, unsigned len, unsigned flags,
+			     struct page **pagep, void **fsdata);
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata);
+#else
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+			       unsigned offset, unsigned to);
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+			      unsigned to);
 
-struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
-			      struct yaffs_obj *obj)
-{
-	struct inode *inode;
+#endif
 
-	if (!sb) {
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_get_inode for NULL super_block!!");
-		return NULL;
+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
+			  int buflen);
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias);
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+#endif
 
-	}
+static void yaffs_touch_super(struct yaffs_dev *dev);
 
-	if (!obj) {
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_get_inode for NULL object!!");
-		return NULL;
+static int yaffs_vfs_setattr(struct inode *, struct iattr *);
 
-	}
+static struct address_space_operations yaffs_file_address_operations = {
+	.readpage = yaffs_readpage,
+	.writepage = yaffs_writepage,
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+	.write_begin = yaffs_write_begin,
+	.write_end = yaffs_write_end,
+#else
+	.prepare_write = yaffs_prepare_write,
+	.commit_write = yaffs_commit_write,
+#endif
+};
 
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_get_inode for object %d",
-		obj->obj_id);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.splice_read = generic_file_splice_read,
+	.splice_write = generic_file_splice_write,
+	.llseek = generic_file_llseek,
+};
 
-	inode = yaffs_iget(sb, obj->obj_id);
-	if (IS_ERR(inode))
-		return NULL;
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
 
-	/* NB Side effect: iget calls back to yaffs_read_inode(). */
-	/* iget also increments the inode's i_count */
-	/* NB You can't be holding gross_lock or deadlock will happen! */
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.sendfile = generic_file_sendfile,
+};
 
-	return inode;
-}
+#else
 
-static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
-		       dev_t rdev)
+static const struct file_operations yaffs_file_operations = {
+	.read = generic_file_read,
+	.write = generic_file_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	.sendfile = generic_file_sendfile,
+#endif
+};
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+static void zero_user_segment(struct page *page, unsigned start, unsigned end)
 {
-	struct inode *inode;
+	void *kaddr = kmap_atomic(page, KM_USER0);
+	memset(kaddr + start, 0, end - start);
+	kunmap_atomic(kaddr, KM_USER0);
+	flush_dcache_page(page);
+}
+#endif
 
-	struct yaffs_obj *obj = NULL;
-	struct yaffs_dev *dev;
+static const struct inode_operations yaffs_file_inode_operations = {
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
 
-	struct yaffs_obj *parent = yaffs_inode_to_obj(dir);
+static const struct inode_operations yaffs_symlink_inode_operations = {
+	.readlink = yaffs_readlink,
+	.follow_link = yaffs_follow_link,
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+	.put_link = yaffs_put_link,
+#endif
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
 
-	int error = -ENOSPC;
-	uid_t uid = current->cred->fsuid;
-	gid_t gid =
-	    (dir->i_mode & S_ISGID) ? dir->i_gid : current->cred->fsgid;
+static const struct inode_operations yaffs_dir_inode_operations = {
+	.create = yaffs_create,
+	.lookup = yaffs_lookup,
+	.link = yaffs_link,
+	.unlink = yaffs_unlink,
+	.symlink = yaffs_symlink,
+	.mkdir = yaffs_mkdir,
+	.rmdir = yaffs_unlink,
+	.mknod = yaffs_mknod,
+	.rename = yaffs_rename,
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
 
-	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
-		mode |= S_ISGID;
+static const struct file_operations yaffs_dir_operations = {
+	.read = generic_read_dir,
+	.readdir = yaffs_readdir,
+	.fsync = yaffs_sync_object,
+	.llseek = generic_file_llseek,
+};
 
-	if (parent) {
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_mknod: parent object %d type %d",
-			parent->obj_id, parent->variant_type);
-	} else {
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_mknod: could not get parent object");
-		return -EPERM;
-	}
+static const struct super_operations yaffs_super_ops = {
+	.statfs = yaffs_statfs,
 
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_mknod: making oject for %s, mode %x dev %x",
-		dentry->d_name.name, mode, rdev);
+#ifndef YAFFS_USE_OWN_IGET
+	.read_inode = yaffs_read_inode,
+#endif
+#ifdef YAFFS_HAS_PUT_INODE
+	.put_inode = yaffs_put_inode,
+#endif
+	.put_super = yaffs_put_super,
+#ifdef YAFFS_HAS_EVICT_INODE
+	.evict_inode = yaffs_evict_inode,
+#else
+	.delete_inode = yaffs_delete_inode,
+	.clear_inode = yaffs_clear_inode,
+#endif
+	.sync_fs = yaffs_sync_fs,
+	.write_super = yaffs_write_super,
+};
 
-	dev = parent->my_dev;
+static int yaffs_vfs_setattr(struct inode *inode, struct iattr *attr)
+{
+#ifdef YAFFS_USE_SETATTR_COPY
+	setattr_copy(inode, attr);
+	return 0;
+#else
+	return inode_setattr(inode, attr);
+#endif
+
+}
+
+static int yaffs_vfs_setsize(struct inode *inode, loff_t newsize)
+{
+#ifdef YAFFS_USE_TRUNCATE_SETSIZE
+	truncate_setsize(inode, newsize);
+	return 0;
+#else
+	truncate_inode_pages(&inode->i_data, newsize);
+	return 0;
+#endif
+
+}
+
+static unsigned yaffs_gc_control_callback(struct yaffs_dev *dev)
+{
+	return yaffs_gc_control;
+}
+
+static void yaffs_gross_lock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locking %p", current);
+	mutex_lock(&(yaffs_dev_to_lc(dev)->gross_lock));
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locked %p", current);
+}
+
+static void yaffs_gross_unlock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs unlocking %p", current);
+	mutex_unlock(&(yaffs_dev_to_lc(dev)->gross_lock));
+}
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+
+static struct inode *yaffs2_nfs_get_inode(struct super_block *sb, uint64_t ino,
+					  uint32_t generation)
+{
+	return Y_IGET(sb, ino);
+}
+
+static struct dentry *yaffs2_fh_to_dentry(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+static struct dentry *yaffs2_fh_to_parent(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+struct dentry *yaffs2_get_parent(struct dentry *dentry)
+{
+
+	struct super_block *sb = dentry->d_inode->i_sb;
+	struct dentry *parent = ERR_PTR(-ENOENT);
+	struct inode *inode;
+	unsigned long parent_ino;
+	struct yaffs_obj *d_obj;
+	struct yaffs_obj *parent_obj;
+
+	d_obj = yaffs_inode_to_obj(dentry->d_inode);
+
+	if (d_obj) {
+		parent_obj = d_obj->parent;
+		if (parent_obj) {
+			parent_ino = yaffs_get_obj_inode(parent_obj);
+			inode = Y_IGET(sb, parent_ino);
+
+			if (IS_ERR(inode)) {
+				parent = ERR_CAST(inode);
+			} else {
+				parent = d_obtain_alias(inode);
+				if (!IS_ERR(parent)) {
+					parent = ERR_PTR(-ENOMEM);
+					iput(inode);
+				}
+			}
+		}
+	}
+
+	return parent;
+}
+
+/* Just declare a zero structure as a NULL value implies
+ * using the default functions of exportfs.
+ */
+
+static struct export_operations yaffs_export_ops = {
+	.fh_to_dentry = yaffs2_fh_to_dentry,
+	.fh_to_parent = yaffs2_fh_to_parent,
+	.get_parent = yaffs2_get_parent,
+};
+
+#endif
+
+/*-----------------------------------------------------------------*/
+/* Directory search context allows us to unlock access to yaffs during
+ * filldir without causing problems with the directory being modified.
+ * This is similar to the tried and tested mechanism used in yaffs direct.
+ *
+ * A search context iterates along a doubly linked list of siblings in the
+ * directory. If the iterating object is deleted then this would corrupt
+ * the list iteration, likely causing a crash. The search context avoids
+ * this by using the remove_obj_fn to move the search context to the
+ * next object before the object is deleted.
+ *
+ * Many readdirs (and thus seach conexts) may be alive simulateously so
+ * each struct yaffs_dev has a list of these.
+ *
+ * A seach context lives for the duration of a readdir.
+ *
+ * All these functions must be called while yaffs is locked.
+ */
+
+struct yaffs_search_context {
+	struct yaffs_dev *dev;
+	struct yaffs_obj *dir_obj;
+	struct yaffs_obj *next_return;
+	struct list_head others;
+};
+
+/*
+ * yaffs_new_search() creates a new search context, initialises it and
+ * adds it to the device's search context list.
+ *
+ * Called at start of readdir.
+ */
+static struct yaffs_search_context *yaffs_new_search(struct yaffs_obj *dir)
+{
+	struct yaffs_dev *dev = dir->my_dev;
+	struct yaffs_search_context *sc =
+	    kmalloc(sizeof(struct yaffs_search_context), GFP_NOFS);
+	if (sc) {
+		sc->dir_obj = dir;
+		sc->dev = dev;
+		if (list_empty(&sc->dir_obj->variant.dir_variant.children))
+			sc->next_return = NULL;
+		else
+			sc->next_return =
+			    list_entry(dir->variant.dir_variant.children.next,
+				       struct yaffs_obj, siblings);
+		INIT_LIST_HEAD(&sc->others);
+		list_add(&sc->others, &(yaffs_dev_to_lc(dev)->search_contexts));
+	}
+	return sc;
+}
+
+/*
+ * yaffs_search_end() disposes of a search context and cleans up.
+ */
+static void yaffs_search_end(struct yaffs_search_context *sc)
+{
+	if (sc) {
+		list_del(&sc->others);
+		kfree(sc);
+	}
+}
+
+/*
+ * yaffs_search_advance() moves a search context to the next object.
+ * Called when the search iterates or when an object removal causes
+ * the search context to be moved to the next object.
+ */
+static void yaffs_search_advance(struct yaffs_search_context *sc)
+{
+	if (!sc)
+		return;
+
+	if (sc->next_return == NULL ||
+	    list_empty(&sc->dir_obj->variant.dir_variant.children))
+		sc->next_return = NULL;
+	else {
+		struct list_head *next = sc->next_return->siblings.next;
+
+		if (next == &sc->dir_obj->variant.dir_variant.children)
+			sc->next_return = NULL;	/* end of list */
+		else
+			sc->next_return =
+			    list_entry(next, struct yaffs_obj, siblings);
+	}
+}
+
+/*
+ * yaffs_remove_obj_callback() is called when an object is unlinked.
+ * We check open search contexts and advance any which are currently
+ * on the object being iterated.
+ */
+static void yaffs_remove_obj_callback(struct yaffs_obj *obj)
+{
+
+	struct list_head *i;
+	struct yaffs_search_context *sc;
+	struct list_head *search_contexts =
+	    &(yaffs_dev_to_lc(obj->my_dev)->search_contexts);
+
+	/* Iterate through the directory search contexts.
+	 * If any are currently on the object being removed, then advance
+	 * the search context to the next object to prevent a hanging pointer.
+	 */
+	list_for_each(i, search_contexts) {
+		sc = list_entry(i, struct yaffs_search_context, others);
+		if (sc->next_return == obj)
+			yaffs_search_advance(sc);
+	}
+
+}
+
+/*-----------------------------------------------------------------*/
+
+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
+			  int buflen)
+{
+	unsigned char *alias;
+	int ret;
+
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
 
 	yaffs_gross_lock(dev);
 
-	switch (mode & S_IFMT) {
-	default:
-		/* Special (socket, fifo, device...) */
-		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making special");
-		obj =
-		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
-					 gid, old_encode_dev(rdev));
-		break;
-	case S_IFREG:		/* file          */
-		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making file");
-		obj = yaffs_create_file(parent, dentry->d_name.name, mode, uid,
-					gid);
-		break;
-	case S_IFDIR:		/* directory */
-		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making directory");
-		obj = yaffs_create_dir(parent, dentry->d_name.name, mode,
-				       uid, gid);
-		break;
-	case S_IFLNK:		/* symlink */
-		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making symlink");
-		obj = NULL;	/* Do we ever get here? */
-		break;
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+
+	yaffs_gross_unlock(dev);
+
+	if (!alias)
+		return -ENOMEM;
+
+	ret = vfs_readlink(dentry, buffer, buflen, alias);
+	kfree(alias);
+	return ret;
+}
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	void *ret;
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	int ret
+#endif
+	unsigned char *alias;
+	int ret_int = 0;
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+	yaffs_gross_unlock(dev);
+
+	if (!alias) {
+		ret_int = -ENOMEM;
+		goto out;
 	}
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+	nd_set_link(nd, alias);
+	ret = alias;
+out:
+	if (ret_int)
+		ret = ERR_PTR(ret_int);
+	return ret;
+#else
+	ret = vfs_follow_link(nd, alias);
+	kfree(alias);
+out:
+	if (ret_int)
+		ret = ret_int;
+	return ret;
+#endif
+}
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias)
+{
+	kfree(alias);
+}
+#endif
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+			      struct yaffs_obj *obj);
+
+/*
+ * Lookup is used to find objects in the fs
+ */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *n)
+#else
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)
+#endif
+{
+	struct yaffs_obj *obj;
+	struct inode *inode = NULL;	/* NCB 2.5/2.6 needs NULL here */
 
-	/* Can not call yaffs_get_inode() with gross lock held */
+	struct yaffs_dev *dev = yaffs_inode_to_obj(dir)->my_dev;
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup for %d:%s",
+		yaffs_inode_to_obj(dir)->obj_id, dentry->d_name.name);
+
+	obj = yaffs_find_by_name(yaffs_inode_to_obj(dir), dentry->d_name.name);
+
+	obj = yaffs_get_equivalent_obj(obj);	/* in case it was a hardlink */
+
+	/* Can't hold gross lock when calling yaffs_get_inode() */
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
 	yaffs_gross_unlock(dev);
 
 	if (obj) {
-		inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
-		d_instantiate(dentry, inode);
-		update_dir_time(dir);
 		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_mknod created object %d count = %d",
-			obj->obj_id, atomic_read(&inode->i_count));
-		error = 0;
-		yaffs_fill_inode_from_obj(dir, parent);
+			"yaffs_lookup found %d", obj->obj_id);
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
 	} else {
-		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod failed making object");
-		error = -ENOMEM;
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup not found");
+
 	}
 
-	return error;
+/* added NCB for 2.5/6 compatability - forces add even if inode is
+ * NULL which creates dentry hash */
+	d_add(dentry, inode);
+
+	return NULL;
 }
 
-static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+#ifdef YAFFS_HAS_PUT_INODE
+
+/* For now put inode is just for debugging
+ * Put inode is called when the inode **structure** is put.
+ */
+static void yaffs_put_inode(struct inode *inode)
 {
-	return yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_put_inode: ino %d, count %d"),
+		(int)inode->i_ino, atomic_read(&inode->i_count);
+
 }
+#endif
 
-static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
-			struct nameidata *n)
+static void yaffs_unstitch_obj(struct inode *inode, struct yaffs_obj *obj)
 {
-	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
+	/* Clear the association between the inode and
+	 * the struct yaffs_obj.
+	 */
+	obj->my_inode = NULL;
+	yaffs_inode_to_obj_lv(inode) = NULL;
+
+	/* If the object freeing was deferred, then the real
+	 * free happens now.
+	 * This should fix the inode inconsistency problem.
+	 */
+	yaffs_handle_defered_free(obj);
 }
 
-static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
-		      struct dentry *dentry)
+#ifdef YAFFS_HAS_EVICT_INODE
+/* yaffs_evict_inode combines into one operation what was previously done in
+ * yaffs_clear_inode() and yaffs_delete_inode()
+ *
+ */
+static void yaffs_evict_inode(struct inode *inode)
 {
-	struct inode *inode = old_dentry->d_inode;
-	struct yaffs_obj *obj = NULL;
-	struct yaffs_obj *link = NULL;
+	struct yaffs_obj *obj;
 	struct yaffs_dev *dev;
-
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_link");
+	int deleteme = 0;
 
 	obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_evict_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (!inode->i_nlink && !is_bad_inode(inode))
+		deleteme = 1;
+	truncate_inode_pages(&inode->i_data, 0);
+	end_writeback(inode);
+
+	if (deleteme && obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+	if (obj) {
 	dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
+	}
+}
+#else
 
+/* clear is called to tell the fs to release any per-inode data it holds.
+ * The object might still exist on disk and is just being thrown out of the cache
+ * or else the object has actually been deleted and we're being called via
+ * the chain
+ *   yaffs_delete_inode() -> clear_inode()->yaffs_clear_inode()
+ */
+
+static void yaffs_clear_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_clear_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (obj) {
+		dev = obj->my_dev;
 	yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
+	}
 
-	if (!S_ISDIR(inode->i_mode))	/* Don't link directories */
-		link =
-		    yaffs_link_obj(yaffs_inode_to_obj(dir), dentry->d_name.name,
-				   obj);
+}
+
+/* delete is called when the link count is zero and the inode
+ * is put (ie. nobody wants to know about it anymore, time to
+ * delete the file).
+ * NB Must call clear_inode()
+ */
+static void yaffs_delete_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+	struct yaffs_dev *dev;
 
-	if (link) {
-		old_dentry->d_inode->i_nlink = yaffs_get_obj_link_count(obj);
-		d_instantiate(dentry, old_dentry->d_inode);
-		atomic_inc(&old_dentry->d_inode->i_count);
 		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_link link count %d i_count %d",
-			old_dentry->d_inode->i_nlink,
-			atomic_read(&old_dentry->d_inode->i_count));
+		"yaffs_delete_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
 	}
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+	truncate_inode_pages(&inode->i_data, 0);
+#endif
+	clear_inode(inode);
+}
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id)
+#else
+static int yaffs_file_flush(struct file *file)
+#endif
+{
+	struct yaffs_obj *obj = yaffs_dentry_to_obj(file->f_dentry);
+
+	struct yaffs_dev *dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_flush object %d (%s)",
+		obj->obj_id,
+		obj->dirty ? "dirty" : "clean");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_file(obj, 1, 0);
 
 	yaffs_gross_unlock(dev);
 
-	if (link) {
-		update_dir_time(dir);
 		return 0;
-	}
-
-	return -EPERM;
 }
 
-static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
-			 const char *symname)
+static int yaffs_readpage_nolock(struct file *f, struct page *pg)
 {
+	/* Lifted from jffs2 */
+
 	struct yaffs_obj *obj;
+	unsigned char *pg_buf;
+	int ret;
+	loff_t pos = ((loff_t) pg->index) << PAGE_CACHE_SHIFT;
 	struct yaffs_dev *dev;
-	uid_t uid = current->cred->fsuid;
-	gid_t gid =
-	    (dir->i_mode & S_ISGID) ? dir->i_gid : current->cred->fsgid;
 
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_symlink");
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readpage_nolock at %lld, size %08x",
+		(long long)pos,
+		(unsigned)PAGE_CACHE_SIZE);
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	BUG_ON(!PageLocked(pg));
+#else
+	if (!PageLocked(pg))
+		PAGE_BUG(pg);
+#endif
+
+	pg_buf = kmap(pg);
+	/* FIXME: Can kmap fail? */
 
-	dev = yaffs_inode_to_obj(dir)->my_dev;
 	yaffs_gross_lock(dev);
-	obj = yaffs_create_symlink(yaffs_inode_to_obj(dir), dentry->d_name.name,
-				   S_IFLNK | S_IRWXUGO, uid, gid, symname);
+
+	ret = yaffs_file_rd(obj, pg_buf, pos, PAGE_CACHE_SIZE);
+
 	yaffs_gross_unlock(dev);
 
-	if (obj) {
+	if (ret >= 0)
+		ret = 0;
+
+	if (ret) {
+		ClearPageUptodate(pg);
+		SetPageError(pg);
+	} else {
+		SetPageUptodate(pg);
+		ClearPageError(pg);
+	}
+
+	flush_dcache_page(pg);
+	kunmap(pg);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage_nolock done");
+	return ret;
+}
+
+static int yaffs_readpage_unlock(struct file *f, struct page *pg)
+{
+	int ret = yaffs_readpage_nolock(f, pg);
+	UnlockPage(pg);
+	return ret;
+}
+
+static int yaffs_readpage(struct file *f, struct page *pg)
+{
+	int ret;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage");
+	ret = yaffs_readpage_unlock(f, pg);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage done");
+	return ret;
+}
+
+/* writepage inspired by/stolen from smbfs */
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc)
+#else
+static int yaffs_writepage(struct page *page)
+#endif
+{
+	struct yaffs_dev *dev;
+	struct address_space *mapping = page->mapping;
 		struct inode *inode;
+	unsigned long end_index;
+	char *buffer;
+	struct yaffs_obj *obj;
+	int n_written = 0;
+	unsigned n_bytes;
+	loff_t i_size;
 
-		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
-		d_instantiate(dentry, inode);
-		update_dir_time(dir);
-		yaffs_trace(YAFFS_TRACE_OS, "symlink created OK");
+	if (!mapping)
+		BUG();
+	inode = mapping->host;
+	if (!inode)
+		BUG();
+	i_size = i_size_read(inode);
+
+	end_index = i_size >> PAGE_CACHE_SHIFT;
+
+	if (page->index < end_index)
+		n_bytes = PAGE_CACHE_SIZE;
+	else {
+		n_bytes = i_size & (PAGE_CACHE_SIZE - 1);
+
+		if (page->index > end_index || !n_bytes) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_writepage at %lld, inode size = %lld!!",
+				((loff_t)page->index) << PAGE_CACHE_SHIFT,
+				inode->i_size);
+			yaffs_trace(YAFFS_TRACE_OS,
+				"                -> don't care!!");
+
+			zero_user_segment(page, 0, PAGE_CACHE_SIZE);
+			set_page_writeback(page);
+			unlock_page(page);
+			end_page_writeback(page);
 		return 0;
-	} else {
-		yaffs_trace(YAFFS_TRACE_OS, "symlink not created");
+		}
 	}
 
-	return -ENOMEM;
-}
+	if (n_bytes != PAGE_CACHE_SIZE)
+		zero_user_segment(page, n_bytes, PAGE_CACHE_SIZE);
 
-static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
-				   struct nameidata *n)
-{
-	struct yaffs_obj *obj;
-	struct inode *inode = NULL;
+	get_page(page);
 
-	struct yaffs_dev *dev = yaffs_inode_to_obj(dir)->my_dev;
+	buffer = kmap(page);
 
-	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
 		yaffs_gross_lock(dev);
 
 	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_lookup for %d:%s",
-		yaffs_inode_to_obj(dir)->obj_id, dentry->d_name.name);
+		"yaffs_writepage at %lld, size %08x",
+		((loff_t)page->index) << PAGE_CACHE_SHIFT, n_bytes);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag0: obj = %lld, ino = %lld",
+		obj->variant.file_variant.file_size, inode->i_size);
 
-	obj = yaffs_find_by_name(yaffs_inode_to_obj(dir), dentry->d_name.name);
+	n_written = yaffs_wr_file(obj, buffer,
+				  ((loff_t)page->index) << PAGE_CACHE_SHIFT, n_bytes, 0);
 
-	obj = yaffs_get_equivalent_obj(obj);	/* in case it was a hardlink */
+	yaffs_touch_super(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag1: obj = %lld, ino = %lld",
+		obj->variant.file_variant.file_size, inode->i_size);
 
-	/* Can't hold gross lock when calling yaffs_get_inode() */
-	if (current != yaffs_dev_to_lc(dev)->readdir_process)
 		yaffs_gross_unlock(dev);
 
-	if (obj) {
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_lookup found %d", obj->obj_id);
+	kunmap(page);
+	set_page_writeback(page);
+	unlock_page(page);
+	end_page_writeback(page);
+	put_page(page);
 
-		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+	return (n_written == n_bytes) ? 0 : -ENOSPC;
+}
 
-		if (inode) {
-			yaffs_trace(YAFFS_TRACE_OS, "yaffs_loookup dentry");
-			d_add(dentry, inode);
-			/* return dentry; */
-			return NULL;
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+			     loff_t pos, unsigned len, unsigned flags,
+			     struct page **pagep, void **fsdata)
+{
+	struct page *pg = NULL;
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+
+	int ret = 0;
+	int space_held = 0;
+
+	/* Get a page */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+	pg = grab_cache_page_write_begin(mapping, index, flags);
+#else
+	pg = __grab_cache_page(mapping, index);
+#endif
+
+	*pagep = pg;
+	if (!pg) {
+		ret = -ENOMEM;
+		goto out;
 		}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"start yaffs_write_begin index %d(%x) uptodate %d",
+		(int)index, (int)index, Page_Uptodate(pg) ? 1 : 0);
 
-	} else {
-		yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup not found");
+	/* Get fs space */
+	space_held = yaffs_hold_space(filp);
 
+	if (!space_held) {
+		ret = -ENOSPC;
+		goto out;
 	}
 
-	d_add(dentry, inode);
+	/* Update page if required */
 
-	return NULL;
-}
+	if (!Page_Uptodate(pg))
+		ret = yaffs_readpage_nolock(filp, pg);
 
-static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
-{
-	int ret_val;
+	if (ret)
+		goto out;
 
-	struct yaffs_dev *dev;
-	struct yaffs_obj *obj;
+	/* Happy path return */
+	yaffs_trace(YAFFS_TRACE_OS, "end yaffs_write_begin - ok");
 
+	return 0;
+
+out:
 	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_unlink %d:%s",
-		(int)(dir->i_ino), dentry->d_name.name);
-	obj = yaffs_inode_to_obj(dir);
-	dev = obj->my_dev;
+		"end yaffs_write_begin fail returning %d", ret);
+	if (space_held)
+		yaffs_release_space(filp);
+	if (pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
+	}
+	return ret;
+}
 
-	yaffs_gross_lock(dev);
+#else
 
-	ret_val = yaffs_unlinker(obj, dentry->d_name.name);
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+			       unsigned offset, unsigned to)
+{
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_prepair_write");
 
-	if (ret_val == YAFFS_OK) {
-		dentry->d_inode->i_nlink--;
-		dir->i_version++;
-		yaffs_gross_unlock(dev);
-		mark_inode_dirty(dentry->d_inode);
-		update_dir_time(dir);
+	if (!Page_Uptodate(pg))
+		return yaffs_readpage_nolock(f, pg);
 		return 0;
-	}
-	yaffs_gross_unlock(dev);
-	return -ENOTEMPTY;
 }
+#endif
 
-static int yaffs_sync_object(struct file *file, int datasync)
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata)
 {
+	int ret = 0;
+	void *addr, *kva;
+	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
 
-	struct yaffs_obj *obj;
-	struct yaffs_dev *dev;
-	struct dentry *dentry = file->f_path.dentry;
+	kva = kmap(pg);
+	addr = kva + offset_into_page;
 
-	obj = yaffs_dentry_to_obj(dentry);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_write_end addr %p pos %lld n_bytes %d",
+		addr, pos, copied);
 
-	dev = obj->my_dev;
+	ret = yaffs_file_write(filp, addr, copied, &pos);
 
-	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC, "yaffs_sync_object");
-	yaffs_gross_lock(dev);
-	yaffs_flush_file(obj, 1, datasync);
-	yaffs_gross_unlock(dev);
-	return 0;
-}
-/*
- * The VFS layer already does all the dentry stuff for rename.
- *
- * NB: POSIX says you can rename an object over an old object of the same name
- */
-static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
-			struct inode *new_dir, struct dentry *new_dentry)
-{
-	struct yaffs_dev *dev;
-	int ret_val = YAFFS_FAIL;
-	struct yaffs_obj *target;
+	if (ret != copied) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_write_end not same size ret %d  copied %d",
+			ret, copied);
+		SetPageError(pg);
+	}
 
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_rename");
-	dev = yaffs_inode_to_obj(old_dir)->my_dev;
+	kunmap(pg);
 
-	yaffs_gross_lock(dev);
+	yaffs_release_space(filp);
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+#else
 
-	/* Check if the target is an existing directory that is not empty. */
-	target = yaffs_find_by_name(yaffs_inode_to_obj(new_dir),
-				    new_dentry->d_name.name);
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+			      unsigned to)
+{
+	void *addr, *kva;
 
-	if (target && target->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY &&
-	    !list_empty(&target->variant.dir_variant.children)) {
+	loff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;
+	int n_bytes = to - offset;
+	int n_written;
 
-		yaffs_trace(YAFFS_TRACE_OS, "target is non-empty dir");
+	kva = kmap(pg);
+	addr = kva + offset;
 
-		ret_val = YAFFS_FAIL;
-	} else {
-		/* Now does unlinking internally using shadowing mechanism */
-		yaffs_trace(YAFFS_TRACE_OS, "calling yaffs_rename_obj");
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_commit_write addr %p pos %lld n_bytes %d",
+		addr, pos, n_bytes);
 
-		ret_val = yaffs_rename_obj(yaffs_inode_to_obj(old_dir),
-					   old_dentry->d_name.name,
-					   yaffs_inode_to_obj(new_dir),
-					   new_dentry->d_name.name);
-	}
-	yaffs_gross_unlock(dev);
+	n_written = yaffs_file_write(f, addr, n_bytes, &pos);
 
-	if (ret_val == YAFFS_OK) {
-		if (target) {
-			new_dentry->d_inode->i_nlink--;
-			mark_inode_dirty(new_dentry->d_inode);
+	if (n_written != n_bytes) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_commit_write not same size n_written %d  n_bytes %d",
+			n_written, n_bytes);
+		SetPageError(pg);
 		}
+	kunmap(pg);
 
-		update_dir_time(old_dir);
-		if (old_dir != new_dir)
-			update_dir_time(new_dir);
-		return 0;
-	} else {
-		return -ENOTEMPTY;
-	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_commit_write returning %d",
+		n_written == n_bytes ? 0 : n_written);
+
+	return n_written == n_bytes ? 0 : n_written;
 }
+#endif
 
-static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
+static void yaffs_fill_inode_from_obj(struct inode *inode,
+				      struct yaffs_obj *obj)
 {
-	struct inode *inode = dentry->d_inode;
-	int error = 0;
-	struct yaffs_dev *dev;
-
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_setattr of object %d",
-		yaffs_inode_to_obj(inode)->obj_id);
-
-	/* Fail if a requested resize >= 2GB */
-	if (attr->ia_valid & ATTR_SIZE && (attr->ia_size >> 31))
-		error = -EINVAL;
+	if (inode && obj) {
 
-	if (error == 0)
-		error = inode_change_ok(inode, attr);
-	if (error == 0) {
-		int result;
-		if (!error) {
-			setattr_copy(inode, attr);
-			yaffs_trace(YAFFS_TRACE_OS, "inode_setattr called");
-			if (attr->ia_valid & ATTR_SIZE) {
-				truncate_setsize(inode, attr->ia_size);
-				inode->i_blocks = (inode->i_size + 511) >> 9;
-			}
+		/* Check mode against the variant type and attempt to repair if broken. */
+		u32 mode = obj->yst_mode;
+		switch (obj->variant_type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			if (!S_ISREG(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFREG;
 		}
-		dev = yaffs_inode_to_obj(inode)->my_dev;
-		if (attr->ia_valid & ATTR_SIZE) {
-			yaffs_trace(YAFFS_TRACE_OS, "resize to %d(%x)",
-					   (int)(attr->ia_size),
-					   (int)(attr->ia_size));
+
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			if (!S_ISLNK(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFLNK;
 		}
-		yaffs_gross_lock(dev);
-		result = yaffs_set_attribs(yaffs_inode_to_obj(inode), attr);
-		if (result == YAFFS_OK) {
-			error = 0;
-		} else {
-			error = -EPERM;
+
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			if (!S_ISDIR(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFDIR;
 		}
-		yaffs_gross_unlock(dev);
 
+			break;
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+		default:
+			/* TODO? */
+			break;
 	}
 
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setattr done returning %d", error);
+		inode->i_flags |= S_NOATIME;
 
-	return error;
-}
+		inode->i_ino = obj->obj_id;
+		inode->i_mode = obj->yst_mode;
+		inode->i_uid = obj->yst_uid;
+		inode->i_gid = obj->yst_gid;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+		inode->i_blksize = inode->i_sb->s_blocksize;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
 
-#ifdef CONFIG_YAFFS_XATTR
-static int yaffs_setxattr(struct dentry *dentry, const char *name,
-		   const void *value, size_t size, int flags)
-{
-	struct inode *inode = dentry->d_inode;
-	int error = 0;
-	struct yaffs_dev *dev;
-	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+		inode->i_rdev = old_decode_dev(obj->yst_rdev);
+		inode->i_atime.tv_sec = (time_t) (obj->yst_atime);
+		inode->i_atime.tv_nsec = 0;
+		inode->i_mtime.tv_sec = (time_t) obj->yst_mtime;
+		inode->i_mtime.tv_nsec = 0;
+		inode->i_ctime.tv_sec = (time_t) obj->yst_ctime;
+		inode->i_ctime.tv_nsec = 0;
+#else
+		inode->i_rdev = obj->yst_rdev;
+		inode->i_atime = obj->yst_atime;
+		inode->i_mtime = obj->yst_mtime;
+		inode->i_ctime = obj->yst_ctime;
+#endif
+		inode->i_size = yaffs_get_obj_length(obj);
+		inode->i_blocks = (inode->i_size + 511) >> 9;
 
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr of object %d", obj->obj_id);
+		set_nlink(inode, yaffs_get_obj_link_count(obj));
 
-	if (error == 0) {
-		int result;
-		dev = obj->my_dev;
-		yaffs_gross_lock(dev);
-		result = yaffs_set_xattrib(obj, name, value, size, flags);
-		if (result == YAFFS_OK)
-			error = 0;
-		else if (result < 0)
-			error = result;
-		yaffs_gross_unlock(dev);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_fill_inode mode %x uid %d gid %d size %lld count %d",
+			inode->i_mode, inode->i_uid, inode->i_gid,
+			inode->i_size, atomic_read(&inode->i_count));
 
+		switch (obj->yst_mode & S_IFMT) {
+		default:	/* fifo, device or socket */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+			init_special_inode(inode, obj->yst_mode,
+					   old_decode_dev(obj->yst_rdev));
+#else
+			init_special_inode(inode, obj->yst_mode,
+					   (dev_t) (obj->yst_rdev));
+#endif
+			break;
+		case S_IFREG:	/* file */
+			inode->i_op = &yaffs_file_inode_operations;
+			inode->i_fop = &yaffs_file_operations;
+			inode->i_mapping->a_ops =
+			    &yaffs_file_address_operations;
+			break;
+		case S_IFDIR:	/* directory */
+			inode->i_op = &yaffs_dir_inode_operations;
+			inode->i_fop = &yaffs_dir_operations;
+			break;
+		case S_IFLNK:	/* symlink */
+			inode->i_op = &yaffs_symlink_inode_operations;
+			break;
 	}
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr done returning %d", error);
 
-	return error;
-}
+		yaffs_inode_to_obj_lv(inode) = obj;
 
-static ssize_t yaffs_getxattr(struct dentry * dentry, const char *name, void *buff,
-		       size_t size)
-{
-	struct inode *inode = dentry->d_inode;
-	int error = 0;
-	struct yaffs_dev *dev;
-	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+		obj->my_inode = inode;
 
+	} else {
 	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_getxattr \"%s\" from object %d",
-		name, obj->obj_id);
-
-	if (error == 0) {
-		dev = obj->my_dev;
-		yaffs_gross_lock(dev);
-		error = yaffs_get_xattrib(obj, name, buff, size);
-		yaffs_gross_unlock(dev);
-
+			"yaffs_fill_inode invalid parameters");
 	}
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_getxattr done returning %d", error);
 
-	return error;
 }
 
-static int yaffs_removexattr(struct dentry *dentry, const char *name)
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+			      struct yaffs_obj *obj)
 {
-	struct inode *inode = dentry->d_inode;
-	int error = 0;
-	struct yaffs_dev *dev;
-	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+	struct inode *inode;
 
+	if (!sb) {
 	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_removexattr of object %d", obj->obj_id);
+			"yaffs_get_inode for NULL super_block!!");
+		return NULL;
 
-	if (error == 0) {
-		int result;
-		dev = obj->my_dev;
-		yaffs_gross_lock(dev);
-		result = yaffs_remove_xattrib(obj, name);
-		if (result == YAFFS_OK)
-			error = 0;
-		else if (result < 0)
-			error = result;
-		yaffs_gross_unlock(dev);
+	}
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL object!!");
+		return NULL;
 
 	}
+
 	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_removexattr done returning %d", error);
+		"yaffs_get_inode for object %d", obj->obj_id);
 
-	return error;
+	inode = Y_IGET(sb, obj->obj_id);
+	if (IS_ERR(inode))
+		return NULL;
+
+	/* NB Side effect: iget calls back to yaffs_read_inode(). */
+	/* iget also increments the inode's i_count */
+	/* NB You can't be holding gross_lock or deadlock will happen! */
+
+	return inode;
 }
 
-static ssize_t yaffs_listxattr(struct dentry * dentry, char *buff, size_t size)
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t * pos)
 {
-	struct inode *inode = dentry->d_inode;
-	int error = 0;
+	struct yaffs_obj *obj;
+	int n_written;
+	loff_t ipos;
+	struct inode *inode;
 	struct yaffs_dev *dev;
-	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
 
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	if (!obj) {
 	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_listxattr of object %d", obj->obj_id);
+			"yaffs_file_write: hey obj is null!");
+                return -EINVAL;
+        }
 
-	if (error == 0) {
 		dev = obj->my_dev;
+
 		yaffs_gross_lock(dev);
-		error = yaffs_list_xattrib(obj, buff, size);
-		yaffs_gross_unlock(dev);
 
-	}
+	inode = f->f_dentry->d_inode;
+
+	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
+		ipos = inode->i_size;
+	else
+		ipos = *pos;
+
 	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_listxattr done returning %d", error);
+		"yaffs_file_write about to write writing %u(%x) bytes to object %d at %lld",
+		(unsigned)n, (unsigned)n, obj->obj_id, ipos);
 
-	return error;
-}
+	n_written = yaffs_wr_file(obj, buf, ipos, n, 0);
 
-#endif
+	yaffs_touch_super(dev);
 
-static const struct inode_operations yaffs_dir_inode_operations = {
-	.create = yaffs_create,
-	.lookup = yaffs_lookup,
-	.link = yaffs_link,
-	.unlink = yaffs_unlink,
-	.symlink = yaffs_symlink,
-	.mkdir = yaffs_mkdir,
-	.rmdir = yaffs_unlink,
-	.mknod = yaffs_mknod,
-	.rename = yaffs_rename,
-	.setattr = yaffs_setattr,
-#ifdef CONFIG_YAFFS_XATTR
-	.setxattr = yaffs_setxattr,
-	.getxattr = yaffs_getxattr,
-	.listxattr = yaffs_listxattr,
-	.removexattr = yaffs_removexattr,
-#endif
-};
-/*-----------------------------------------------------------------*/
-/* Directory search context allows us to unlock access to yaffs during
- * filldir without causing problems with the directory being modified.
- * This is similar to the tried and tested mechanism used in yaffs direct.
- *
- * A search context iterates along a doubly linked list of siblings in the
- * directory. If the iterating object is deleted then this would corrupt
- * the list iteration, likely causing a crash. The search context avoids
- * this by using the remove_obj_fn to move the search context to the
- * next object before the object is deleted.
- *
- * Many readdirs (and thus seach conexts) may be alive simulateously so
- * each struct yaffs_dev has a list of these.
- *
- * A seach context lives for the duration of a readdir.
- *
- * All these functions must be called while yaffs is locked.
- */
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write: %d(%x) bytes written",
+		(unsigned)n, (unsigned)n);
 
-struct yaffs_search_context {
-	struct yaffs_dev *dev;
-	struct yaffs_obj *dir_obj;
-	struct yaffs_obj *next_return;
-	struct list_head others;
-};
+	if (n_written > 0) {
+		ipos += n_written;
+		*pos = ipos;
+		if (ipos > inode->i_size) {
+			inode->i_size = ipos;
+			inode->i_blocks = (ipos + 511) >> 9;
 
-/*
- * yaffs_new_search() creates a new search context, initialises it and
- * adds it to the device's search context list.
- *
- * Called at start of readdir.
- */
-static struct yaffs_search_context *yaffs_new_search(struct yaffs_obj *dir)
-{
-	struct yaffs_dev *dev = dir->my_dev;
-	struct yaffs_search_context *sc =
-	    kmalloc(sizeof(struct yaffs_search_context), GFP_NOFS);
-	if (sc) {
-		sc->dir_obj = dir;
-		sc->dev = dev;
-		if (list_empty(&sc->dir_obj->variant.dir_variant.children))
-			sc->next_return = NULL;
-		else
-			sc->next_return =
-			    list_entry(dir->variant.dir_variant.children.next,
-				       struct yaffs_obj, siblings);
-		INIT_LIST_HEAD(&sc->others);
-		list_add(&sc->others, &(yaffs_dev_to_lc(dev)->search_contexts));
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_file_write size updated to %lld bytes, %d blocks",
+				ipos, (int)(inode->i_blocks));
 	}
-	return sc;
-}
 
-/*
- * yaffs_search_end() disposes of a search context and cleans up.
- */
-static void yaffs_search_end(struct yaffs_search_context *sc)
-{
-	if (sc) {
-		list_del(&sc->others);
-		kfree(sc);
 	}
+	yaffs_gross_unlock(dev);
+	return (n_written == 0) && (n > 0) ? -ENOSPC : n_written;
 }
 
-/*
- * yaffs_search_advance() moves a search context to the next object.
- * Called when the search iterates or when an object removal causes
- * the search context to be moved to the next object.
- */
-static void yaffs_search_advance(struct yaffs_search_context *sc)
+/* Space holding and freeing is done to ensure we have space available for write_begin/end */
+/* For now we just assume few parallel writes and check against a small number. */
+/* Todo: need to do this with a counter to handle parallel reads better */
+
+static ssize_t yaffs_hold_space(struct file *f)
 {
-	if (!sc)
-		return;
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
 
-	if (sc->next_return == NULL ||
-	    list_empty(&sc->dir_obj->variant.dir_variant.children))
-		sc->next_return = NULL;
-	else {
-		struct list_head *next = sc->next_return->siblings.next;
+	int n_free_chunks;
 
-		if (next == &sc->dir_obj->variant.dir_variant.children)
-			sc->next_return = NULL;	/* end of list */
-		else
-			sc->next_return =
-			    list_entry(next, struct yaffs_obj, siblings);
-	}
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	n_free_chunks = yaffs_get_n_free_chunks(dev);
+
+	yaffs_gross_unlock(dev);
+
+	return (n_free_chunks > 20) ? 1 : 0;
 }
 
-/*
- * yaffs_remove_obj_callback() is called when an object is unlinked.
- * We check open search contexts and advance any which are currently
- * on the object being iterated.
- */
-static void yaffs_remove_obj_callback(struct yaffs_obj *obj)
+static void yaffs_release_space(struct file *f)
 {
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
 
-	struct list_head *i;
-	struct yaffs_search_context *sc;
-	struct list_head *search_contexts =
-	    &(yaffs_dev_to_lc(obj->my_dev)->search_contexts);
+	obj = yaffs_dentry_to_obj(f->f_dentry);
 
-	/* Iterate through the directory search contexts.
-	 * If any are currently on the object being removed, then advance
-	 * the search context to the next object to prevent a hanging pointer.
-	 */
-	list_for_each(i, search_contexts) {
-		if (i) {
-			sc = list_entry(i, struct yaffs_search_context, others);
-			if (sc->next_return == obj)
-				yaffs_search_advance(sc);
-		}
-	}
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
 
+	yaffs_gross_unlock(dev);
 }
 
 static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
@@ -843,622 +1549,541 @@
 			"yaffs_readdir: entry .. ino %d",
 			(int)f->f_dentry->d_parent->d_inode->i_ino);
 		yaffs_gross_unlock(dev);
-		if (filldir(dirent, "..", 2, offset,
-			    f->f_dentry->d_parent->d_inode->i_ino,
-			    DT_DIR) < 0) {
-			yaffs_gross_lock(dev);
-			goto out;
-		}
-		yaffs_gross_lock(dev);
-		offset++;
-		f->f_pos++;
-	}
-
-	curoffs = 1;
-
-	/* If the directory has changed since the open or last call to
-	   readdir, rewind to after the 2 canned entries. */
-	if (f->f_version != inode->i_version) {
-		offset = 2;
-		f->f_pos = offset;
-		f->f_version = inode->i_version;
-	}
-
-	while (sc->next_return) {
-		curoffs++;
-		l = sc->next_return;
-		if (curoffs >= offset) {
-			int this_inode = yaffs_get_obj_inode(l);
-			int this_type = yaffs_get_obj_type(l);
-
-			yaffs_get_obj_name(l, name, YAFFS_MAX_NAME_LENGTH + 1);
-			yaffs_trace(YAFFS_TRACE_OS,
-				"yaffs_readdir: %s inode %d",
-				name, yaffs_get_obj_inode(l));
-
-			yaffs_gross_unlock(dev);
-
-			if (filldir(dirent,
-				    name,
-				    strlen(name),
-				    offset, this_inode, this_type) < 0) {
-				yaffs_gross_lock(dev);
-				goto out;
-			}
-
-			yaffs_gross_lock(dev);
-
-			offset++;
-			f->f_pos++;
-		}
-		yaffs_search_advance(sc);
-	}
-
-out:
-	yaffs_search_end(sc);
-	yaffs_dev_to_lc(dev)->readdir_process = NULL;
-	yaffs_gross_unlock(dev);
-
-	return ret_val;
-}
-
-static const struct file_operations yaffs_dir_operations = {
-	.read = generic_read_dir,
-	.readdir = yaffs_readdir,
-	.fsync = yaffs_sync_object,
-	.llseek = generic_file_llseek,
-};
-
-
-
-static int yaffs_file_flush(struct file *file, fl_owner_t id)
-{
-	struct yaffs_obj *obj = yaffs_dentry_to_obj(file->f_dentry);
-
-	struct yaffs_dev *dev = obj->my_dev;
-
-	yaffs_trace(YAFFS_TRACE_OS,
-	  	"yaffs_file_flush object %d (%s)",
-		obj->obj_id, obj->dirty ? "dirty" : "clean");
-
-	yaffs_gross_lock(dev);
-
-	yaffs_flush_file(obj, 1, 0);
-
-	yaffs_gross_unlock(dev);
-
-	return 0;
-}
-
-static const struct file_operations yaffs_file_operations = {
-	.read = do_sync_read,
-	.write = do_sync_write,
-	.aio_read = generic_file_aio_read,
-	.aio_write = generic_file_aio_write,
-	.mmap = generic_file_mmap,
-	.flush = yaffs_file_flush,
-	.fsync = yaffs_sync_object,
-	.splice_read = generic_file_splice_read,
-	.splice_write = generic_file_splice_write,
-	.llseek = generic_file_llseek,
-};
-
-
-/* ExportFS support */
-static struct inode *yaffs2_nfs_get_inode(struct super_block *sb, uint64_t ino,
-					  uint32_t generation)
-{
-	return yaffs_iget(sb, ino);
-}
-
-static struct dentry *yaffs2_fh_to_dentry(struct super_block *sb,
-					  struct fid *fid, int fh_len,
-					  int fh_type)
-{
-	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
-				    yaffs2_nfs_get_inode);
-}
-
-static struct dentry *yaffs2_fh_to_parent(struct super_block *sb,
-					  struct fid *fid, int fh_len,
-					  int fh_type)
-{
-	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
-				    yaffs2_nfs_get_inode);
-}
-
-struct dentry *yaffs2_get_parent(struct dentry *dentry)
-{
-
-	struct super_block *sb = dentry->d_inode->i_sb;
-	struct dentry *parent = ERR_PTR(-ENOENT);
-	struct inode *inode;
-	unsigned long parent_ino;
-	struct yaffs_obj *d_obj;
-	struct yaffs_obj *parent_obj;
-
-	d_obj = yaffs_inode_to_obj(dentry->d_inode);
-
-	if (d_obj) {
-		parent_obj = d_obj->parent;
-		if (parent_obj) {
-			parent_ino = yaffs_get_obj_inode(parent_obj);
-			inode = yaffs_iget(sb, parent_ino);
-
-			if (IS_ERR(inode)) {
-				parent = ERR_CAST(inode);
-			} else {
-				parent = d_obtain_alias(inode);
-				if (!IS_ERR(parent)) {
-					parent = ERR_PTR(-ENOMEM);
-					iput(inode);
-				}
-			}
-		}
-	}
-
-	return parent;
-}
-
-/* Just declare a zero structure as a NULL value implies
- * using the default functions of exportfs.
- */
-
-static struct export_operations yaffs_export_ops = {
-	.fh_to_dentry = yaffs2_fh_to_dentry,
-	.fh_to_parent = yaffs2_fh_to_parent,
-	.get_parent = yaffs2_get_parent,
-};
-
-
-/*-----------------------------------------------------------------*/
-
-static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
-			  int buflen)
-{
-	unsigned char *alias;
-	int ret;
-
-	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
-
-	yaffs_gross_lock(dev);
-
-	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
-
-	yaffs_gross_unlock(dev);
-
-	if (!alias)
-		return -ENOMEM;
-
-	ret = vfs_readlink(dentry, buffer, buflen, alias);
-	kfree(alias);
-	return ret;
-}
-
-static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
-{
-	unsigned char *alias;
-	void *ret;
-	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
-
-	yaffs_gross_lock(dev);
-
-	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
-	yaffs_gross_unlock(dev);
-
-	if (!alias) {
-		ret = ERR_PTR(-ENOMEM);
+		if (filldir(dirent, "..", 2, offset,
+			    f->f_dentry->d_parent->d_inode->i_ino,
+			    DT_DIR) < 0) {
+			yaffs_gross_lock(dev);
 		goto out;
 	}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
 
-	nd_set_link(nd, alias);
-	ret = (void *)alias;
-out:
-	return ret;
-}
-
-void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias)
-{
-	kfree(alias);
-}
-
-
-static void yaffs_unstitch_obj(struct inode *inode, struct yaffs_obj *obj)
-{
-	/* Clear the association between the inode and
-	 * the struct yaffs_obj.
-	 */
-	obj->my_inode = NULL;
-	yaffs_inode_to_obj_lv(inode) = NULL;
-
-	/* If the object freeing was deferred, then the real
-	 * free happens now.
-	 * This should fix the inode inconsistency problem.
-	 */
-	yaffs_handle_defered_free(obj);
-}
+	curoffs = 1;
 
-/* yaffs_evict_inode combines into one operation what was previously done in
- * yaffs_clear_inode() and yaffs_delete_inode()
- *
- */
-static void yaffs_evict_inode(struct inode *inode)
-{
-	struct yaffs_obj *obj;
-	struct yaffs_dev *dev;
-	int deleteme = 0;
+	/* If the directory has changed since the open or last call to
+	   readdir, rewind to after the 2 canned entries. */
+	if (f->f_version != inode->i_version) {
+		offset = 2;
+		f->f_pos = offset;
+		f->f_version = inode->i_version;
+	}
 
-	obj = yaffs_inode_to_obj(inode);
+	while (sc->next_return) {
+		curoffs++;
+		l = sc->next_return;
+		if (curoffs >= offset) {
+			int this_inode = yaffs_get_obj_inode(l);
+			int this_type = yaffs_get_obj_type(l);
 
+			yaffs_get_obj_name(l, name, YAFFS_MAX_NAME_LENGTH + 1);
 	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_evict_inode: ino %d, count %d %s",
-		(int)inode->i_ino,
-		atomic_read(&inode->i_count),
-		obj ? "object exists" : "null object");
+				"yaffs_readdir: %s inode %d",
+				name, yaffs_get_obj_inode(l));
 
-	if (!inode->i_nlink && !is_bad_inode(inode))
-		deleteme = 1;
-	truncate_inode_pages(&inode->i_data, 0);
-	end_writeback(inode);
+			yaffs_gross_unlock(dev);
 
-	if (deleteme && obj) {
-		dev = obj->my_dev;
+			if (filldir(dirent,
+				    name,
+				    strlen(name),
+				    offset, this_inode, this_type) < 0) {
 		yaffs_gross_lock(dev);
-		yaffs_del_obj(obj);
-		yaffs_gross_unlock(dev);
+				goto out;
 	}
-	if (obj) {
-		dev = obj->my_dev;
+
 		yaffs_gross_lock(dev);
-		yaffs_unstitch_obj(inode, obj);
-		yaffs_gross_unlock(dev);
+
+			offset++;
+			f->f_pos++;
 	}
+		yaffs_search_advance(sc);
+	}
+
+out:
+	yaffs_search_end(sc);
+	yaffs_dev_to_lc(dev)->readdir_process = NULL;
+	yaffs_gross_unlock(dev);
 
+	return ret_val;
 }
 
-static void yaffs_touch_super(struct yaffs_dev *dev)
-{
-	struct super_block *sb = yaffs_dev_to_lc(dev)->super;
+/*
+ * File creation. Allocate an inode, and we're done..
+ */
 
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_touch_super() sb = %p", sb);
-	if (sb)
-		sb->s_dirt = 1;
-}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+#define YCRED(x) x
+#else
+#define YCRED(x) (x->cred)
+#endif
 
-static int yaffs_readpage_nolock(struct file *f, struct page *pg)
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       dev_t rdev)
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       int rdev)
+#endif
 {
-	/* Lifted from jffs2 */
-
-	struct yaffs_obj *obj;
-	unsigned char *pg_buf;
-	int ret;
+	struct inode *inode;
 
+	struct yaffs_obj *obj = NULL;
 	struct yaffs_dev *dev;
 
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_readpage_nolock at %08x, size %08x",
-		(unsigned)(pg->index << PAGE_CACHE_SHIFT),
-		(unsigned)PAGE_CACHE_SIZE);
+	struct yaffs_obj *parent = yaffs_inode_to_obj(dir);
 
-	obj = yaffs_dentry_to_obj(f->f_dentry);
+	int error = -ENOSPC;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
 
-	dev = obj->my_dev;
+	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
+		mode |= S_ISGID;
 
-	BUG_ON(!PageLocked(pg));
+	if (parent) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: parent object %d type %d",
+			parent->obj_id, parent->variant_type);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: could not get parent object");
+		return -EPERM;
+	}
 
-	pg_buf = kmap(pg);
-	/* FIXME: Can kmap fail? */
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_mknod: making oject for %s, mode %x dev %x",
+		dentry->d_name.name, mode, rdev);
+
+	dev = parent->my_dev;
 
 	yaffs_gross_lock(dev);
 
-	ret = yaffs_file_rd(obj, pg_buf,
-			    pg->index << PAGE_CACHE_SHIFT, PAGE_CACHE_SIZE);
+	switch (mode & S_IFMT) {
+	default:
+		/* Special (socket, fifo, device...) */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making special");
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, old_encode_dev(rdev));
+#else
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, rdev);
+#endif
+		break;
+	case S_IFREG:		/* file          */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making file");
+		obj = yaffs_create_file(parent, dentry->d_name.name, mode, uid,
+					gid);
+		break;
+	case S_IFDIR:		/* directory */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making directory");
+		obj = yaffs_create_dir(parent, dentry->d_name.name, mode,
+				       uid, gid);
+		break;
+	case S_IFLNK:		/* symlink */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making symlink");
+		obj = NULL;	/* Do we ever get here? */
+		break;
+	}
 
+	/* Can not call yaffs_get_inode() with gross lock held */
 	yaffs_gross_unlock(dev);
 
-	if (ret >= 0)
-		ret = 0;
-
-	if (ret) {
-		ClearPageUptodate(pg);
-		SetPageError(pg);
+	if (obj) {
+		inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod created object %d count = %d",
+			obj->obj_id, atomic_read(&inode->i_count));
+		error = 0;
+		yaffs_fill_inode_from_obj(dir, parent);
 	} else {
-		SetPageUptodate(pg);
-		ClearPageError(pg);
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod failed making object");
+		error = -ENOMEM;
 	}
 
-	flush_dcache_page(pg);
-	kunmap(pg);
-
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage_nolock done");
-	return ret;
+	return error;
 }
 
-static int yaffs_readpage_unlock(struct file *f, struct page *pg)
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
-	int ret = yaffs_readpage_nolock(f, pg);
-	UnlockPage(pg);
-	return ret;
+	int ret_val;
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_mkdir");
+	ret_val = yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
+	return ret_val;
 }
 
-static int yaffs_readpage(struct file *f, struct page *pg)
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n)
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode)
+#endif
 {
-	int ret;
-
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage");
-	ret = yaffs_readpage_unlock(f, pg);
-	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage done");
-	return ret;
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_create");
+	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
 }
 
-/* writepage inspired by/stolen from smbfs */
-
-static int yaffs_writepage(struct page *page, struct writeback_control *wbc)
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
 {
+	int ret_val;
+
 	struct yaffs_dev *dev;
-	struct address_space *mapping = page->mapping;
-	struct inode *inode;
-	unsigned long end_index;
-	char *buffer;
 	struct yaffs_obj *obj;
-	int n_written = 0;
-	unsigned n_bytes;
-	loff_t i_size;
-
-	if (!mapping)
-		BUG();
-	inode = mapping->host;
-	if (!inode)
-		BUG();
-	i_size = i_size_read(inode);
 
-	end_index = i_size >> PAGE_CACHE_SHIFT;
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_unlink %d:%s",
+		(int)(dir->i_ino), dentry->d_name.name);
+	obj = yaffs_inode_to_obj(dir);
+	dev = obj->my_dev;
 
-	if (page->index < end_index)
-		n_bytes = PAGE_CACHE_SIZE;
-	else {
-		n_bytes = i_size & (PAGE_CACHE_SIZE - 1);
+	yaffs_gross_lock(dev);
 
-		if (page->index > end_index || !n_bytes) {
-			yaffs_trace(YAFFS_TRACE_OS,
-				"yaffs_writepage at %08x, inode size = %08x!!!",
-				(unsigned)(page->index << PAGE_CACHE_SHIFT),
-				(unsigned)inode->i_size);
-			yaffs_trace(YAFFS_TRACE_OS,
-			  "                -> don't care!!");
+	ret_val = yaffs_unlinker(obj, dentry->d_name.name);
 
-			zero_user_segment(page, 0, PAGE_CACHE_SIZE);
-			set_page_writeback(page);
-			unlock_page(page);
-			end_page_writeback(page);
+	if (ret_val == YAFFS_OK) {
+		inode_dec_link_count(dentry->d_inode);
+		dir->i_version++;
+		yaffs_gross_unlock(dev);
+		update_dir_time(dir);
 			return 0;
 		}
-	}
-
-	if (n_bytes != PAGE_CACHE_SIZE)
-		zero_user_segment(page, n_bytes, PAGE_CACHE_SIZE);
+	yaffs_gross_unlock(dev);
+	return -ENOTEMPTY;
+}
 
-	get_page(page);
+/*
+ * Create a link...
+ */
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+		      struct dentry *dentry)
+{
+	struct inode *inode = old_dentry->d_inode;
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_obj *link = NULL;
+	struct yaffs_dev *dev;
 
-	buffer = kmap(page);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_link");
 
 	obj = yaffs_inode_to_obj(inode);
 	dev = obj->my_dev;
-	yaffs_gross_lock(dev);
 
-	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_writepage at %08x, size %08x",
-		(unsigned)(page->index << PAGE_CACHE_SHIFT), n_bytes);
-	yaffs_trace(YAFFS_TRACE_OS,
-		"writepag0: obj = %05x, ino = %05x",
-		(int)obj->variant.file_variant.file_size, (int)inode->i_size);
-
-	n_written = yaffs_wr_file(obj, buffer,
-				  page->index << PAGE_CACHE_SHIFT, n_bytes, 0);
+	yaffs_gross_lock(dev);
 
-	yaffs_touch_super(dev);
+	if (!S_ISDIR(inode->i_mode))	/* Don't link directories */
+		link =
+		    yaffs_link_obj(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   obj);
 
+	if (link) {
+		set_nlink(old_dentry->d_inode, yaffs_get_obj_link_count(obj));
+		d_instantiate(dentry, old_dentry->d_inode);
+		atomic_inc(&old_dentry->d_inode->i_count);
 	yaffs_trace(YAFFS_TRACE_OS,
-		"writepag1: obj = %05x, ino = %05x",
-		(int)obj->variant.file_variant.file_size, (int)inode->i_size);
+			"yaffs_link link count %d i_count %d",
+			old_dentry->d_inode->i_nlink,
+			atomic_read(&old_dentry->d_inode->i_count));
+	}
 
 	yaffs_gross_unlock(dev);
 
-	kunmap(page);
-	set_page_writeback(page);
-	unlock_page(page);
-	end_page_writeback(page);
-	put_page(page);
+	if (link) {
+		update_dir_time(dir);
+		return 0;
+	}
 
-	return (n_written == n_bytes) ? 0 : -ENOSPC;
+	return -EPERM;
 }
 
-/* Space holding and freeing is done to ensure we have space available for 
- * write_begin/end.
- * For now we just assume few parallel writes and check against a small
- * number.
- * Todo: need to do this with a counter to handle parallel reads better.
- */
-
-static ssize_t yaffs_hold_space(struct file *f)
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			 const char *symname)
 {
 	struct yaffs_obj *obj;
 	struct yaffs_dev *dev;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
 
-	int n_free_chunks;
-
-	obj = yaffs_dentry_to_obj(f->f_dentry);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_symlink");
 
-	dev = obj->my_dev;
+	if (strnlen(dentry->d_name.name, YAFFS_MAX_NAME_LENGTH + 1) >
+				YAFFS_MAX_NAME_LENGTH)
+		return -ENAMETOOLONG;
+
+	if (strnlen(symname, YAFFS_MAX_ALIAS_LENGTH + 1) >
+				YAFFS_MAX_ALIAS_LENGTH)
+		return -ENAMETOOLONG;
 
+	dev = yaffs_inode_to_obj(dir)->my_dev;
 	yaffs_gross_lock(dev);
+	obj = yaffs_create_symlink(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   S_IFLNK | S_IRWXUGO, uid, gid, symname);
+	yaffs_gross_unlock(dev);
 
-	n_free_chunks = yaffs_get_n_free_chunks(dev);
+	if (obj) {
+		struct inode *inode;
 
-	yaffs_gross_unlock(dev);
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		yaffs_trace(YAFFS_TRACE_OS, "symlink created OK");
+		return 0;
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "symlink not created");
+	}
 
-	return (n_free_chunks > 20) ? 1 : 0;
+	return -ENOMEM;
 }
 
-static void yaffs_release_space(struct file *f)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static int yaffs_sync_object(struct file *file, loff_t start, loff_t end, int datasync)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+static int yaffs_sync_object(struct file *file, int datasync)
+#else
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+			     int datasync)
+#endif
 {
+
 	struct yaffs_obj *obj;
 	struct yaffs_dev *dev;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+	struct dentry *dentry = file->f_path.dentry;
+#endif
 
-	obj = yaffs_dentry_to_obj(f->f_dentry);
+	obj = yaffs_dentry_to_obj(dentry);
 
 	dev = obj->my_dev;
 
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		"yaffs_sync_object");
 	yaffs_gross_lock(dev);
-
+	yaffs_flush_file(obj, 1, datasync);
 	yaffs_gross_unlock(dev);
+	return 0;
 }
 
-static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
-			     loff_t pos, unsigned len, unsigned flags,
-			     struct page **pagep, void **fsdata)
+/*
+ * The VFS layer already does all the dentry stuff for rename.
+ *
+ * NB: POSIX says you can rename an object over an old object of the same name
+ */
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry)
 {
-	struct page *pg = NULL;
-	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
-
-	int ret = 0;
-	int space_held = 0;
+	struct yaffs_dev *dev;
+	int ret_val = YAFFS_FAIL;
+	struct yaffs_obj *target;
 
-	/* Get a page */
-	pg = grab_cache_page_write_begin(mapping, index, flags);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_rename");
+	dev = yaffs_inode_to_obj(old_dir)->my_dev;
 
-	*pagep = pg;
-	if (!pg) {
-		ret = -ENOMEM;
-		goto out;
-	}
-	yaffs_trace(YAFFS_TRACE_OS,
-		"start yaffs_write_begin index %d(%x) uptodate %d",
-		(int)index, (int)index, Page_Uptodate(pg) ? 1 : 0);
+	yaffs_gross_lock(dev);
 
-	/* Get fs space */
-	space_held = yaffs_hold_space(filp);
+	/* Check if the target is an existing directory that is not empty. */
+	target = yaffs_find_by_name(yaffs_inode_to_obj(new_dir),
+				    new_dentry->d_name.name);
 
-	if (!space_held) {
-		ret = -ENOSPC;
-		goto out;
-	}
+	if (target && target->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY &&
+	    !list_empty(&target->variant.dir_variant.children)) {
 
-	/* Update page if required */
+		yaffs_trace(YAFFS_TRACE_OS, "target is non-empty dir");
 
-	if (!Page_Uptodate(pg))
-		ret = yaffs_readpage_nolock(filp, pg);
+		ret_val = YAFFS_FAIL;
+	} else {
+		/* Now does unlinking internally using shadowing mechanism */
+		yaffs_trace(YAFFS_TRACE_OS, "calling yaffs_rename_obj");
 
-	if (ret)
-		goto out;
+		ret_val = yaffs_rename_obj(yaffs_inode_to_obj(old_dir),
+					   old_dentry->d_name.name,
+					   yaffs_inode_to_obj(new_dir),
+					   new_dentry->d_name.name);
+	}
+	yaffs_gross_unlock(dev);
 
-	/* Happy path return */
-	yaffs_trace(YAFFS_TRACE_OS, "end yaffs_write_begin - ok");
+	if (ret_val == YAFFS_OK) {
+		if (target)
+			inode_dec_link_count(new_dentry->d_inode);
 
+		update_dir_time(old_dir);
+		if (old_dir != new_dir)
+			update_dir_time(new_dir);
 	return 0;
+	} else {
+		return -ENOTEMPTY;
+	}
+}
+
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
 
-out:
 	yaffs_trace(YAFFS_TRACE_OS,
-		"end yaffs_write_begin fail returning %d", ret);
-	if (space_held)
-		yaffs_release_space(filp);
-	if (pg) {
-		unlock_page(pg);
-		page_cache_release(pg);
+		"yaffs_setattr of object %d",
+		yaffs_inode_to_obj(inode)->obj_id);
+#if 0
+	/* Fail if a requested resize >= 2GB */
+	if (attr->ia_valid & ATTR_SIZE && (attr->ia_size >> 31))
+		error = -EINVAL;
+#endif
+
+	if (error == 0)
+		error = inode_change_ok(inode, attr);
+	if (error == 0) {
+		int result;
+		if (!error) {
+			error = yaffs_vfs_setattr(inode, attr);
+			yaffs_trace(YAFFS_TRACE_OS, "inode_setattr called");
+			if (attr->ia_valid & ATTR_SIZE) {
+				yaffs_vfs_setsize(inode, attr->ia_size);
+				inode->i_blocks = (inode->i_size + 511) >> 9;
 	}
-	return ret;
+		}
+		dev = yaffs_inode_to_obj(inode)->my_dev;
+		if (attr->ia_valid & ATTR_SIZE) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"resize to %d(%x)",
+				(int)(attr->ia_size),
+				(int)(attr->ia_size));
+		}
+		yaffs_gross_lock(dev);
+		result = yaffs_set_attribs(yaffs_inode_to_obj(inode), attr);
+		if (result == YAFFS_OK) {
+			error = 0;
+		} else {
+			error = -EPERM;
+		}
+		yaffs_gross_unlock(dev);
+
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setattr done returning %d", error);
+
+	return error;
 }
 
-static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
-				loff_t * pos)
+static int yaffs_setxattr(struct dentry *dentry, const char *name,
+		   const void *value, size_t size, int flags)
 {
-	struct yaffs_obj *obj;
-	int n_written, ipos;
-	struct inode *inode;
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
 	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
 
-	obj = yaffs_dentry_to_obj(f->f_dentry);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr of object %d", obj->obj_id);
 
+	if (error == 0) {
+		int result;
 	dev = obj->my_dev;
-
 	yaffs_gross_lock(dev);
+		result = yaffs_set_xattrib(obj, name, value, size, flags);
+		if (result == YAFFS_OK)
+			error = 0;
+		else if (result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
 
-	inode = f->f_dentry->d_inode;
+	}
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr done returning %d", error);
 
-	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
-		ipos = inode->i_size;
-	else
-		ipos = *pos;
+	return error;
+}
+
+static ssize_t yaffs_getxattr(struct dentry * dentry, const char *name,
+			void *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
 
-	if (!obj)
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_file_write: hey obj is null!");
-	else
 		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_file_write about to write writing %u(%x) bytes to object %d at %d(%x)",
-			(unsigned)n, (unsigned)n, obj->obj_id, ipos, ipos);
+		"yaffs_getxattr \"%s\" from object %d",
+		name, obj->obj_id);
+
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_get_xattrib(obj, name, buff, size);
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_getxattr done returning %d", error);
 
-	n_written = yaffs_wr_file(obj, buf, ipos, n, 0);
+	return error;
+}
 
-	yaffs_touch_super(dev);
+static int yaffs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
 
 	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_file_write: %d(%x) bytes written",
-		(unsigned)n, (unsigned)n);
+		"yaffs_removexattr of object %d", obj->obj_id);
 
-	if (n_written > 0) {
-		ipos += n_written;
-		*pos = ipos;
-		if (ipos > inode->i_size) {
-			inode->i_size = ipos;
-			inode->i_blocks = (ipos + 511) >> 9;
+	if (error == 0) {
+		int result;
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		result = yaffs_remove_xattrib(obj, name);
+		if (result == YAFFS_OK)
+			error = 0;
+		else if (result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
 
-			yaffs_trace(YAFFS_TRACE_OS,
-				"yaffs_file_write size updated to %d bytes, %d blocks",
-				ipos, (int)(inode->i_blocks));
 		}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr done returning %d", error);
 
-	}
-	yaffs_gross_unlock(dev);
-	return (n_written == 0) && (n > 0) ? -ENOSPC : n_written;
+	return error;
 }
 
-static int yaffs_write_end(struct file *filp, struct address_space *mapping,
-			   loff_t pos, unsigned len, unsigned copied,
-			   struct page *pg, void *fsdadata)
+static ssize_t yaffs_listxattr(struct dentry * dentry, char *buff, size_t size)
 {
-	int ret = 0;
-	void *addr, *kva;
-	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
-
-	kva = kmap(pg);
-	addr = kva + offset_into_page;
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
 
 	yaffs_trace(YAFFS_TRACE_OS,
-		"yaffs_write_end addr %p pos %x n_bytes %d",
-		addr, (unsigned)pos, copied);
+		"yaffs_listxattr of object %d", obj->obj_id);
 
-	ret = yaffs_file_write(filp, addr, copied, &pos);
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_list_xattrib(obj, buff, size);
+		yaffs_gross_unlock(dev);
 
-	if (ret != copied) {
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_write_end not same size ret %d  copied %d",
-			ret, copied);
-		SetPageError(pg);
 	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr done returning %d", error);
 
-	kunmap(pg);
-
-	yaffs_release_space(filp);
-	unlock_page(pg);
-	page_cache_release(pg);
-	return ret;
+	return error;
 }
 
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
 static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
 	struct super_block *sb = dentry->d_sb;
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+#endif
 
 	yaffs_trace(YAFFS_TRACE_OS, "yaffs_statfs");
 
@@ -1527,7 +2152,8 @@
 		obj = yaffs_inode_to_obj(iptr);
 		if (obj) {
 			yaffs_trace(YAFFS_TRACE_OS,
-				"flushing obj %d", obj->obj_id);
+				"flushing obj %d",
+				obj->obj_id);
 			yaffs_flush_file(obj, 1, 0);
 		}
 	}
@@ -1610,6 +2236,8 @@
  * The thread should not do any writing while the fs is in read only.
  */
 
+#ifdef YAFFS_COMPILE_BACKGROUND
+
 void yaffs_background_waker(unsigned long data)
 {
 	wake_up_process((struct task_struct *)data);
@@ -1631,16 +2259,19 @@
 	yaffs_trace(YAFFS_TRACE_BACKGROUND,
 		"yaffs_background starting for dev %p", (void *)dev);
 
+#ifdef YAFFS_COMPILE_FREEZER
 	set_freezable();
+#endif
 	while (context->bg_running) {
 		yaffs_trace(YAFFS_TRACE_BACKGROUND, "yaffs_background");
 
 		if (kthread_should_stop())
 			break;
 
+#ifdef YAFFS_COMPILE_FREEZER
 		if (try_to_freeze())
 			continue;
-
+#endif
 		yaffs_gross_lock(dev);
 
 		now = jiffies;
@@ -1669,6 +2300,7 @@
                         }
 		}
 		yaffs_gross_unlock(dev);
+#if 1
 		expires = next_dir_update;
 		if (time_before(next_gc, expires))
 			expires = next_gc;
@@ -1684,6 +2316,9 @@
 		add_timer(&timer);
 		schedule();
 		del_timer_sync(&timer);
+#else
+		msleep(10);
+#endif
 	}
 
 	return 0;
@@ -1722,20 +2357,46 @@
 		ctxt->bg_thread = NULL;
 	}
 }
+#else
+static int yaffs_bg_thread_fn(void *data)
+{
+	return 0;
+}
+
+static int yaffs_bg_start(struct yaffs_dev *dev)
+{
+	return 0;
+}
+
+static void yaffs_bg_stop(struct yaffs_dev *dev)
+{
+}
+#endif
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
 static void yaffs_write_super(struct super_block *sb)
+#else
+static int yaffs_write_super(struct super_block *sb)
+#endif
 {
 	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 2);
 
 	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
-		"yaffs_write_super%s",
+		"yaffs_write_super %s",
 		request_checkpoint ? " checkpt" : "");
 
 	yaffs_do_sync_fs(sb, request_checkpoint);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+	return 0;
+#endif
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
 static int yaffs_sync_fs(struct super_block *sb, int wait)
+#else
+static int yaffs_sync_fs(struct super_block *sb)
+#endif
 {
 	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 1);
 
@@ -1747,213 +2408,70 @@
 	return 0;
 }
 
+#ifdef YAFFS_USE_OWN_IGET
 
-static LIST_HEAD(yaffs_context_list);
-struct mutex yaffs_context_lock;
-
-
-
-struct yaffs_options {
-	int inband_tags;
-	int skip_checkpoint_read;
-	int skip_checkpoint_write;
-	int no_cache;
-	int tags_ecc_on;
-	int tags_ecc_overridden;
-	int lazy_loading_enabled;
-	int lazy_loading_overridden;
-	int empty_lost_and_found;
-	int empty_lost_and_found_overridden;
-};
-
-#define MAX_OPT_LEN 30
-static int yaffs_parse_options(struct yaffs_options *options,
-			       const char *options_str)
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino)
 {
-	char cur_opt[MAX_OPT_LEN + 1];
-	int p;
-	int error = 0;
-
-	/* Parse through the options which is a comma seperated list */
-
-	while (options_str && *options_str && !error) {
-		memset(cur_opt, 0, MAX_OPT_LEN + 1);
-		p = 0;
-
-		while (*options_str == ',')
-			options_str++;
-
-		while (*options_str && *options_str != ',') {
-			if (p < MAX_OPT_LEN) {
-				cur_opt[p] = *options_str;
-				p++;
-			}
-			options_str++;
-		}
-
-		if (!strcmp(cur_opt, "inband-tags")) {
-			options->inband_tags = 1;
-		} else if (!strcmp(cur_opt, "tags-ecc-off")) {
-			options->tags_ecc_on = 0;
-			options->tags_ecc_overridden = 1;
-		} else if (!strcmp(cur_opt, "tags-ecc-on")) {
-			options->tags_ecc_on = 1;
-			options->tags_ecc_overridden = 1;
-		} else if (!strcmp(cur_opt, "lazy-loading-off")) {
-			options->lazy_loading_enabled = 0;
-			options->lazy_loading_overridden = 1;
-		} else if (!strcmp(cur_opt, "lazy-loading-on")) {
-			options->lazy_loading_enabled = 1;
-			options->lazy_loading_overridden = 1;
-		} else if (!strcmp(cur_opt, "empty-lost-and-found-off")) {
-			options->empty_lost_and_found = 0;
-			options->empty_lost_and_found_overridden = 1;
-		} else if (!strcmp(cur_opt, "empty-lost-and-found-on")) {
-			options->empty_lost_and_found = 1;
-			options->empty_lost_and_found_overridden = 1;
-		} else if (!strcmp(cur_opt, "no-cache")) {
-			options->no_cache = 1;
-		} else if (!strcmp(cur_opt, "no-checkpoint-read")) {
-			options->skip_checkpoint_read = 1;
-		} else if (!strcmp(cur_opt, "no-checkpoint-write")) {
-			options->skip_checkpoint_write = 1;
-		} else if (!strcmp(cur_opt, "no-checkpoint")) {
-			options->skip_checkpoint_read = 1;
-			options->skip_checkpoint_write = 1;
-		} else {
-			printk(KERN_INFO "yaffs: Bad mount option \"%s\"\n",
-			       cur_opt);
-			error = 1;
-		}
-	}
-
-	return error;
-}
-
-static struct address_space_operations yaffs_file_address_operations = {
-	.readpage = yaffs_readpage,
-	.writepage = yaffs_writepage,
-	.write_begin = yaffs_write_begin,
-	.write_end = yaffs_write_end,
-};
-
-
-
-static const struct inode_operations yaffs_file_inode_operations = {
-	.setattr = yaffs_setattr,
-#ifdef CONFIG_YAFFS_XATTR
-	.setxattr = yaffs_setxattr,
-	.getxattr = yaffs_getxattr,
-	.listxattr = yaffs_listxattr,
-	.removexattr = yaffs_removexattr,
-#endif
-};
-
-static const struct inode_operations yaffs_symlink_inode_operations = {
-	.readlink = yaffs_readlink,
-	.follow_link = yaffs_follow_link,
-	.put_link = yaffs_put_link,
-	.setattr = yaffs_setattr,
-#ifdef CONFIG_YAFFS_XATTR
-	.setxattr = yaffs_setxattr,
-	.getxattr = yaffs_getxattr,
-	.listxattr = yaffs_listxattr,
-	.removexattr = yaffs_removexattr,
-#endif
-};
+	struct inode *inode;
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
 
-static void yaffs_fill_inode_from_obj(struct inode *inode,
-				      struct yaffs_obj *obj)
-{
-	if (inode && obj) {
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_iget for %lu", ino);
 
-		/* Check mode against the variant type and attempt to repair if broken. */
-		u32 mode = obj->yst_mode;
-		switch (obj->variant_type) {
-		case YAFFS_OBJECT_TYPE_FILE:
-			if (!S_ISREG(mode)) {
-				obj->yst_mode &= ~S_IFMT;
-				obj->yst_mode |= S_IFREG;
-			}
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
 
-			break;
-		case YAFFS_OBJECT_TYPE_SYMLINK:
-			if (!S_ISLNK(mode)) {
-				obj->yst_mode &= ~S_IFMT;
-				obj->yst_mode |= S_IFLNK;
-			}
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
 
-			break;
-		case YAFFS_OBJECT_TYPE_DIRECTORY:
-			if (!S_ISDIR(mode)) {
-				obj->yst_mode &= ~S_IFMT;
-				obj->yst_mode |= S_IFDIR;
-			}
+	yaffs_gross_lock(dev);
 
-			break;
-		case YAFFS_OBJECT_TYPE_UNKNOWN:
-		case YAFFS_OBJECT_TYPE_HARDLINK:
-		case YAFFS_OBJECT_TYPE_SPECIAL:
-		default:
-			/* TODO? */
-			break;
-		}
+	obj = yaffs_find_by_number(dev, inode->i_ino);
 
-		inode->i_flags |= S_NOATIME;
+	yaffs_fill_inode_from_obj(inode, obj);
 
-		inode->i_ino = obj->obj_id;
-		inode->i_mode = obj->yst_mode;
-		inode->i_uid = obj->yst_uid;
-		inode->i_gid = obj->yst_gid;
+	yaffs_gross_unlock(dev);
 
-		inode->i_rdev = old_decode_dev(obj->yst_rdev);
+	unlock_new_inode(inode);
+	return inode;
+}
 
-		inode->i_atime.tv_sec = (time_t) (obj->yst_atime);
-		inode->i_atime.tv_nsec = 0;
-		inode->i_mtime.tv_sec = (time_t) obj->yst_mtime;
-		inode->i_mtime.tv_nsec = 0;
-		inode->i_ctime.tv_sec = (time_t) obj->yst_ctime;
-		inode->i_ctime.tv_nsec = 0;
-		inode->i_size = yaffs_get_obj_length(obj);
-		inode->i_blocks = (inode->i_size + 511) >> 9;
+#else
+
+static void yaffs_read_inode(struct inode *inode)
+{
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
 
-		inode->i_nlink = yaffs_get_obj_link_count(obj);
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(inode->i_sb);
 
 		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_fill_inode mode %x uid %d gid %d size %d count %d",
-			inode->i_mode, inode->i_uid, inode->i_gid,
-			(int)inode->i_size, atomic_read(&inode->i_count));
+		"yaffs_read_inode for %d", (int)inode->i_ino);
 
-		switch (obj->yst_mode & S_IFMT) {
-		default:	/* fifo, device or socket */
-			init_special_inode(inode, obj->yst_mode,
-					   old_decode_dev(obj->yst_rdev));
-			break;
-		case S_IFREG:	/* file */
-			inode->i_op = &yaffs_file_inode_operations;
-			inode->i_fop = &yaffs_file_operations;
-			inode->i_mapping->a_ops =
-			    &yaffs_file_address_operations;
-			break;
-		case S_IFDIR:	/* directory */
-			inode->i_op = &yaffs_dir_inode_operations;
-			inode->i_fop = &yaffs_dir_operations;
-			break;
-		case S_IFLNK:	/* symlink */
-			inode->i_op = &yaffs_symlink_inode_operations;
-			break;
-		}
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
 
-		yaffs_inode_to_obj_lv(inode) = obj;
+	obj = yaffs_find_by_number(dev, inode->i_ino);
 
-		obj->my_inode = inode;
+	yaffs_fill_inode_from_obj(inode, obj);
 
-	} else {
-		yaffs_trace(YAFFS_TRACE_OS,
-			"yaffs_fill_inode invalid parameters");
-	}
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_unlock(dev);
 }
 
+#endif
+
+static LIST_HEAD(yaffs_context_list);
+struct mutex yaffs_context_lock;
+
 static void yaffs_put_super(struct super_block *sb)
 {
 	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
@@ -1976,6 +2494,7 @@
 	yaffs_deinitialise(dev);
 
 	yaffs_gross_unlock(dev);
+
 	mutex_lock(&yaffs_context_lock);
 	list_del_init(&(yaffs_dev_to_lc(dev)->context_list));
 	mutex_unlock(&yaffs_context_lock);
@@ -1998,14 +2517,95 @@
 	put_mtd_device(mtd);
 }
 
-static const struct super_operations yaffs_super_ops = {
-	.statfs = yaffs_statfs,
-	.put_super = yaffs_put_super,
-	.evict_inode = yaffs_evict_inode,
-	.sync_fs = yaffs_sync_fs,
-	.write_super = yaffs_write_super,
+static void yaffs_touch_super(struct yaffs_dev *dev)
+{
+	struct super_block *sb = yaffs_dev_to_lc(dev)->super;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_touch_super() sb = %p", sb);
+	if (sb)
+		sb->s_dirt = 1;
+}
+
+struct yaffs_options {
+	int inband_tags;
+	int skip_checkpoint_read;
+	int skip_checkpoint_write;
+	int no_cache;
+	int tags_ecc_on;
+	int tags_ecc_overridden;
+	int lazy_loading_enabled;
+	int lazy_loading_overridden;
+	int empty_lost_and_found;
+	int empty_lost_and_found_overridden;
+	int disable_summary;
 };
 
+#define MAX_OPT_LEN 30
+static int yaffs_parse_options(struct yaffs_options *options,
+			       const char *options_str)
+{
+	char cur_opt[MAX_OPT_LEN + 1];
+	int p;
+	int error = 0;
+
+	/* Parse through the options which is a comma seperated list */
+
+	while (options_str && *options_str && !error) {
+		memset(cur_opt, 0, MAX_OPT_LEN + 1);
+		p = 0;
+
+		while (*options_str == ',')
+			options_str++;
+
+		while (*options_str && *options_str != ',') {
+			if (p < MAX_OPT_LEN) {
+				cur_opt[p] = *options_str;
+				p++;
+			}
+			options_str++;
+		}
+
+		if (!strcmp(cur_opt, "inband-tags")) {
+			options->inband_tags = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-off")) {
+			options->tags_ecc_on = 0;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-on")) {
+			options->tags_ecc_on = 1;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-off")) {
+			options->lazy_loading_enabled = 0;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-on")) {
+			options->lazy_loading_enabled = 1;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "disable-summary")) {
+			options->disable_summary = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-off")) {
+			options->empty_lost_and_found = 0;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-on")) {
+			options->empty_lost_and_found = 1;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "no-cache")) {
+			options->no_cache = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-read")) {
+			options->skip_checkpoint_read = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-write")) {
+			options->skip_checkpoint_write = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint")) {
+			options->skip_checkpoint_read = 1;
+			options->skip_checkpoint_write = 1;
+		} else {
+			printk(KERN_INFO "yaffs: Bad mount option \"%s\"\n",
+			       cur_opt);
+			error = 1;
+		}
+	}
+
+	return error;
+}
+
 static struct super_block *yaffs_internal_read_super(int yaffs_version,
 						     struct super_block *sb,
 						     void *data, int silent)
@@ -2030,17 +2630,22 @@
 	struct yaffs_linux_context *context_iterator;
 	struct list_head *l;
 
+	if (!sb) {
+		printk(KERN_INFO "yaffs: sb is NULL\n");
+		return NULL;
+        }
+
 	sb->s_magic = YAFFS_MAGIC;
 	sb->s_op = &yaffs_super_ops;
 	sb->s_flags |= MS_NOATIME;
 
 	read_only = ((sb->s_flags & MS_RDONLY) != 0);
 
+#ifdef YAFFS_COMPILE_EXPORTFS
 	sb->s_export_op = &yaffs_export_ops;
+#endif
 
-	if (!sb)
-		printk(KERN_INFO "yaffs: sb is NULL\n");
-	else if (!sb->s_dev)
+	if (!sb->s_dev)
 		printk(KERN_INFO "yaffs: sb->s_dev is NULL\n");
 	else if (!yaffs_devname(sb, devname_buf))
 		printk(KERN_INFO "yaffs: devname is NULL\n");
@@ -2070,7 +2675,7 @@
 		"yaffs_read_super: block size %d", (int)(sb->s_blocksize));
 
 	yaffs_trace(YAFFS_TRACE_ALWAYS,
-		"Attempting MTD mount of %u.%u,\"%s\"",
+		"yaffs: Attempting MTD mount of %u.%u,\"%s\"",
 		MAJOR(sb->s_dev), MINOR(sb->s_dev),
 		yaffs_devname(sb, devname_buf));
 
@@ -2082,14 +2687,14 @@
 	mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
 	if (!mtd) {
 		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"MTD device #%u doesn't appear to exist",
+			"yaffs: MTD device #%u doesn't appear to exist",
 			MINOR(sb->s_dev));
 		return NULL;
 	}
 	/* Check it's NAND */
 	if (mtd->type != MTD_NANDFLASH) {
 		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"MTD device is not NAND it's type %d",
+			"yaffs: MTD device is not NAND it's type %d",
 			mtd->type);
 		return NULL;
 	}
@@ -2104,11 +2709,13 @@
 	yaffs_trace(YAFFS_TRACE_OS, " %s %d", WRITE_SIZE_STR, WRITE_SIZE(mtd));
 	yaffs_trace(YAFFS_TRACE_OS, " oobsize %d", mtd->oobsize);
 	yaffs_trace(YAFFS_TRACE_OS, " erasesize %d", mtd->erasesize);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+	yaffs_trace(YAFFS_TRACE_OS, " size %u", mtd->size);
+#else
 	yaffs_trace(YAFFS_TRACE_OS, " size %lld", mtd->size);
+#endif
 
-#ifdef CONFIG_YAFFS_AUTO_YAFFS2
-
-	if (yaffs_version == 1 && WRITE_SIZE(mtd) >= 2048) {
+	if (yaffs_auto_select && yaffs_version == 1 && WRITE_SIZE(mtd) >= 2048) {
 		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs2");
 		yaffs_version = 2;
 	}
@@ -2119,17 +2726,21 @@
 		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs1");
 		yaffs_version = 1;
 	}
-#endif
 
 	if (yaffs_version == 2) {
 		/* Check for version 2 style functions */
 		if (!mtd->erase ||
 		    !mtd->block_isbad ||
-		    !mtd->block_markbad ||
-		    !mtd->read ||
-		    !mtd->write || !mtd->read_oob || !mtd->write_oob) {
+		    !mtd->block_markbad || !mtd->read || !mtd->write ||
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		    !mtd->read_oob || !mtd->write_oob) {
+#else
+		    !mtd->write_ecc ||
+		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+#endif
 			yaffs_trace(YAFFS_TRACE_ALWAYS,
-				"MTD device does not support required functions");
+				"MTD device does not support required functions"
+			);
 			return NULL;
 		}
 
@@ -2137,23 +2748,30 @@
 		     mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&
 		    !options.inband_tags) {
 			yaffs_trace(YAFFS_TRACE_ALWAYS,
-				"MTD device does not have the right page sizes");
+				"MTD device does not have the right page sizes"
+			);
 			return NULL;
 		}
 	} else {
 		/* Check for V1 style functions */
-		if (!mtd->erase ||
-		    !mtd->read ||
-		    !mtd->write || !mtd->read_oob || !mtd->write_oob) {
+		if (!mtd->erase || !mtd->read || !mtd->write ||
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		    !mtd->read_oob || !mtd->write_oob) {
+#else
+		    !mtd->write_ecc ||
+		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+#endif
 			yaffs_trace(YAFFS_TRACE_ALWAYS,
-				"MTD device does not support required functions");
+				"MTD device does not support required functions"
+			);
 			return NULL;
 		}
 
 		if (WRITE_SIZE(mtd) < YAFFS_BYTES_PER_CHUNK ||
 		    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {
 			yaffs_trace(YAFFS_TRACE_ALWAYS,
-				"MTD device does not support have the right page sizes");
+				"MTD device does not support have the right page sizes"
+			);
 			return NULL;
 		}
 	}
@@ -2166,7 +2784,8 @@
 	if (!read_only && !(mtd->flags & MTD_WRITEABLE)) {
 		read_only = 1;
 		printk(KERN_INFO
-		       "yaffs: mtd is read only, setting superblock read only");
+		       "yaffs: mtd is read only, setting superblock read only\n"
+		);
 		sb->s_flags |= MS_RDONLY;
 	}
 
@@ -2185,7 +2804,8 @@
 	if (!dev) {
 		/* Deep shit could not allocate device structure */
 		yaffs_trace(YAFFS_TRACE_ALWAYS,
-			"yaffs_read_super failed trying to allocate yaffs_dev");
+			"yaffs_read_super: Failed trying to allocate struct yaffs_dev."
+		);
 		return NULL;
 	}
 	memset(dev, 0, sizeof(struct yaffs_dev));
@@ -2199,7 +2819,12 @@
 
 	dev->read_only = read_only;
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
 	sb->s_fs_info = dev;
+#else
+	sb->u.generic_sbp = dev;
+#endif
+
 
 	dev->driver_context = mtd;
 	param->name = mtd->name;
@@ -2218,40 +2843,18 @@
 	param->n_caches = (options.no_cache) ? 0 : 10;
 	param->inband_tags = options.inband_tags;
 
-#ifdef CONFIG_YAFFS_DISABLE_LAZY_LOAD
-	param->disable_lazy_load = 1;
-#endif
-#ifdef CONFIG_YAFFS_XATTR
 	param->enable_xattr = 1;
-#endif
 	if (options.lazy_loading_overridden)
 		param->disable_lazy_load = !options.lazy_loading_enabled;
 
-#ifdef CONFIG_YAFFS_DISABLE_TAGS_ECC
-	param->no_tags_ecc = 1;
-#endif
-
-#ifdef CONFIG_YAFFS_DISABLE_BACKGROUND
-#else
 	param->defered_dir_update = 1;
-#endif
 
 	if (options.tags_ecc_overridden)
 		param->no_tags_ecc = !options.tags_ecc_on;
 
-#ifdef CONFIG_YAFFS_EMPTY_LOST_AND_FOUND
 	param->empty_lost_n_found = 1;
-#endif
-
-#ifdef CONFIG_YAFFS_DISABLE_BLOCK_REFRESHING
-	param->refresh_period = 0;
-#else
 	param->refresh_period = 500;
-#endif
-
-#ifdef CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED
-	param->always_check_erased = 1;
-#endif
+	param->disable_summary = options.disable_summary;
 
 	if (options.empty_lost_and_found_overridden)
 		param->empty_lost_n_found = options.empty_lost_and_found;
@@ -2265,18 +2868,28 @@
 		yaffs_dev_to_lc(dev)->spare_buffer = 
 		                kmalloc(mtd->oobsize, GFP_NOFS);
 		param->is_yaffs2 = 1;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
 		param->total_bytes_per_chunk = mtd->writesize;
 		param->chunks_per_block = mtd->erasesize / mtd->writesize;
+#else
+		param->total_bytes_per_chunk = mtd->oobblock;
+		param->chunks_per_block = mtd->erasesize / mtd->oobblock;
+#endif
 		n_blocks = YCALCBLOCKS(mtd->size, mtd->erasesize);
 
 		param->start_block = 0;
 		param->end_block = n_blocks - 1;
 	} else {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
 		/* use the MTD interface in yaffs_mtdif1.c */
 		param->write_chunk_tags_fn = nandmtd1_write_chunk_tags;
 		param->read_chunk_tags_fn = nandmtd1_read_chunk_tags;
 		param->bad_block_fn = nandmtd1_mark_block_bad;
 		param->query_block_fn = nandmtd1_query_block;
+#else
+		param->write_chunk_fn = nandmtd_write_chunk;
+		param->read_chunk_fn = nandmtd_read_chunk;
+#endif
 		param->is_yaffs2 = 0;
 	}
 	/* ... and common functions */
@@ -2290,9 +2903,7 @@
 
 	yaffs_dev_to_lc(dev)->super = sb;
 
-#ifndef CONFIG_YAFFS_DOES_ECC
 	param->use_nand_ecc = 1;
-#endif
 
 	param->skip_checkpt_rd = options.skip_checkpoint_read;
 	param->skip_checkpt_wr = options.skip_checkpoint_write;
@@ -2336,6 +2947,8 @@
 	if (!context->bg_thread)
 		param->defered_dir_update = 0;
 
+	sb->s_maxbytes = yaffs_max_file_size(dev);
+
 	/* Release lock before yaffs_get_inode() */
 	yaffs_gross_unlock(dev);
 
@@ -2369,12 +2982,20 @@
 	return sb;
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
 static int yaffs_internal_read_super_mtd(struct super_block *sb, void *data,
 					 int silent)
 {
 	return yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static struct dentry *yaffs_mount(struct file_system_type *fs_type, int flags,
+        const char *dev_name, void *data)
+{
+    return mount_bdev(fs_type, flags, dev_name, data, yaffs_internal_read_super_mtd);
+}
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
 static int yaffs_read_super(struct file_system_type *fs,
 			    int flags, const char *dev_name,
 			    void *data, struct vfsmount *mnt)
@@ -2383,23 +3004,54 @@
 	return get_sb_bdev(fs, flags, dev_name, data,
 			   yaffs_internal_read_super_mtd, mnt);
 }
+#else
+static struct super_block *yaffs_read_super(struct file_system_type *fs,
+					    int flags, const char *dev_name,
+					    void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd);
+}
+#endif
 
 static struct file_system_type yaffs_fs_type = {
 	.owner = THIS_MODULE,
 	.name = "yaffs",
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+        .mount = yaffs_mount,
+#else
 	.get_sb = yaffs_read_super,
+#endif
 	.kill_sb = kill_block_super,
 	.fs_flags = FS_REQUIRES_DEV,
 };
+#else
+static struct super_block *yaffs_read_super(struct super_block *sb, void *data,
+					    int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs_fs_type, "yaffs", yaffs_read_super,
+		      FS_REQUIRES_DEV);
+#endif
 
-#ifdef CONFIG_YAFFS_YAFFS2
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
 static int yaffs2_internal_read_super_mtd(struct super_block *sb, void *data,
 					  int silent)
 {
 	return yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static struct dentry *yaffs2_mount(struct file_system_type *fs_type, int flags,
+        const char *dev_name, void *data)
+{
+        return mount_bdev(fs_type, flags, dev_name, data, yaffs2_internal_read_super_mtd);
+}
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
 static int yaffs2_read_super(struct file_system_type *fs,
 			     int flags, const char *dev_name, void *data,
 			     struct vfsmount *mnt)
@@ -2407,91 +3059,115 @@
 	return get_sb_bdev(fs, flags, dev_name, data,
 			   yaffs2_internal_read_super_mtd, mnt);
 }
+#else
+static struct super_block *yaffs2_read_super(struct file_system_type *fs,
+					     int flags, const char *dev_name,
+					     void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd);
+}
+#endif
 
 static struct file_system_type yaffs2_fs_type = {
 	.owner = THIS_MODULE,
 	.name = "yaffs2",
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+        .mount = yaffs2_mount,
+#else
 	.get_sb = yaffs2_read_super,
+#endif
 	.kill_sb = kill_block_super,
 	.fs_flags = FS_REQUIRES_DEV,
 };
-#endif /* CONFIG_YAFFS_YAFFS2 */
+#else
+static struct super_block *yaffs2_read_super(struct super_block *sb,
+					     void *data, int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs2_fs_type, "yaffs2", yaffs2_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
 
 static struct proc_dir_entry *my_proc_entry;
 
 static char *yaffs_dump_dev_part0(char *buf, struct yaffs_dev *dev)
 {
 	struct yaffs_param *param = &dev->param;
-	buf += sprintf(buf, "start_block........... %d\n", param->start_block);
-	buf += sprintf(buf, "end_block............. %d\n", param->end_block);
-	buf += sprintf(buf, "total_bytes_per_chunk. %d\n",
+
+	buf += sprintf(buf, "start_block.......... %d\n", param->start_block);
+	buf += sprintf(buf, "end_block............ %d\n", param->end_block);
+	buf += sprintf(buf, "total_bytes_per_chunk %d\n",
 			param->total_bytes_per_chunk);
-	buf += sprintf(buf, "use_nand_ecc.......... %d\n",
-			param->use_nand_ecc);
-	buf += sprintf(buf, "no_tags_ecc........... %d\n", param->no_tags_ecc);
-	buf += sprintf(buf, "is_yaffs2............. %d\n", param->is_yaffs2);
-	buf += sprintf(buf, "inband_tags........... %d\n", param->inband_tags);
-	buf += sprintf(buf, "empty_lost_n_found.... %d\n",
+	buf += sprintf(buf, "use_nand_ecc......... %d\n", param->use_nand_ecc);
+	buf += sprintf(buf, "no_tags_ecc.......... %d\n", param->no_tags_ecc);
+	buf += sprintf(buf, "is_yaffs2............ %d\n", param->is_yaffs2);
+	buf += sprintf(buf, "inband_tags.......... %d\n", param->inband_tags);
+	buf += sprintf(buf, "empty_lost_n_found... %d\n",
 			param->empty_lost_n_found);
-	buf += sprintf(buf, "disable_lazy_load..... %d\n",
+	buf += sprintf(buf, "disable_lazy_load.... %d\n",
 			param->disable_lazy_load);
-	buf += sprintf(buf, "refresh_period........ %d\n",
+	buf += sprintf(buf, "refresh_period....... %d\n",
 			param->refresh_period);
-	buf += sprintf(buf, "n_caches.............. %d\n", param->n_caches);
-	buf += sprintf(buf, "n_reserved_blocks..... %d\n",
+	buf += sprintf(buf, "n_caches............. %d\n", param->n_caches);
+	buf += sprintf(buf, "n_reserved_blocks.... %d\n",
 			param->n_reserved_blocks);
-	buf += sprintf(buf, "always_check_erased... %d\n",
+	buf += sprintf(buf, "always_check_erased.. %d\n",
 			param->always_check_erased);
+	buf += sprintf(buf, "\n");
 
 	return buf;
 }
 
 static char *yaffs_dump_dev_part1(char *buf, struct yaffs_dev *dev)
 {
-	buf +=
-	    sprintf(buf, "data_bytes_per_chunk.. %d\n",
+	buf += sprintf(buf, "max file size....... %lld\n",
+				(long long) yaffs_max_file_size(dev));
+	buf += sprintf(buf, "data_bytes_per_chunk. %d\n",
 		    dev->data_bytes_per_chunk);
-	buf += sprintf(buf, "chunk_grp_bits........ %d\n", dev->chunk_grp_bits);
-	buf += sprintf(buf, "chunk_grp_size........ %d\n", dev->chunk_grp_size);
-	buf +=
-	    sprintf(buf, "n_erased_blocks....... %d\n", dev->n_erased_blocks);
-	buf +=
-	    sprintf(buf, "blocks_in_checkpt..... %d\n", dev->blocks_in_checkpt);
+	buf += sprintf(buf, "chunk_grp_bits....... %d\n", dev->chunk_grp_bits);
+	buf += sprintf(buf, "chunk_grp_size....... %d\n", dev->chunk_grp_size);
+	buf += sprintf(buf, "n_erased_blocks...... %d\n", dev->n_erased_blocks);
+	buf += sprintf(buf, "blocks_in_checkpt.... %d\n",
+				dev->blocks_in_checkpt);
 	buf += sprintf(buf, "\n");
-	buf += sprintf(buf, "n_tnodes.............. %d\n", dev->n_tnodes);
-	buf += sprintf(buf, "n_obj................. %d\n", dev->n_obj);
-	buf += sprintf(buf, "n_free_chunks......... %d\n", dev->n_free_chunks);
+	buf += sprintf(buf, "n_tnodes............. %d\n", dev->n_tnodes);
+	buf += sprintf(buf, "n_obj................ %d\n", dev->n_obj);
+	buf += sprintf(buf, "n_free_chunks........ %d\n", dev->n_free_chunks);
 	buf += sprintf(buf, "\n");
-	buf += sprintf(buf, "n_page_writes......... %u\n", dev->n_page_writes);
-	buf += sprintf(buf, "n_page_reads.......... %u\n", dev->n_page_reads);
-	buf += sprintf(buf, "n_erasures............ %u\n", dev->n_erasures);
-	buf += sprintf(buf, "n_gc_copies........... %u\n", dev->n_gc_copies);
-	buf += sprintf(buf, "all_gcs............... %u\n", dev->all_gcs);
-	buf +=
-	    sprintf(buf, "passive_gc_count...... %u\n", dev->passive_gc_count);
-	buf +=
-	    sprintf(buf, "oldest_dirty_gc_count. %u\n",
+	buf += sprintf(buf, "n_page_writes........ %u\n", dev->n_page_writes);
+	buf += sprintf(buf, "n_page_reads......... %u\n", dev->n_page_reads);
+	buf += sprintf(buf, "n_erasures........... %u\n", dev->n_erasures);
+	buf += sprintf(buf, "n_gc_copies.......... %u\n", dev->n_gc_copies);
+	buf += sprintf(buf, "all_gcs.............. %u\n", dev->all_gcs);
+	buf += sprintf(buf, "passive_gc_count..... %u\n",
+				dev->passive_gc_count);
+	buf += sprintf(buf, "oldest_dirty_gc_count %u\n",
 		    dev->oldest_dirty_gc_count);
-	buf += sprintf(buf, "n_gc_blocks........... %u\n", dev->n_gc_blocks);
-	buf += sprintf(buf, "bg_gcs................ %u\n", dev->bg_gcs);
-	buf +=
-	    sprintf(buf, "n_retired_writes...... %u\n", dev->n_retired_writes);
-	buf +=
-	    sprintf(buf, "n_retired_blocks...... %u\n", dev->n_retired_blocks);
-	buf += sprintf(buf, "n_ecc_fixed........... %u\n", dev->n_ecc_fixed);
-	buf += sprintf(buf, "n_ecc_unfixed......... %u\n", dev->n_ecc_unfixed);
-	buf +=
-	    sprintf(buf, "n_tags_ecc_fixed...... %u\n", dev->n_tags_ecc_fixed);
-	buf +=
-	    sprintf(buf, "n_tags_ecc_unfixed.... %u\n",
+	buf += sprintf(buf, "n_gc_blocks.......... %u\n", dev->n_gc_blocks);
+	buf += sprintf(buf, "bg_gcs............... %u\n", dev->bg_gcs);
+	buf += sprintf(buf, "n_retried_writes..... %u\n",
+				dev->n_retried_writes);
+	buf += sprintf(buf, "n_retired_blocks..... %u\n",
+				dev->n_retired_blocks);
+	buf += sprintf(buf, "n_ecc_fixed.......... %u\n", dev->n_ecc_fixed);
+	buf += sprintf(buf, "n_ecc_unfixed........ %u\n", dev->n_ecc_unfixed);
+	buf += sprintf(buf, "n_tags_ecc_fixed..... %u\n",
+				dev->n_tags_ecc_fixed);
+	buf += sprintf(buf, "n_tags_ecc_unfixed... %u\n",
 		    dev->n_tags_ecc_unfixed);
-	buf += sprintf(buf, "cache_hits............ %u\n", dev->cache_hits);
-	buf +=
-	    sprintf(buf, "n_deleted_files....... %u\n", dev->n_deleted_files);
-	buf +=
-	    sprintf(buf, "n_unlinked_files...... %u\n", dev->n_unlinked_files);
-	buf += sprintf(buf, "refresh_count......... %u\n", dev->refresh_count);
-	buf += sprintf(buf, "n_bg_deletions........ %u\n", dev->n_bg_deletions);
+	buf += sprintf(buf, "cache_hits........... %u\n", dev->cache_hits);
+	buf += sprintf(buf, "n_deleted_files...... %u\n", dev->n_deleted_files);
+	buf += sprintf(buf, "n_unlinked_files..... %u\n",
+				dev->n_unlinked_files);
+	buf += sprintf(buf, "refresh_count........ %u\n", dev->refresh_count);
+	buf += sprintf(buf, "n_bg_deletions....... %u\n", dev->n_bg_deletions);
+	buf += sprintf(buf, "tags_used............ %u\n", dev->tags_used);
+	buf += sprintf(buf, "summary_used......... %u\n", dev->summary_used);
 
 	return buf;
 }
@@ -2515,7 +3191,10 @@
 
 	/* Print header first */
 	if (step == 0)
-		buf += sprintf(buf, "YAFFS built:" __DATE__ " " __TIME__ "\n");
+		buf +=
+		    sprintf(buf,
+			    "Multi-version YAFFS built:" __DATE__ " " __TIME__
+			    "\n");
 	else if (step == 1)
 		buf += sprintf(buf, "\n");
 	else {
@@ -2551,7 +3230,6 @@
 	return buf - page < count ? buf - page : count;
 }
 
-
 /**
  * Set the verbosity of the warnings and error messages.
  *
@@ -2716,11 +3394,6 @@
 	yaffs_trace(YAFFS_TRACE_ALWAYS,
 		"yaffs built " __DATE__ " " __TIME__ " Installing.");
 
-#ifdef CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED
-	yaffs_trace(YAFFS_TRACE_ALWAYS,
-		"\n\nYAFFS-WARNING CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED selected.\n\n\n");
-#endif
-
 	mutex_init(&yaffs_context_lock);
 
 	/* Install the proc_fs entries */
@@ -2735,7 +3408,6 @@
 		return -ENOMEM;
         }
 
-
 	/* Now add the file system entries */
 
 	fsinst = fs_to_install;
@@ -2788,5 +3460,5 @@
     module_exit(exit_yaffs_fs)
 
     MODULE_DESCRIPTION("YAFFS2 - a NAND specific flash file system");
-MODULE_AUTHOR("Charles Manning, Aleph One Ltd., 2002-2010");
+MODULE_AUTHOR("Charles Manning, Aleph One Ltd., 2002-2011");
 MODULE_LICENSE("GPL");
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_vfs_multi.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_vfs_multi.c
--- linux-3.1.9/fs/yaffs2/yaffs_vfs_multi.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_vfs_multi.c	2012-06-28 16:54:39.723622580 -0600
@@ -0,0 +1,3464 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ * Acknowledgements:
+ * Luc van OostenRyck for numerous patches.
+ * Nick Bane for numerous patches.
+ * Nick Bane for 2.5/2.6 integration.
+ * Andras Toth for mknod rdev issue.
+ * Michael Fischer for finding the problem with inode inconsistency.
+ * Some code bodily lifted from JFFS
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ *
+ * This is the file system front-end to YAFFS that hooks it up to
+ * the VFS.
+ *
+ * Special notes:
+ * >> 2.4: sb->u.generic_sbp points to the struct yaffs_dev associated with
+ *         this superblock
+ * >> 2.6: sb->s_fs_info  points to the struct yaffs_dev associated with this
+ *         superblock
+ * >> inode->u.generic_ip points to the associated struct yaffs_obj.
+ */
+
+/*
+ * There are two variants of the VFS glue code. This variant should compile
+ * for any version of Linux.
+ */
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 10))
+#define YAFFS_COMPILE_BACKGROUND
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23))
+#define YAFFS_COMPILE_FREEZER
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28))
+#define YAFFS_COMPILE_EXPORTFS
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#define YAFFS_USE_SETATTR_COPY
+#define YAFFS_USE_TRUNCATE_SETSIZE
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#define YAFFS_HAS_EVICT_INODE
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+#define YAFFS_NEW_FOLLOW_LINK 1
+#else
+#define YAFFS_NEW_FOLLOW_LINK 0
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 39))
+#include <linux/smp_lock.h>
+#endif
+#include <linux/pagemap.h>
+#include <linux/mtd/mtd.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+#include <linux/namei.h>
+#endif
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+#include <linux/exportfs.h>
+#endif
+
+#ifdef YAFFS_COMPILE_BACKGROUND
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#endif
+#ifdef YAFFS_COMPILE_FREEZER
+#include <linux/freezer.h>
+#endif
+
+#include <asm/div64.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+#include <linux/statfs.h>
+
+#define UnlockPage(p) unlock_page(p)
+#define Page_Uptodate(page)	test_bit(PG_uptodate, &(page)->flags)
+
+/* FIXME: use sb->s_id instead ? */
+#define yaffs_devname(sb, buf)	bdevname(sb->s_bdev, buf)
+
+#else
+
+#include <linux/locks.h>
+#define	BDEVNAME_SIZE		0
+#define	yaffs_devname(sb, buf)	kdevname(sb->s_dev)
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0))
+/* added NCB 26/5/2006 for 2.4.25-vrs2-tcl1 kernel */
+#define __user
+#endif
+
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define YPROC_ROOT  (&proc_root)
+#else
+#define YPROC_ROOT  NULL
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define Y_INIT_TIMER(a)	init_timer(a)
+#else
+#define Y_INIT_TIMER(a)	init_timer_on_stack(a)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+#define WRITE_SIZE_STR "writesize"
+#define WRITE_SIZE(mtd) ((mtd)->writesize)
+#else
+#define WRITE_SIZE_STR "oobblock"
+#define WRITE_SIZE(mtd) ((mtd)->oobblock)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27))
+#define YAFFS_USE_WRITE_BEGIN_END 1
+#else
+#define YAFFS_USE_WRITE_BEGIN_END 0
+#endif
+
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
+#define set_nlink(inode, count)  do { (inode)->i_nlink = (count); } while(0)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 28))
+static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
+{
+	uint64_t result = partition_size;
+	do_div(result, block_size);
+	return (uint32_t) result;
+}
+#else
+#define YCALCBLOCKS(s, b) ((s)/(b))
+#endif
+
+#include <linux/uaccess.h>
+#include <linux/mtd/mtd.h>
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+#include "yaffs_attribs.h"
+
+#include "yaffs_linux.h"
+
+#include "yaffs_mtdif.h"
+#include "yaffs_mtdif1.h"
+#include "yaffs_mtdif2.h"
+
+unsigned int yaffs_trace_mask = YAFFS_TRACE_BAD_BLOCKS | YAFFS_TRACE_ALWAYS;
+unsigned int yaffs_wr_attempts = YAFFS_WR_ATTEMPTS;
+unsigned int yaffs_auto_checkpoint = 1;
+unsigned int yaffs_gc_control = 1;
+unsigned int yaffs_bg_enable = 1;
+unsigned int yaffs_auto_select = 1;
+/* Module Parameters */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+module_param(yaffs_trace_mask, uint, 0644);
+module_param(yaffs_wr_attempts, uint, 0644);
+module_param(yaffs_auto_checkpoint, uint, 0644);
+module_param(yaffs_gc_control, uint, 0644);
+module_param(yaffs_bg_enable, uint, 0644);
+#else
+MODULE_PARM(yaffs_trace_mask, "i");
+MODULE_PARM(yaffs_wr_attempts, "i");
+MODULE_PARM(yaffs_auto_checkpoint, "i");
+MODULE_PARM(yaffs_gc_control, "i");
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+/* use iget and read_inode */
+#define Y_IGET(sb, inum) iget((sb), (inum))
+static void yaffs_read_inode(struct inode *inode);
+
+#else
+/* Call local equivalent */
+#define YAFFS_USE_OWN_IGET
+#define Y_IGET(sb, inum) yaffs_iget((sb), (inum))
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino);
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+#define yaffs_inode_to_obj_lv(iptr) ((iptr)->i_private)
+#else
+#define yaffs_inode_to_obj_lv(iptr) ((iptr)->u.generic_ip)
+#endif
+
+#define yaffs_inode_to_obj(iptr) \
+	((struct yaffs_obj *)(yaffs_inode_to_obj_lv(iptr)))
+#define yaffs_dentry_to_obj(dptr) yaffs_inode_to_obj((dptr)->d_inode)
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+#define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->s_fs_info)
+#else
+#define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->u.generic_sbp)
+#endif
+
+#define update_dir_time(dir) do {\
+			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
+		} while (0)
+
+static void yaffs_put_super(struct super_block *sb);
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t *pos);
+static ssize_t yaffs_hold_space(struct file *f);
+static void yaffs_release_space(struct file *f);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id);
+#else
+static int yaffs_file_flush(struct file *file);
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static int yaffs_sync_object(struct file *file, loff_t start, loff_t end, int datasync);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+static int yaffs_sync_object(struct file *file, int datasync);
+#else
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+			     int datasync);
+#endif
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n);
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *n);
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode);
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry);
+#endif
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+		      struct dentry *dentry);
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry);
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			 const char *symname);
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       dev_t dev);
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       int dev);
+#endif
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry);
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_sync_fs(struct super_block *sb, int wait);
+static void yaffs_write_super(struct super_block *sb);
+#else
+static int yaffs_sync_fs(struct super_block *sb);
+static int yaffs_write_super(struct super_block *sb);
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf);
+#endif
+
+#ifdef YAFFS_HAS_PUT_INODE
+static void yaffs_put_inode(struct inode *inode);
+#endif
+
+#ifdef YAFFS_HAS_EVICT_INODE
+static void yaffs_evict_inode(struct inode *);
+#else
+static void yaffs_delete_inode(struct inode *);
+static void yaffs_clear_inode(struct inode *);
+#endif
+
+static int yaffs_readpage(struct file *file, struct page *page);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc);
+#else
+static int yaffs_writepage(struct page *page);
+#endif
+
+static int yaffs_setxattr(struct dentry *dentry, const char *name,
+		   const void *value, size_t size, int flags);
+static ssize_t yaffs_getxattr(struct dentry *dentry, const char *name,
+				void *buff, size_t size);
+static int yaffs_removexattr(struct dentry *dentry, const char *name);
+static ssize_t yaffs_listxattr(struct dentry *dentry, char *buff, size_t size);
+
+#if (YAFFS_USE_WRITE_BEGIN_END != 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+			     loff_t pos, unsigned len, unsigned flags,
+			     struct page **pagep, void **fsdata);
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata);
+#else
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+			       unsigned offset, unsigned to);
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+			      unsigned to);
+
+#endif
+
+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
+			  int buflen);
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias);
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+#endif
+
+static void yaffs_touch_super(struct yaffs_dev *dev);
+
+static int yaffs_vfs_setattr(struct inode *, struct iattr *);
+
+static struct address_space_operations yaffs_file_address_operations = {
+	.readpage = yaffs_readpage,
+	.writepage = yaffs_writepage,
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+	.write_begin = yaffs_write_begin,
+	.write_end = yaffs_write_end,
+#else
+	.prepare_write = yaffs_prepare_write,
+	.commit_write = yaffs_commit_write,
+#endif
+};
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.splice_read = generic_file_splice_read,
+	.splice_write = generic_file_splice_write,
+	.llseek = generic_file_llseek,
+};
+
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.sendfile = generic_file_sendfile,
+};
+
+#else
+
+static const struct file_operations yaffs_file_operations = {
+	.read = generic_file_read,
+	.write = generic_file_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	.sendfile = generic_file_sendfile,
+#endif
+};
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+static void zero_user_segment(struct page *page, unsigned start, unsigned end)
+{
+	void *kaddr = kmap_atomic(page, KM_USER0);
+	memset(kaddr + start, 0, end - start);
+	kunmap_atomic(kaddr, KM_USER0);
+	flush_dcache_page(page);
+}
+#endif
+
+static const struct inode_operations yaffs_file_inode_operations = {
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+static const struct inode_operations yaffs_symlink_inode_operations = {
+	.readlink = yaffs_readlink,
+	.follow_link = yaffs_follow_link,
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+	.put_link = yaffs_put_link,
+#endif
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+static const struct inode_operations yaffs_dir_inode_operations = {
+	.create = yaffs_create,
+	.lookup = yaffs_lookup,
+	.link = yaffs_link,
+	.unlink = yaffs_unlink,
+	.symlink = yaffs_symlink,
+	.mkdir = yaffs_mkdir,
+	.rmdir = yaffs_unlink,
+	.mknod = yaffs_mknod,
+	.rename = yaffs_rename,
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+static const struct file_operations yaffs_dir_operations = {
+	.read = generic_read_dir,
+	.readdir = yaffs_readdir,
+	.fsync = yaffs_sync_object,
+	.llseek = generic_file_llseek,
+};
+
+static const struct super_operations yaffs_super_ops = {
+	.statfs = yaffs_statfs,
+
+#ifndef YAFFS_USE_OWN_IGET
+	.read_inode = yaffs_read_inode,
+#endif
+#ifdef YAFFS_HAS_PUT_INODE
+	.put_inode = yaffs_put_inode,
+#endif
+	.put_super = yaffs_put_super,
+#ifdef YAFFS_HAS_EVICT_INODE
+	.evict_inode = yaffs_evict_inode,
+#else
+	.delete_inode = yaffs_delete_inode,
+	.clear_inode = yaffs_clear_inode,
+#endif
+	.sync_fs = yaffs_sync_fs,
+	.write_super = yaffs_write_super,
+};
+
+static int yaffs_vfs_setattr(struct inode *inode, struct iattr *attr)
+{
+#ifdef YAFFS_USE_SETATTR_COPY
+	setattr_copy(inode, attr);
+	return 0;
+#else
+	return inode_setattr(inode, attr);
+#endif
+
+}
+
+static int yaffs_vfs_setsize(struct inode *inode, loff_t newsize)
+{
+#ifdef YAFFS_USE_TRUNCATE_SETSIZE
+	truncate_setsize(inode, newsize);
+	return 0;
+#else
+	truncate_inode_pages(&inode->i_data, newsize);
+	return 0;
+#endif
+
+}
+
+static unsigned yaffs_gc_control_callback(struct yaffs_dev *dev)
+{
+	return yaffs_gc_control;
+}
+
+static void yaffs_gross_lock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locking %p", current);
+	mutex_lock(&(yaffs_dev_to_lc(dev)->gross_lock));
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locked %p", current);
+}
+
+static void yaffs_gross_unlock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs unlocking %p", current);
+	mutex_unlock(&(yaffs_dev_to_lc(dev)->gross_lock));
+}
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+
+static struct inode *yaffs2_nfs_get_inode(struct super_block *sb, uint64_t ino,
+					  uint32_t generation)
+{
+	return Y_IGET(sb, ino);
+}
+
+static struct dentry *yaffs2_fh_to_dentry(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+static struct dentry *yaffs2_fh_to_parent(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+struct dentry *yaffs2_get_parent(struct dentry *dentry)
+{
+
+	struct super_block *sb = dentry->d_inode->i_sb;
+	struct dentry *parent = ERR_PTR(-ENOENT);
+	struct inode *inode;
+	unsigned long parent_ino;
+	struct yaffs_obj *d_obj;
+	struct yaffs_obj *parent_obj;
+
+	d_obj = yaffs_inode_to_obj(dentry->d_inode);
+
+	if (d_obj) {
+		parent_obj = d_obj->parent;
+		if (parent_obj) {
+			parent_ino = yaffs_get_obj_inode(parent_obj);
+			inode = Y_IGET(sb, parent_ino);
+
+			if (IS_ERR(inode)) {
+				parent = ERR_CAST(inode);
+			} else {
+				parent = d_obtain_alias(inode);
+				if (!IS_ERR(parent)) {
+					parent = ERR_PTR(-ENOMEM);
+					iput(inode);
+				}
+			}
+		}
+	}
+
+	return parent;
+}
+
+/* Just declare a zero structure as a NULL value implies
+ * using the default functions of exportfs.
+ */
+
+static struct export_operations yaffs_export_ops = {
+	.fh_to_dentry = yaffs2_fh_to_dentry,
+	.fh_to_parent = yaffs2_fh_to_parent,
+	.get_parent = yaffs2_get_parent,
+};
+
+#endif
+
+/*-----------------------------------------------------------------*/
+/* Directory search context allows us to unlock access to yaffs during
+ * filldir without causing problems with the directory being modified.
+ * This is similar to the tried and tested mechanism used in yaffs direct.
+ *
+ * A search context iterates along a doubly linked list of siblings in the
+ * directory. If the iterating object is deleted then this would corrupt
+ * the list iteration, likely causing a crash. The search context avoids
+ * this by using the remove_obj_fn to move the search context to the
+ * next object before the object is deleted.
+ *
+ * Many readdirs (and thus seach conexts) may be alive simulateously so
+ * each struct yaffs_dev has a list of these.
+ *
+ * A seach context lives for the duration of a readdir.
+ *
+ * All these functions must be called while yaffs is locked.
+ */
+
+struct yaffs_search_context {
+	struct yaffs_dev *dev;
+	struct yaffs_obj *dir_obj;
+	struct yaffs_obj *next_return;
+	struct list_head others;
+};
+
+/*
+ * yaffs_new_search() creates a new search context, initialises it and
+ * adds it to the device's search context list.
+ *
+ * Called at start of readdir.
+ */
+static struct yaffs_search_context *yaffs_new_search(struct yaffs_obj *dir)
+{
+	struct yaffs_dev *dev = dir->my_dev;
+	struct yaffs_search_context *sc =
+	    kmalloc(sizeof(struct yaffs_search_context), GFP_NOFS);
+	if (sc) {
+		sc->dir_obj = dir;
+		sc->dev = dev;
+		if (list_empty(&sc->dir_obj->variant.dir_variant.children))
+			sc->next_return = NULL;
+		else
+			sc->next_return =
+			    list_entry(dir->variant.dir_variant.children.next,
+				       struct yaffs_obj, siblings);
+		INIT_LIST_HEAD(&sc->others);
+		list_add(&sc->others, &(yaffs_dev_to_lc(dev)->search_contexts));
+	}
+	return sc;
+}
+
+/*
+ * yaffs_search_end() disposes of a search context and cleans up.
+ */
+static void yaffs_search_end(struct yaffs_search_context *sc)
+{
+	if (sc) {
+		list_del(&sc->others);
+		kfree(sc);
+	}
+}
+
+/*
+ * yaffs_search_advance() moves a search context to the next object.
+ * Called when the search iterates or when an object removal causes
+ * the search context to be moved to the next object.
+ */
+static void yaffs_search_advance(struct yaffs_search_context *sc)
+{
+	if (!sc)
+		return;
+
+	if (sc->next_return == NULL ||
+	    list_empty(&sc->dir_obj->variant.dir_variant.children))
+		sc->next_return = NULL;
+	else {
+		struct list_head *next = sc->next_return->siblings.next;
+
+		if (next == &sc->dir_obj->variant.dir_variant.children)
+			sc->next_return = NULL;	/* end of list */
+		else
+			sc->next_return =
+			    list_entry(next, struct yaffs_obj, siblings);
+	}
+}
+
+/*
+ * yaffs_remove_obj_callback() is called when an object is unlinked.
+ * We check open search contexts and advance any which are currently
+ * on the object being iterated.
+ */
+static void yaffs_remove_obj_callback(struct yaffs_obj *obj)
+{
+
+	struct list_head *i;
+	struct yaffs_search_context *sc;
+	struct list_head *search_contexts =
+	    &(yaffs_dev_to_lc(obj->my_dev)->search_contexts);
+
+	/* Iterate through the directory search contexts.
+	 * If any are currently on the object being removed, then advance
+	 * the search context to the next object to prevent a hanging pointer.
+	 */
+	list_for_each(i, search_contexts) {
+		sc = list_entry(i, struct yaffs_search_context, others);
+		if (sc->next_return == obj)
+			yaffs_search_advance(sc);
+	}
+
+}
+
+/*-----------------------------------------------------------------*/
+
+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
+			  int buflen)
+{
+	unsigned char *alias;
+	int ret;
+
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+
+	yaffs_gross_unlock(dev);
+
+	if (!alias)
+		return -ENOMEM;
+
+	ret = vfs_readlink(dentry, buffer, buflen, alias);
+	kfree(alias);
+	return ret;
+}
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	void *ret;
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	int ret
+#endif
+	unsigned char *alias;
+	int ret_int = 0;
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+	yaffs_gross_unlock(dev);
+
+	if (!alias) {
+		ret_int = -ENOMEM;
+		goto out;
+	}
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+	nd_set_link(nd, alias);
+	ret = alias;
+out:
+	if (ret_int)
+		ret = ERR_PTR(ret_int);
+	return ret;
+#else
+	ret = vfs_follow_link(nd, alias);
+	kfree(alias);
+out:
+	if (ret_int)
+		ret = ret_int;
+	return ret;
+#endif
+}
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias)
+{
+	kfree(alias);
+}
+#endif
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+			      struct yaffs_obj *obj);
+
+/*
+ * Lookup is used to find objects in the fs
+ */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *n)
+#else
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)
+#endif
+{
+	struct yaffs_obj *obj;
+	struct inode *inode = NULL;	/* NCB 2.5/2.6 needs NULL here */
+
+	struct yaffs_dev *dev = yaffs_inode_to_obj(dir)->my_dev;
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup for %d:%s",
+		yaffs_inode_to_obj(dir)->obj_id, dentry->d_name.name);
+
+	obj = yaffs_find_by_name(yaffs_inode_to_obj(dir), dentry->d_name.name);
+
+	obj = yaffs_get_equivalent_obj(obj);	/* in case it was a hardlink */
+
+	/* Can't hold gross lock when calling yaffs_get_inode() */
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_unlock(dev);
+
+	if (obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_lookup found %d", obj->obj_id);
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup not found");
+
+	}
+
+/* added NCB for 2.5/6 compatability - forces add even if inode is
+ * NULL which creates dentry hash */
+	d_add(dentry, inode);
+
+	return NULL;
+}
+
+#ifdef YAFFS_HAS_PUT_INODE
+
+/* For now put inode is just for debugging
+ * Put inode is called when the inode **structure** is put.
+ */
+static void yaffs_put_inode(struct inode *inode)
+{
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_put_inode: ino %d, count %d"),
+		(int)inode->i_ino, atomic_read(&inode->i_count);
+
+}
+#endif
+
+static void yaffs_unstitch_obj(struct inode *inode, struct yaffs_obj *obj)
+{
+	/* Clear the association between the inode and
+	 * the struct yaffs_obj.
+	 */
+	obj->my_inode = NULL;
+	yaffs_inode_to_obj_lv(inode) = NULL;
+
+	/* If the object freeing was deferred, then the real
+	 * free happens now.
+	 * This should fix the inode inconsistency problem.
+	 */
+	yaffs_handle_defered_free(obj);
+}
+
+#ifdef YAFFS_HAS_EVICT_INODE
+/* yaffs_evict_inode combines into one operation what was previously done in
+ * yaffs_clear_inode() and yaffs_delete_inode()
+ *
+ */
+static void yaffs_evict_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	int deleteme = 0;
+
+	obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_evict_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (!inode->i_nlink && !is_bad_inode(inode))
+		deleteme = 1;
+	truncate_inode_pages(&inode->i_data, 0);
+	end_writeback(inode);
+
+	if (deleteme && obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
+	}
+}
+#else
+
+/* clear is called to tell the fs to release any per-inode data it holds.
+ * The object might still exist on disk and is just being thrown out of the cache
+ * or else the object has actually been deleted and we're being called via
+ * the chain
+ *   yaffs_delete_inode() -> clear_inode()->yaffs_clear_inode()
+ */
+
+static void yaffs_clear_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_clear_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
+	}
+
+}
+
+/* delete is called when the link count is zero and the inode
+ * is put (ie. nobody wants to know about it anymore, time to
+ * delete the file).
+ * NB Must call clear_inode()
+ */
+static void yaffs_delete_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_delete_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+	truncate_inode_pages(&inode->i_data, 0);
+#endif
+	clear_inode(inode);
+}
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id)
+#else
+static int yaffs_file_flush(struct file *file)
+#endif
+{
+	struct yaffs_obj *obj = yaffs_dentry_to_obj(file->f_dentry);
+
+	struct yaffs_dev *dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_flush object %d (%s)",
+		obj->obj_id,
+		obj->dirty ? "dirty" : "clean");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_file(obj, 1, 0);
+
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+static int yaffs_readpage_nolock(struct file *f, struct page *pg)
+{
+	/* Lifted from jffs2 */
+
+	struct yaffs_obj *obj;
+	unsigned char *pg_buf;
+	int ret;
+	loff_t pos = ((loff_t) pg->index) << PAGE_CACHE_SHIFT;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readpage_nolock at %lld, size %08x",
+		(long long)pos,
+		(unsigned)PAGE_CACHE_SIZE);
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	BUG_ON(!PageLocked(pg));
+#else
+	if (!PageLocked(pg))
+		PAGE_BUG(pg);
+#endif
+
+	pg_buf = kmap(pg);
+	/* FIXME: Can kmap fail? */
+
+	yaffs_gross_lock(dev);
+
+	ret = yaffs_file_rd(obj, pg_buf, pos, PAGE_CACHE_SIZE);
+
+	yaffs_gross_unlock(dev);
+
+	if (ret >= 0)
+		ret = 0;
+
+	if (ret) {
+		ClearPageUptodate(pg);
+		SetPageError(pg);
+	} else {
+		SetPageUptodate(pg);
+		ClearPageError(pg);
+	}
+
+	flush_dcache_page(pg);
+	kunmap(pg);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage_nolock done");
+	return ret;
+}
+
+static int yaffs_readpage_unlock(struct file *f, struct page *pg)
+{
+	int ret = yaffs_readpage_nolock(f, pg);
+	UnlockPage(pg);
+	return ret;
+}
+
+static int yaffs_readpage(struct file *f, struct page *pg)
+{
+	int ret;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage");
+	ret = yaffs_readpage_unlock(f, pg);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage done");
+	return ret;
+}
+
+/* writepage inspired by/stolen from smbfs */
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc)
+#else
+static int yaffs_writepage(struct page *page)
+#endif
+{
+	struct yaffs_dev *dev;
+	struct address_space *mapping = page->mapping;
+	struct inode *inode;
+	unsigned long end_index;
+	char *buffer;
+	struct yaffs_obj *obj;
+	int n_written = 0;
+	unsigned n_bytes;
+	loff_t i_size;
+
+	if (!mapping)
+		BUG();
+	inode = mapping->host;
+	if (!inode)
+		BUG();
+	i_size = i_size_read(inode);
+
+	end_index = i_size >> PAGE_CACHE_SHIFT;
+
+	if (page->index < end_index)
+		n_bytes = PAGE_CACHE_SIZE;
+	else {
+		n_bytes = i_size & (PAGE_CACHE_SIZE - 1);
+
+		if (page->index > end_index || !n_bytes) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_writepage at %lld, inode size = %lld!!",
+				((loff_t)page->index) << PAGE_CACHE_SHIFT,
+				inode->i_size);
+			yaffs_trace(YAFFS_TRACE_OS,
+				"                -> don't care!!");
+
+			zero_user_segment(page, 0, PAGE_CACHE_SIZE);
+			set_page_writeback(page);
+			unlock_page(page);
+			end_page_writeback(page);
+			return 0;
+		}
+	}
+
+	if (n_bytes != PAGE_CACHE_SIZE)
+		zero_user_segment(page, n_bytes, PAGE_CACHE_SIZE);
+
+	get_page(page);
+
+	buffer = kmap(page);
+
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_writepage at %lld, size %08x",
+		((loff_t)page->index) << PAGE_CACHE_SHIFT, n_bytes);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag0: obj = %lld, ino = %lld",
+		obj->variant.file_variant.file_size, inode->i_size);
+
+	n_written = yaffs_wr_file(obj, buffer,
+				  ((loff_t)page->index) << PAGE_CACHE_SHIFT, n_bytes, 0);
+
+	yaffs_touch_super(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag1: obj = %lld, ino = %lld",
+		obj->variant.file_variant.file_size, inode->i_size);
+
+	yaffs_gross_unlock(dev);
+
+	kunmap(page);
+	set_page_writeback(page);
+	unlock_page(page);
+	end_page_writeback(page);
+	put_page(page);
+
+	return (n_written == n_bytes) ? 0 : -ENOSPC;
+}
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+			     loff_t pos, unsigned len, unsigned flags,
+			     struct page **pagep, void **fsdata)
+{
+	struct page *pg = NULL;
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+
+	int ret = 0;
+	int space_held = 0;
+
+	/* Get a page */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+	pg = grab_cache_page_write_begin(mapping, index, flags);
+#else
+	pg = __grab_cache_page(mapping, index);
+#endif
+
+	*pagep = pg;
+	if (!pg) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"start yaffs_write_begin index %d(%x) uptodate %d",
+		(int)index, (int)index, Page_Uptodate(pg) ? 1 : 0);
+
+	/* Get fs space */
+	space_held = yaffs_hold_space(filp);
+
+	if (!space_held) {
+		ret = -ENOSPC;
+		goto out;
+	}
+
+	/* Update page if required */
+
+	if (!Page_Uptodate(pg))
+		ret = yaffs_readpage_nolock(filp, pg);
+
+	if (ret)
+		goto out;
+
+	/* Happy path return */
+	yaffs_trace(YAFFS_TRACE_OS, "end yaffs_write_begin - ok");
+
+	return 0;
+
+out:
+	yaffs_trace(YAFFS_TRACE_OS,
+		"end yaffs_write_begin fail returning %d", ret);
+	if (space_held)
+		yaffs_release_space(filp);
+	if (pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
+	}
+	return ret;
+}
+
+#else
+
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+			       unsigned offset, unsigned to)
+{
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_prepair_write");
+
+	if (!Page_Uptodate(pg))
+		return yaffs_readpage_nolock(f, pg);
+	return 0;
+}
+#endif
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata)
+{
+	int ret = 0;
+	void *addr, *kva;
+	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
+
+	kva = kmap(pg);
+	addr = kva + offset_into_page;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_write_end addr %p pos %lld n_bytes %d",
+		addr, pos, copied);
+
+	ret = yaffs_file_write(filp, addr, copied, &pos);
+
+	if (ret != copied) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_write_end not same size ret %d  copied %d",
+			ret, copied);
+		SetPageError(pg);
+	}
+
+	kunmap(pg);
+
+	yaffs_release_space(filp);
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+#else
+
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+			      unsigned to)
+{
+	void *addr, *kva;
+
+	loff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;
+	int n_bytes = to - offset;
+	int n_written;
+
+	kva = kmap(pg);
+	addr = kva + offset;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_commit_write addr %p pos %lld n_bytes %d",
+		addr, pos, n_bytes);
+
+	n_written = yaffs_file_write(f, addr, n_bytes, &pos);
+
+	if (n_written != n_bytes) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_commit_write not same size n_written %d  n_bytes %d",
+			n_written, n_bytes);
+		SetPageError(pg);
+	}
+	kunmap(pg);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_commit_write returning %d",
+		n_written == n_bytes ? 0 : n_written);
+
+	return n_written == n_bytes ? 0 : n_written;
+}
+#endif
+
+static void yaffs_fill_inode_from_obj(struct inode *inode,
+				      struct yaffs_obj *obj)
+{
+	if (inode && obj) {
+
+		/* Check mode against the variant type and attempt to repair if broken. */
+		u32 mode = obj->yst_mode;
+		switch (obj->variant_type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			if (!S_ISREG(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFREG;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			if (!S_ISLNK(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFLNK;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			if (!S_ISDIR(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFDIR;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+		default:
+			/* TODO? */
+			break;
+		}
+
+		inode->i_flags |= S_NOATIME;
+
+		inode->i_ino = obj->obj_id;
+		inode->i_mode = obj->yst_mode;
+		inode->i_uid = obj->yst_uid;
+		inode->i_gid = obj->yst_gid;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+		inode->i_blksize = inode->i_sb->s_blocksize;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+		inode->i_rdev = old_decode_dev(obj->yst_rdev);
+		inode->i_atime.tv_sec = (time_t) (obj->yst_atime);
+		inode->i_atime.tv_nsec = 0;
+		inode->i_mtime.tv_sec = (time_t) obj->yst_mtime;
+		inode->i_mtime.tv_nsec = 0;
+		inode->i_ctime.tv_sec = (time_t) obj->yst_ctime;
+		inode->i_ctime.tv_nsec = 0;
+#else
+		inode->i_rdev = obj->yst_rdev;
+		inode->i_atime = obj->yst_atime;
+		inode->i_mtime = obj->yst_mtime;
+		inode->i_ctime = obj->yst_ctime;
+#endif
+		inode->i_size = yaffs_get_obj_length(obj);
+		inode->i_blocks = (inode->i_size + 511) >> 9;
+
+		set_nlink(inode, yaffs_get_obj_link_count(obj));
+
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_fill_inode mode %x uid %d gid %d size %lld count %d",
+			inode->i_mode, inode->i_uid, inode->i_gid,
+			inode->i_size, atomic_read(&inode->i_count));
+
+		switch (obj->yst_mode & S_IFMT) {
+		default:	/* fifo, device or socket */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+			init_special_inode(inode, obj->yst_mode,
+					   old_decode_dev(obj->yst_rdev));
+#else
+			init_special_inode(inode, obj->yst_mode,
+					   (dev_t) (obj->yst_rdev));
+#endif
+			break;
+		case S_IFREG:	/* file */
+			inode->i_op = &yaffs_file_inode_operations;
+			inode->i_fop = &yaffs_file_operations;
+			inode->i_mapping->a_ops =
+			    &yaffs_file_address_operations;
+			break;
+		case S_IFDIR:	/* directory */
+			inode->i_op = &yaffs_dir_inode_operations;
+			inode->i_fop = &yaffs_dir_operations;
+			break;
+		case S_IFLNK:	/* symlink */
+			inode->i_op = &yaffs_symlink_inode_operations;
+			break;
+		}
+
+		yaffs_inode_to_obj_lv(inode) = obj;
+
+		obj->my_inode = inode;
+
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_fill_inode invalid parameters");
+	}
+
+}
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+			      struct yaffs_obj *obj)
+{
+	struct inode *inode;
+
+	if (!sb) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL super_block!!");
+		return NULL;
+
+	}
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL object!!");
+		return NULL;
+
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_get_inode for object %d", obj->obj_id);
+
+	inode = Y_IGET(sb, obj->obj_id);
+	if (IS_ERR(inode))
+		return NULL;
+
+	/* NB Side effect: iget calls back to yaffs_read_inode(). */
+	/* iget also increments the inode's i_count */
+	/* NB You can't be holding gross_lock or deadlock will happen! */
+
+	return inode;
+}
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t * pos)
+{
+	struct yaffs_obj *obj;
+	int n_written;
+	loff_t ipos;
+	struct inode *inode;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_file_write: hey obj is null!");
+                return -EINVAL;
+        }
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	inode = f->f_dentry->d_inode;
+
+	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
+		ipos = inode->i_size;
+	else
+		ipos = *pos;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write about to write writing %u(%x) bytes to object %d at %lld",
+		(unsigned)n, (unsigned)n, obj->obj_id, ipos);
+
+	n_written = yaffs_wr_file(obj, buf, ipos, n, 0);
+
+	yaffs_touch_super(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write: %d(%x) bytes written",
+		(unsigned)n, (unsigned)n);
+
+	if (n_written > 0) {
+		ipos += n_written;
+		*pos = ipos;
+		if (ipos > inode->i_size) {
+			inode->i_size = ipos;
+			inode->i_blocks = (ipos + 511) >> 9;
+
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_file_write size updated to %lld bytes, %d blocks",
+				ipos, (int)(inode->i_blocks));
+		}
+
+	}
+	yaffs_gross_unlock(dev);
+	return (n_written == 0) && (n > 0) ? -ENOSPC : n_written;
+}
+
+/* Space holding and freeing is done to ensure we have space available for write_begin/end */
+/* For now we just assume few parallel writes and check against a small number. */
+/* Todo: need to do this with a counter to handle parallel reads better */
+
+static ssize_t yaffs_hold_space(struct file *f)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	int n_free_chunks;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	n_free_chunks = yaffs_get_n_free_chunks(dev);
+
+	yaffs_gross_unlock(dev);
+
+	return (n_free_chunks > 20) ? 1 : 0;
+}
+
+static void yaffs_release_space(struct file *f)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_gross_unlock(dev);
+}
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	struct yaffs_search_context *sc;
+	struct inode *inode = f->f_dentry->d_inode;
+	unsigned long offset, curoffs;
+	struct yaffs_obj *l;
+	int ret_val = 0;
+
+	char name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_dev_to_lc(dev)->readdir_process = current;
+
+	offset = f->f_pos;
+
+	sc = yaffs_new_search(obj);
+	if (!sc) {
+		ret_val = -ENOMEM;
+		goto out;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readdir: starting at %d", (int)offset);
+
+	if (offset == 0) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_readdir: entry . ino %d",
+			(int)inode->i_ino);
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, ".", 1, offset, inode->i_ino, DT_DIR) < 0) {
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+	if (offset == 1) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_readdir: entry .. ino %d",
+			(int)f->f_dentry->d_parent->d_inode->i_ino);
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, "..", 2, offset,
+			    f->f_dentry->d_parent->d_inode->i_ino,
+			    DT_DIR) < 0) {
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+
+	curoffs = 1;
+
+	/* If the directory has changed since the open or last call to
+	   readdir, rewind to after the 2 canned entries. */
+	if (f->f_version != inode->i_version) {
+		offset = 2;
+		f->f_pos = offset;
+		f->f_version = inode->i_version;
+	}
+
+	while (sc->next_return) {
+		curoffs++;
+		l = sc->next_return;
+		if (curoffs >= offset) {
+			int this_inode = yaffs_get_obj_inode(l);
+			int this_type = yaffs_get_obj_type(l);
+
+			yaffs_get_obj_name(l, name, YAFFS_MAX_NAME_LENGTH + 1);
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_readdir: %s inode %d",
+				name, yaffs_get_obj_inode(l));
+
+			yaffs_gross_unlock(dev);
+
+			if (filldir(dirent,
+				    name,
+				    strlen(name),
+				    offset, this_inode, this_type) < 0) {
+				yaffs_gross_lock(dev);
+				goto out;
+			}
+
+			yaffs_gross_lock(dev);
+
+			offset++;
+			f->f_pos++;
+		}
+		yaffs_search_advance(sc);
+	}
+
+out:
+	yaffs_search_end(sc);
+	yaffs_dev_to_lc(dev)->readdir_process = NULL;
+	yaffs_gross_unlock(dev);
+
+	return ret_val;
+}
+
+/*
+ * File creation. Allocate an inode, and we're done..
+ */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+#define YCRED(x) x
+#else
+#define YCRED(x) (x->cred)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       dev_t rdev)
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       int rdev)
+#endif
+{
+	struct inode *inode;
+
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_dev *dev;
+
+	struct yaffs_obj *parent = yaffs_inode_to_obj(dir);
+
+	int error = -ENOSPC;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+
+	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
+		mode |= S_ISGID;
+
+	if (parent) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: parent object %d type %d",
+			parent->obj_id, parent->variant_type);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: could not get parent object");
+		return -EPERM;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_mknod: making oject for %s, mode %x dev %x",
+		dentry->d_name.name, mode, rdev);
+
+	dev = parent->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	switch (mode & S_IFMT) {
+	default:
+		/* Special (socket, fifo, device...) */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making special");
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, old_encode_dev(rdev));
+#else
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, rdev);
+#endif
+		break;
+	case S_IFREG:		/* file          */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making file");
+		obj = yaffs_create_file(parent, dentry->d_name.name, mode, uid,
+					gid);
+		break;
+	case S_IFDIR:		/* directory */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making directory");
+		obj = yaffs_create_dir(parent, dentry->d_name.name, mode,
+				       uid, gid);
+		break;
+	case S_IFLNK:		/* symlink */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making symlink");
+		obj = NULL;	/* Do we ever get here? */
+		break;
+	}
+
+	/* Can not call yaffs_get_inode() with gross lock held */
+	yaffs_gross_unlock(dev);
+
+	if (obj) {
+		inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod created object %d count = %d",
+			obj->obj_id, atomic_read(&inode->i_count));
+		error = 0;
+		yaffs_fill_inode_from_obj(dir, parent);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod failed making object");
+		error = -ENOMEM;
+	}
+
+	return error;
+}
+
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	int ret_val;
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_mkdir");
+	ret_val = yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
+	return ret_val;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n)
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode)
+#endif
+{
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_create");
+	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
+}
+
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int ret_val;
+
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_unlink %d:%s",
+		(int)(dir->i_ino), dentry->d_name.name);
+	obj = yaffs_inode_to_obj(dir);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	ret_val = yaffs_unlinker(obj, dentry->d_name.name);
+
+	if (ret_val == YAFFS_OK) {
+		inode_dec_link_count(dentry->d_inode);
+		dir->i_version++;
+		yaffs_gross_unlock(dev);
+		update_dir_time(dir);
+		return 0;
+	}
+	yaffs_gross_unlock(dev);
+	return -ENOTEMPTY;
+}
+
+/*
+ * Create a link...
+ */
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+		      struct dentry *dentry)
+{
+	struct inode *inode = old_dentry->d_inode;
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_obj *link = NULL;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_link");
+
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	if (!S_ISDIR(inode->i_mode))	/* Don't link directories */
+		link =
+		    yaffs_link_obj(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   obj);
+
+	if (link) {
+		set_nlink(old_dentry->d_inode, yaffs_get_obj_link_count(obj));
+		d_instantiate(dentry, old_dentry->d_inode);
+		atomic_inc(&old_dentry->d_inode->i_count);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_link link count %d i_count %d",
+			old_dentry->d_inode->i_nlink,
+			atomic_read(&old_dentry->d_inode->i_count));
+	}
+
+	yaffs_gross_unlock(dev);
+
+	if (link) {
+		update_dir_time(dir);
+		return 0;
+	}
+
+	return -EPERM;
+}
+
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			 const char *symname)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_symlink");
+
+	if (strnlen(dentry->d_name.name, YAFFS_MAX_NAME_LENGTH + 1) >
+				YAFFS_MAX_NAME_LENGTH)
+		return -ENAMETOOLONG;
+
+	if (strnlen(symname, YAFFS_MAX_ALIAS_LENGTH + 1) >
+				YAFFS_MAX_ALIAS_LENGTH)
+		return -ENAMETOOLONG;
+
+	dev = yaffs_inode_to_obj(dir)->my_dev;
+	yaffs_gross_lock(dev);
+	obj = yaffs_create_symlink(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   S_IFLNK | S_IRWXUGO, uid, gid, symname);
+	yaffs_gross_unlock(dev);
+
+	if (obj) {
+		struct inode *inode;
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		yaffs_trace(YAFFS_TRACE_OS, "symlink created OK");
+		return 0;
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "symlink not created");
+	}
+
+	return -ENOMEM;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static int yaffs_sync_object(struct file *file, loff_t start, loff_t end, int datasync)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+static int yaffs_sync_object(struct file *file, int datasync)
+#else
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+			     int datasync)
+#endif
+{
+
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+	struct dentry *dentry = file->f_path.dentry;
+#endif
+
+	obj = yaffs_dentry_to_obj(dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		"yaffs_sync_object");
+	yaffs_gross_lock(dev);
+	yaffs_flush_file(obj, 1, datasync);
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+
+/*
+ * The VFS layer already does all the dentry stuff for rename.
+ *
+ * NB: POSIX says you can rename an object over an old object of the same name
+ */
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry)
+{
+	struct yaffs_dev *dev;
+	int ret_val = YAFFS_FAIL;
+	struct yaffs_obj *target;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_rename");
+	dev = yaffs_inode_to_obj(old_dir)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	/* Check if the target is an existing directory that is not empty. */
+	target = yaffs_find_by_name(yaffs_inode_to_obj(new_dir),
+				    new_dentry->d_name.name);
+
+	if (target && target->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY &&
+	    !list_empty(&target->variant.dir_variant.children)) {
+
+		yaffs_trace(YAFFS_TRACE_OS, "target is non-empty dir");
+
+		ret_val = YAFFS_FAIL;
+	} else {
+		/* Now does unlinking internally using shadowing mechanism */
+		yaffs_trace(YAFFS_TRACE_OS, "calling yaffs_rename_obj");
+
+		ret_val = yaffs_rename_obj(yaffs_inode_to_obj(old_dir),
+					   old_dentry->d_name.name,
+					   yaffs_inode_to_obj(new_dir),
+					   new_dentry->d_name.name);
+	}
+	yaffs_gross_unlock(dev);
+
+	if (ret_val == YAFFS_OK) {
+		if (target)
+			inode_dec_link_count(new_dentry->d_inode);
+
+		update_dir_time(old_dir);
+		if (old_dir != new_dir)
+			update_dir_time(new_dir);
+		return 0;
+	} else {
+		return -ENOTEMPTY;
+	}
+}
+
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_setattr of object %d",
+		yaffs_inode_to_obj(inode)->obj_id);
+#if 0
+	/* Fail if a requested resize >= 2GB */
+	if (attr->ia_valid & ATTR_SIZE && (attr->ia_size >> 31))
+		error = -EINVAL;
+#endif
+
+	if (error == 0)
+		error = inode_change_ok(inode, attr);
+	if (error == 0) {
+		int result;
+		if (!error) {
+			error = yaffs_vfs_setattr(inode, attr);
+			yaffs_trace(YAFFS_TRACE_OS, "inode_setattr called");
+			if (attr->ia_valid & ATTR_SIZE) {
+				yaffs_vfs_setsize(inode, attr->ia_size);
+				inode->i_blocks = (inode->i_size + 511) >> 9;
+			}
+		}
+		dev = yaffs_inode_to_obj(inode)->my_dev;
+		if (attr->ia_valid & ATTR_SIZE) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"resize to %d(%x)",
+				(int)(attr->ia_size),
+				(int)(attr->ia_size));
+		}
+		yaffs_gross_lock(dev);
+		result = yaffs_set_attribs(yaffs_inode_to_obj(inode), attr);
+		if (result == YAFFS_OK) {
+			error = 0;
+		} else {
+			error = -EPERM;
+		}
+		yaffs_gross_unlock(dev);
+
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setattr done returning %d", error);
+
+	return error;
+}
+
+static int yaffs_setxattr(struct dentry *dentry, const char *name,
+		   const void *value, size_t size, int flags)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		int result;
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		result = yaffs_set_xattrib(obj, name, value, size, flags);
+		if (result == YAFFS_OK)
+			error = 0;
+		else if (result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_getxattr(struct dentry * dentry, const char *name,
+			void *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_getxattr \"%s\" from object %d",
+		name, obj->obj_id);
+
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_get_xattrib(obj, name, buff, size);
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_getxattr done returning %d", error);
+
+	return error;
+}
+
+static int yaffs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		int result;
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		result = yaffs_remove_xattrib(obj, name);
+		if (result == YAFFS_OK)
+			error = 0;
+		else if (result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_listxattr(struct dentry * dentry, char *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_list_xattrib(obj, buff, size);
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr done returning %d", error);
+
+	return error;
+}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+	struct super_block *sb = dentry->d_sb;
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+#endif
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_statfs");
+
+	yaffs_gross_lock(dev);
+
+	buf->f_type = YAFFS_MAGIC;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_namelen = 255;
+
+	if (dev->data_bytes_per_chunk & (dev->data_bytes_per_chunk - 1)) {
+		/* Do this if chunk size is not a power of 2 */
+
+		uint64_t bytes_in_dev;
+		uint64_t bytes_free;
+
+		bytes_in_dev =
+		    ((uint64_t)
+		     ((dev->param.end_block - dev->param.start_block +
+		       1))) * ((uint64_t) (dev->param.chunks_per_block *
+					   dev->data_bytes_per_chunk));
+
+		do_div(bytes_in_dev, sb->s_blocksize);	/* bytes_in_dev becomes the number of blocks */
+		buf->f_blocks = bytes_in_dev;
+
+		bytes_free = ((uint64_t) (yaffs_get_n_free_chunks(dev))) *
+		    ((uint64_t) (dev->data_bytes_per_chunk));
+
+		do_div(bytes_free, sb->s_blocksize);
+
+		buf->f_bfree = bytes_free;
+
+	} else if (sb->s_blocksize > dev->data_bytes_per_chunk) {
+
+		buf->f_blocks =
+		    (dev->param.end_block - dev->param.start_block + 1) *
+		    dev->param.chunks_per_block /
+		    (sb->s_blocksize / dev->data_bytes_per_chunk);
+		buf->f_bfree =
+		    yaffs_get_n_free_chunks(dev) /
+		    (sb->s_blocksize / dev->data_bytes_per_chunk);
+	} else {
+		buf->f_blocks =
+		    (dev->param.end_block - dev->param.start_block + 1) *
+		    dev->param.chunks_per_block *
+		    (dev->data_bytes_per_chunk / sb->s_blocksize);
+
+		buf->f_bfree =
+		    yaffs_get_n_free_chunks(dev) *
+		    (dev->data_bytes_per_chunk / sb->s_blocksize);
+	}
+
+	buf->f_files = 0;
+	buf->f_ffree = 0;
+	buf->f_bavail = buf->f_bfree;
+
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+
+static void yaffs_flush_inodes(struct super_block *sb)
+{
+	struct inode *iptr;
+	struct yaffs_obj *obj;
+
+	list_for_each_entry(iptr, &sb->s_inodes, i_sb_list) {
+		obj = yaffs_inode_to_obj(iptr);
+		if (obj) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"flushing obj %d",
+				obj->obj_id);
+			yaffs_flush_file(obj, 1, 0);
+		}
+	}
+}
+
+static void yaffs_flush_super(struct super_block *sb, int do_checkpoint)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	if (!dev)
+		return;
+
+	yaffs_flush_inodes(sb);
+	yaffs_update_dirty_dirs(dev);
+	yaffs_flush_whole_cache(dev);
+	if (do_checkpoint)
+		yaffs_checkpoint_save(dev);
+}
+
+static unsigned yaffs_bg_gc_urgency(struct yaffs_dev *dev)
+{
+	unsigned erased_chunks =
+	    dev->n_erased_blocks * dev->param.chunks_per_block;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned scattered = 0;	/* Free chunks not in an erased block */
+
+	if (erased_chunks < dev->n_free_chunks)
+		scattered = (dev->n_free_chunks - erased_chunks);
+
+	if (!context->bg_running)
+		return 0;
+	else if (scattered < (dev->param.chunks_per_block * 2))
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 2)
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 4)
+		return 1;
+	else
+		return 2;
+}
+
+static int yaffs_do_sync_fs(struct super_block *sb, int request_checkpoint)
+{
+
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	unsigned int oneshot_checkpoint = (yaffs_auto_checkpoint & 4);
+	unsigned gc_urgent = yaffs_bg_gc_urgency(dev);
+	int do_checkpoint;
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		"yaffs_do_sync_fs: gc-urgency %d %s %s%s",
+		gc_urgent,
+		sb->s_dirt ? "dirty" : "clean",
+		request_checkpoint ? "checkpoint requested" : "no checkpoint",
+		oneshot_checkpoint ? " one-shot" : "");
+
+	yaffs_gross_lock(dev);
+	do_checkpoint = ((request_checkpoint && !gc_urgent) ||
+			 oneshot_checkpoint) && !dev->is_checkpointed;
+
+	if (sb->s_dirt || do_checkpoint) {
+		yaffs_flush_super(sb, !dev->is_checkpointed && do_checkpoint);
+		sb->s_dirt = 0;
+		if (oneshot_checkpoint)
+			yaffs_auto_checkpoint &= ~4;
+	}
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+/*
+ * yaffs background thread functions .
+ * yaffs_bg_thread_fn() the thread function
+ * yaffs_bg_start() launches the background thread.
+ * yaffs_bg_stop() cleans up the background thread.
+ *
+ * NB:
+ * The thread should only run after the yaffs is initialised
+ * The thread should be stopped before yaffs is unmounted.
+ * The thread should not do any writing while the fs is in read only.
+ */
+
+#ifdef YAFFS_COMPILE_BACKGROUND
+
+void yaffs_background_waker(unsigned long data)
+{
+	wake_up_process((struct task_struct *)data);
+}
+
+static int yaffs_bg_thread_fn(void *data)
+{
+	struct yaffs_dev *dev = (struct yaffs_dev *)data;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned long now = jiffies;
+	unsigned long next_dir_update = now;
+	unsigned long next_gc = now;
+	unsigned long expires;
+	unsigned int urgency;
+
+	int gc_result;
+	struct timer_list timer;
+
+	yaffs_trace(YAFFS_TRACE_BACKGROUND,
+		"yaffs_background starting for dev %p", (void *)dev);
+
+#ifdef YAFFS_COMPILE_FREEZER
+	set_freezable();
+#endif
+	while (context->bg_running) {
+		yaffs_trace(YAFFS_TRACE_BACKGROUND, "yaffs_background");
+
+		if (kthread_should_stop())
+			break;
+
+#ifdef YAFFS_COMPILE_FREEZER
+		if (try_to_freeze())
+			continue;
+#endif
+		yaffs_gross_lock(dev);
+
+		now = jiffies;
+
+		if (time_after(now, next_dir_update) && yaffs_bg_enable) {
+			yaffs_update_dirty_dirs(dev);
+			next_dir_update = now + HZ;
+		}
+
+		if (time_after(now, next_gc) && yaffs_bg_enable) {
+			if (!dev->is_checkpointed) {
+				urgency = yaffs_bg_gc_urgency(dev);
+				gc_result = yaffs_bg_gc(dev, urgency);
+				if (urgency > 1)
+					next_gc = now + HZ / 20 + 1;
+				else if (urgency > 0)
+					next_gc = now + HZ / 10 + 1;
+				else
+					next_gc = now + HZ * 2;
+			} else	{
+			        /*
+				 * gc not running so set to next_dir_update
+				 * to cut down on wake ups
+				 */
+				next_gc = next_dir_update;
+                        }
+		}
+		yaffs_gross_unlock(dev);
+#if 1
+		expires = next_dir_update;
+		if (time_before(next_gc, expires))
+			expires = next_gc;
+		if (time_before(expires, now))
+			expires = now + HZ;
+
+		Y_INIT_TIMER(&timer);
+		timer.expires = expires + 1;
+		timer.data = (unsigned long)current;
+		timer.function = yaffs_background_waker;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_timer(&timer);
+		schedule();
+		del_timer_sync(&timer);
+#else
+		msleep(10);
+#endif
+	}
+
+	return 0;
+}
+
+static int yaffs_bg_start(struct yaffs_dev *dev)
+{
+	int retval = 0;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+
+	if (dev->read_only)
+		return -1;
+
+	context->bg_running = 1;
+
+	context->bg_thread = kthread_run(yaffs_bg_thread_fn,
+					 (void *)dev, "yaffs-bg-%d",
+					 context->mount_id);
+
+	if (IS_ERR(context->bg_thread)) {
+		retval = PTR_ERR(context->bg_thread);
+		context->bg_thread = NULL;
+		context->bg_running = 0;
+	}
+	return retval;
+}
+
+static void yaffs_bg_stop(struct yaffs_dev *dev)
+{
+	struct yaffs_linux_context *ctxt = yaffs_dev_to_lc(dev);
+
+	ctxt->bg_running = 0;
+
+	if (ctxt->bg_thread) {
+		kthread_stop(ctxt->bg_thread);
+		ctxt->bg_thread = NULL;
+	}
+}
+#else
+static int yaffs_bg_thread_fn(void *data)
+{
+	return 0;
+}
+
+static int yaffs_bg_start(struct yaffs_dev *dev)
+{
+	return 0;
+}
+
+static void yaffs_bg_stop(struct yaffs_dev *dev)
+{
+}
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static void yaffs_write_super(struct super_block *sb)
+#else
+static int yaffs_write_super(struct super_block *sb)
+#endif
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 2);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		"yaffs_write_super %s",
+		request_checkpoint ? " checkpt" : "");
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+	return 0;
+#endif
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_sync_fs(struct super_block *sb, int wait)
+#else
+static int yaffs_sync_fs(struct super_block *sb)
+#endif
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 1);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		"yaffs_sync_fs%s", request_checkpoint ? " checkpt" : "");
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+	return 0;
+}
+
+#ifdef YAFFS_USE_OWN_IGET
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode;
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_iget for %lu", ino);
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	yaffs_gross_unlock(dev);
+
+	unlock_new_inode(inode);
+	return inode;
+}
+
+#else
+
+static void yaffs_read_inode(struct inode *inode)
+{
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(inode->i_sb);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_inode for %d", (int)inode->i_ino);
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_unlock(dev);
+}
+
+#endif
+
+static LIST_HEAD(yaffs_context_list);
+struct mutex yaffs_context_lock;
+
+static void yaffs_put_super(struct super_block *sb)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_put_super");
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"Shutting down yaffs background thread");
+	yaffs_bg_stop(dev);
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"yaffs background thread shut down");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_super(sb, 1);
+
+	if (yaffs_dev_to_lc(dev)->put_super_fn)
+		yaffs_dev_to_lc(dev)->put_super_fn(sb);
+
+	yaffs_deinitialise(dev);
+
+	yaffs_gross_unlock(dev);
+
+	mutex_lock(&yaffs_context_lock);
+	list_del_init(&(yaffs_dev_to_lc(dev)->context_list));
+	mutex_unlock(&yaffs_context_lock);
+
+	if (yaffs_dev_to_lc(dev)->spare_buffer) {
+		kfree(yaffs_dev_to_lc(dev)->spare_buffer);
+		yaffs_dev_to_lc(dev)->spare_buffer = NULL;
+	}
+
+	kfree(dev);
+}
+
+static void yaffs_mtd_put_super(struct super_block *sb)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(yaffs_super_to_dev(sb));
+
+	if (mtd->sync)
+		mtd->sync(mtd);
+
+	put_mtd_device(mtd);
+}
+
+static void yaffs_touch_super(struct yaffs_dev *dev)
+{
+	struct super_block *sb = yaffs_dev_to_lc(dev)->super;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_touch_super() sb = %p", sb);
+	if (sb)
+		sb->s_dirt = 1;
+}
+
+struct yaffs_options {
+	int inband_tags;
+	int skip_checkpoint_read;
+	int skip_checkpoint_write;
+	int no_cache;
+	int tags_ecc_on;
+	int tags_ecc_overridden;
+	int lazy_loading_enabled;
+	int lazy_loading_overridden;
+	int empty_lost_and_found;
+	int empty_lost_and_found_overridden;
+	int disable_summary;
+};
+
+#define MAX_OPT_LEN 30
+static int yaffs_parse_options(struct yaffs_options *options,
+			       const char *options_str)
+{
+	char cur_opt[MAX_OPT_LEN + 1];
+	int p;
+	int error = 0;
+
+	/* Parse through the options which is a comma seperated list */
+
+	while (options_str && *options_str && !error) {
+		memset(cur_opt, 0, MAX_OPT_LEN + 1);
+		p = 0;
+
+		while (*options_str == ',')
+			options_str++;
+
+		while (*options_str && *options_str != ',') {
+			if (p < MAX_OPT_LEN) {
+				cur_opt[p] = *options_str;
+				p++;
+			}
+			options_str++;
+		}
+
+		if (!strcmp(cur_opt, "inband-tags")) {
+			options->inband_tags = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-off")) {
+			options->tags_ecc_on = 0;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-on")) {
+			options->tags_ecc_on = 1;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-off")) {
+			options->lazy_loading_enabled = 0;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-on")) {
+			options->lazy_loading_enabled = 1;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "disable-summary")) {
+			options->disable_summary = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-off")) {
+			options->empty_lost_and_found = 0;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-on")) {
+			options->empty_lost_and_found = 1;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "no-cache")) {
+			options->no_cache = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-read")) {
+			options->skip_checkpoint_read = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-write")) {
+			options->skip_checkpoint_write = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint")) {
+			options->skip_checkpoint_read = 1;
+			options->skip_checkpoint_write = 1;
+		} else {
+			printk(KERN_INFO "yaffs: Bad mount option \"%s\"\n",
+			       cur_opt);
+			error = 1;
+		}
+	}
+
+	return error;
+}
+
+static struct super_block *yaffs_internal_read_super(int yaffs_version,
+						     struct super_block *sb,
+						     void *data, int silent)
+{
+	int n_blocks;
+	struct inode *inode = NULL;
+	struct dentry *root;
+	struct yaffs_dev *dev = 0;
+	char devname_buf[BDEVNAME_SIZE + 1];
+	struct mtd_info *mtd;
+	int err;
+	char *data_str = (char *)data;
+	struct yaffs_linux_context *context = NULL;
+	struct yaffs_param *param;
+
+	int read_only = 0;
+
+	struct yaffs_options options;
+
+	unsigned mount_id;
+	int found;
+	struct yaffs_linux_context *context_iterator;
+	struct list_head *l;
+
+	if (!sb) {
+		printk(KERN_INFO "yaffs: sb is NULL\n");
+		return NULL;
+        }
+
+	sb->s_magic = YAFFS_MAGIC;
+	sb->s_op = &yaffs_super_ops;
+	sb->s_flags |= MS_NOATIME;
+
+	read_only = ((sb->s_flags & MS_RDONLY) != 0);
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+	sb->s_export_op = &yaffs_export_ops;
+#endif
+
+	if (!sb->s_dev)
+		printk(KERN_INFO "yaffs: sb->s_dev is NULL\n");
+	else if (!yaffs_devname(sb, devname_buf))
+		printk(KERN_INFO "yaffs: devname is NULL\n");
+	else
+		printk(KERN_INFO "yaffs: dev is %d name is \"%s\" %s\n",
+		       sb->s_dev,
+		       yaffs_devname(sb, devname_buf), read_only ? "ro" : "rw");
+
+	if (!data_str)
+		data_str = "";
+
+	printk(KERN_INFO "yaffs: passed flags \"%s\"\n", data_str);
+
+	memset(&options, 0, sizeof(options));
+
+	if (yaffs_parse_options(&options, data_str)) {
+		/* Option parsing failed */
+		return NULL;
+	}
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: Using yaffs%d", yaffs_version);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: block size %d", (int)(sb->s_blocksize));
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs: Attempting MTD mount of %u.%u,\"%s\"",
+		MAJOR(sb->s_dev), MINOR(sb->s_dev),
+		yaffs_devname(sb, devname_buf));
+
+	/* Check it's an mtd device..... */
+	if (MAJOR(sb->s_dev) != MTD_BLOCK_MAJOR)
+		return NULL;	/* This isn't an mtd device */
+
+	/* Get the device */
+	mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
+	if (!mtd) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs: MTD device #%u doesn't appear to exist",
+			MINOR(sb->s_dev));
+		return NULL;
+	}
+	/* Check it's NAND */
+	if (mtd->type != MTD_NANDFLASH) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs: MTD device is not NAND it's type %d",
+			mtd->type);
+		return NULL;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, " erase %p", mtd->erase);
+	yaffs_trace(YAFFS_TRACE_OS, " read %p", mtd->read);
+	yaffs_trace(YAFFS_TRACE_OS, " write %p", mtd->write);
+	yaffs_trace(YAFFS_TRACE_OS, " readoob %p", mtd->read_oob);
+	yaffs_trace(YAFFS_TRACE_OS, " writeoob %p", mtd->write_oob);
+	yaffs_trace(YAFFS_TRACE_OS, " block_isbad %p", mtd->block_isbad);
+	yaffs_trace(YAFFS_TRACE_OS, " block_markbad %p", mtd->block_markbad);
+	yaffs_trace(YAFFS_TRACE_OS, " %s %d", WRITE_SIZE_STR, WRITE_SIZE(mtd));
+	yaffs_trace(YAFFS_TRACE_OS, " oobsize %d", mtd->oobsize);
+	yaffs_trace(YAFFS_TRACE_OS, " erasesize %d", mtd->erasesize);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+	yaffs_trace(YAFFS_TRACE_OS, " size %u", mtd->size);
+#else
+	yaffs_trace(YAFFS_TRACE_OS, " size %lld", mtd->size);
+#endif
+
+	if (yaffs_auto_select && yaffs_version == 1 && WRITE_SIZE(mtd) >= 2048) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs2");
+		yaffs_version = 2;
+	}
+
+	/* Added NCB 26/5/2006 for completeness */
+	if (yaffs_version == 2 && !options.inband_tags
+	    && WRITE_SIZE(mtd) == 512) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs1");
+		yaffs_version = 1;
+	}
+
+	if (yaffs_version == 2) {
+		/* Check for version 2 style functions */
+		if (!mtd->erase ||
+		    !mtd->block_isbad ||
+		    !mtd->block_markbad || !mtd->read || !mtd->write ||
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		    !mtd->read_oob || !mtd->write_oob) {
+#else
+		    !mtd->write_ecc ||
+		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+#endif
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support required functions"
+			);
+			return NULL;
+		}
+
+		if ((WRITE_SIZE(mtd) < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||
+		     mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&
+		    !options.inband_tags) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not have the right page sizes"
+			);
+			return NULL;
+		}
+	} else {
+		/* Check for V1 style functions */
+		if (!mtd->erase || !mtd->read || !mtd->write ||
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		    !mtd->read_oob || !mtd->write_oob) {
+#else
+		    !mtd->write_ecc ||
+		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+#endif
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support required functions"
+			);
+			return NULL;
+		}
+
+		if (WRITE_SIZE(mtd) < YAFFS_BYTES_PER_CHUNK ||
+		    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support have the right page sizes"
+			);
+			return NULL;
+		}
+	}
+
+	/* OK, so if we got here, we have an MTD that's NAND and looks
+	 * like it has the right capabilities
+	 * Set the struct yaffs_dev up for mtd
+	 */
+
+	if (!read_only && !(mtd->flags & MTD_WRITEABLE)) {
+		read_only = 1;
+		printk(KERN_INFO
+		       "yaffs: mtd is read only, setting superblock read only\n"
+		);
+		sb->s_flags |= MS_RDONLY;
+	}
+
+	dev = kmalloc(sizeof(struct yaffs_dev), GFP_KERNEL);
+	context = kmalloc(sizeof(struct yaffs_linux_context), GFP_KERNEL);
+
+	if (!dev || !context) {
+		if (dev)
+			kfree(dev);
+		if (context)
+			kfree(context);
+		dev = NULL;
+		context = NULL;
+	}
+
+	if (!dev) {
+		/* Deep shit could not allocate device structure */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs_read_super: Failed trying to allocate struct yaffs_dev."
+		);
+		return NULL;
+	}
+	memset(dev, 0, sizeof(struct yaffs_dev));
+	param = &(dev->param);
+
+	memset(context, 0, sizeof(struct yaffs_linux_context));
+	dev->os_context = context;
+	INIT_LIST_HEAD(&(context->context_list));
+	context->dev = dev;
+	context->super = sb;
+
+	dev->read_only = read_only;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	sb->s_fs_info = dev;
+#else
+	sb->u.generic_sbp = dev;
+#endif
+
+
+	dev->driver_context = mtd;
+	param->name = mtd->name;
+
+	/* Set up the memory size parameters.... */
+
+	n_blocks =
+	    YCALCBLOCKS(mtd->size,
+			(YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK));
+
+	param->start_block = 0;
+	param->end_block = n_blocks - 1;
+	param->chunks_per_block = YAFFS_CHUNKS_PER_BLOCK;
+	param->total_bytes_per_chunk = YAFFS_BYTES_PER_CHUNK;
+	param->n_reserved_blocks = 5;
+	param->n_caches = (options.no_cache) ? 0 : 10;
+	param->inband_tags = options.inband_tags;
+
+	param->enable_xattr = 1;
+	if (options.lazy_loading_overridden)
+		param->disable_lazy_load = !options.lazy_loading_enabled;
+
+	param->defered_dir_update = 1;
+
+	if (options.tags_ecc_overridden)
+		param->no_tags_ecc = !options.tags_ecc_on;
+
+	param->empty_lost_n_found = 1;
+	param->refresh_period = 500;
+	param->disable_summary = options.disable_summary;
+
+	if (options.empty_lost_and_found_overridden)
+		param->empty_lost_n_found = options.empty_lost_and_found;
+
+	/* ... and the functions. */
+	if (yaffs_version == 2) {
+		param->write_chunk_tags_fn = nandmtd2_write_chunk_tags;
+		param->read_chunk_tags_fn = nandmtd2_read_chunk_tags;
+		param->bad_block_fn = nandmtd2_mark_block_bad;
+		param->query_block_fn = nandmtd2_query_block;
+		yaffs_dev_to_lc(dev)->spare_buffer =
+				kmalloc(mtd->oobsize, GFP_NOFS);
+		param->is_yaffs2 = 1;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		param->total_bytes_per_chunk = mtd->writesize;
+		param->chunks_per_block = mtd->erasesize / mtd->writesize;
+#else
+		param->total_bytes_per_chunk = mtd->oobblock;
+		param->chunks_per_block = mtd->erasesize / mtd->oobblock;
+#endif
+		n_blocks = YCALCBLOCKS(mtd->size, mtd->erasesize);
+
+		param->start_block = 0;
+		param->end_block = n_blocks - 1;
+	} else {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		/* use the MTD interface in yaffs_mtdif1.c */
+		param->write_chunk_tags_fn = nandmtd1_write_chunk_tags;
+		param->read_chunk_tags_fn = nandmtd1_read_chunk_tags;
+		param->bad_block_fn = nandmtd1_mark_block_bad;
+		param->query_block_fn = nandmtd1_query_block;
+#else
+		param->write_chunk_fn = nandmtd_write_chunk;
+		param->read_chunk_fn = nandmtd_read_chunk;
+#endif
+		param->is_yaffs2 = 0;
+	}
+	/* ... and common functions */
+	param->erase_fn = nandmtd_erase_block;
+	param->initialise_flash_fn = nandmtd_initialise;
+
+	yaffs_dev_to_lc(dev)->put_super_fn = yaffs_mtd_put_super;
+
+	param->sb_dirty_fn = yaffs_touch_super;
+	param->gc_control = yaffs_gc_control_callback;
+
+	yaffs_dev_to_lc(dev)->super = sb;
+
+	param->use_nand_ecc = 1;
+
+	param->skip_checkpt_rd = options.skip_checkpoint_read;
+	param->skip_checkpt_wr = options.skip_checkpoint_write;
+
+	mutex_lock(&yaffs_context_lock);
+	/* Get a mount id */
+	found = 0;
+	for (mount_id = 0; !found; mount_id++) {
+		found = 1;
+		list_for_each(l, &yaffs_context_list) {
+			context_iterator =
+			    list_entry(l, struct yaffs_linux_context,
+				       context_list);
+			if (context_iterator->mount_id == mount_id)
+				found = 0;
+		}
+	}
+	context->mount_id = mount_id;
+
+	list_add_tail(&(yaffs_dev_to_lc(dev)->context_list),
+		      &yaffs_context_list);
+	mutex_unlock(&yaffs_context_lock);
+
+	/* Directory search handling... */
+	INIT_LIST_HEAD(&(yaffs_dev_to_lc(dev)->search_contexts));
+	param->remove_obj_fn = yaffs_remove_obj_callback;
+
+	mutex_init(&(yaffs_dev_to_lc(dev)->gross_lock));
+
+	yaffs_gross_lock(dev);
+
+	err = yaffs_guts_initialise(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: guts initialised %s",
+		(err == YAFFS_OK) ? "OK" : "FAILED");
+
+	if (err == YAFFS_OK)
+		yaffs_bg_start(dev);
+
+	if (!context->bg_thread)
+		param->defered_dir_update = 0;
+
+	sb->s_maxbytes = yaffs_max_file_size(dev);
+
+	/* Release lock before yaffs_get_inode() */
+	yaffs_gross_unlock(dev);
+
+	/* Create root inode */
+	if (err == YAFFS_OK)
+		inode = yaffs_get_inode(sb, S_IFDIR | 0755, 0, yaffs_root(dev));
+
+	if (!inode)
+		return NULL;
+
+	inode->i_op = &yaffs_dir_inode_operations;
+	inode->i_fop = &yaffs_dir_operations;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: got root inode");
+
+	root = d_alloc_root(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: d_alloc_root done");
+
+	if (!root) {
+		iput(inode);
+		return NULL;
+	}
+	sb->s_root = root;
+	sb->s_dirt = !dev->is_checkpointed;
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs_read_super: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: done");
+	return sb;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_internal_read_super_mtd(struct super_block *sb, void *data,
+					 int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static struct dentry *yaffs_mount(struct file_system_type *fs_type, int flags,
+        const char *dev_name, void *data)
+{
+    return mount_bdev(fs_type, flags, dev_name, data, yaffs_internal_read_super_mtd);
+}
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_read_super(struct file_system_type *fs,
+			    int flags, const char *dev_name,
+			    void *data, struct vfsmount *mnt)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs_read_super(struct file_system_type *fs,
+					    int flags, const char *dev_name,
+					    void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs",
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+        .mount = yaffs_mount,
+#else
+        .get_sb = yaffs_read_super,
+#endif
+     	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs_read_super(struct super_block *sb, void *data,
+					    int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs_fs_type, "yaffs", yaffs_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs2_internal_read_super_mtd(struct super_block *sb, void *data,
+					  int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static struct dentry *yaffs2_mount(struct file_system_type *fs_type, int flags,
+        const char *dev_name, void *data)
+{
+        return mount_bdev(fs_type, flags, dev_name, data, yaffs2_internal_read_super_mtd);
+}
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs2_read_super(struct file_system_type *fs,
+			     int flags, const char *dev_name, void *data,
+			     struct vfsmount *mnt)
+{
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs2_read_super(struct file_system_type *fs,
+					     int flags, const char *dev_name,
+					     void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs2_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs2",
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+        .mount = yaffs2_mount,
+#else
+        .get_sb = yaffs2_read_super,
+#endif
+     	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs2_read_super(struct super_block *sb,
+					     void *data, int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs2_fs_type, "yaffs2", yaffs2_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+
+static struct proc_dir_entry *my_proc_entry;
+
+static char *yaffs_dump_dev_part0(char *buf, struct yaffs_dev *dev)
+{
+	struct yaffs_param *param = &dev->param;
+
+	buf += sprintf(buf, "start_block.......... %d\n", param->start_block);
+	buf += sprintf(buf, "end_block............ %d\n", param->end_block);
+	buf += sprintf(buf, "total_bytes_per_chunk %d\n",
+				param->total_bytes_per_chunk);
+	buf += sprintf(buf, "use_nand_ecc......... %d\n", param->use_nand_ecc);
+	buf += sprintf(buf, "no_tags_ecc.......... %d\n", param->no_tags_ecc);
+	buf += sprintf(buf, "is_yaffs2............ %d\n", param->is_yaffs2);
+	buf += sprintf(buf, "inband_tags.......... %d\n", param->inband_tags);
+	buf += sprintf(buf, "empty_lost_n_found... %d\n",
+				param->empty_lost_n_found);
+	buf += sprintf(buf, "disable_lazy_load.... %d\n",
+				param->disable_lazy_load);
+	buf += sprintf(buf, "refresh_period....... %d\n",
+				param->refresh_period);
+	buf += sprintf(buf, "n_caches............. %d\n", param->n_caches);
+	buf += sprintf(buf, "n_reserved_blocks.... %d\n",
+				param->n_reserved_blocks);
+	buf += sprintf(buf, "always_check_erased.. %d\n",
+				param->always_check_erased);
+	buf += sprintf(buf, "\n");
+
+	return buf;
+}
+
+static char *yaffs_dump_dev_part1(char *buf, struct yaffs_dev *dev)
+{
+	buf += sprintf(buf, "max file size....... %lld\n",
+				(long long) yaffs_max_file_size(dev));
+	buf += sprintf(buf, "data_bytes_per_chunk. %d\n",
+				dev->data_bytes_per_chunk);
+	buf += sprintf(buf, "chunk_grp_bits....... %d\n", dev->chunk_grp_bits);
+	buf += sprintf(buf, "chunk_grp_size....... %d\n", dev->chunk_grp_size);
+	buf += sprintf(buf, "n_erased_blocks...... %d\n", dev->n_erased_blocks);
+	buf += sprintf(buf, "blocks_in_checkpt.... %d\n",
+				dev->blocks_in_checkpt);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_tnodes............. %d\n", dev->n_tnodes);
+	buf += sprintf(buf, "n_obj................ %d\n", dev->n_obj);
+	buf += sprintf(buf, "n_free_chunks........ %d\n", dev->n_free_chunks);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_page_writes........ %u\n", dev->n_page_writes);
+	buf += sprintf(buf, "n_page_reads......... %u\n", dev->n_page_reads);
+	buf += sprintf(buf, "n_erasures........... %u\n", dev->n_erasures);
+	buf += sprintf(buf, "n_gc_copies.......... %u\n", dev->n_gc_copies);
+	buf += sprintf(buf, "all_gcs.............. %u\n", dev->all_gcs);
+	buf += sprintf(buf, "passive_gc_count..... %u\n",
+				dev->passive_gc_count);
+	buf += sprintf(buf, "oldest_dirty_gc_count %u\n",
+				dev->oldest_dirty_gc_count);
+	buf += sprintf(buf, "n_gc_blocks.......... %u\n", dev->n_gc_blocks);
+	buf += sprintf(buf, "bg_gcs............... %u\n", dev->bg_gcs);
+	buf += sprintf(buf, "n_retried_writes..... %u\n",
+				dev->n_retried_writes);
+	buf += sprintf(buf, "n_retired_blocks..... %u\n",
+				dev->n_retired_blocks);
+	buf += sprintf(buf, "n_ecc_fixed.......... %u\n", dev->n_ecc_fixed);
+	buf += sprintf(buf, "n_ecc_unfixed........ %u\n", dev->n_ecc_unfixed);
+	buf += sprintf(buf, "n_tags_ecc_fixed..... %u\n",
+				dev->n_tags_ecc_fixed);
+	buf += sprintf(buf, "n_tags_ecc_unfixed... %u\n",
+				dev->n_tags_ecc_unfixed);
+	buf += sprintf(buf, "cache_hits........... %u\n", dev->cache_hits);
+	buf += sprintf(buf, "n_deleted_files...... %u\n", dev->n_deleted_files);
+	buf += sprintf(buf, "n_unlinked_files..... %u\n",
+				dev->n_unlinked_files);
+	buf += sprintf(buf, "refresh_count........ %u\n", dev->refresh_count);
+	buf += sprintf(buf, "n_bg_deletions....... %u\n", dev->n_bg_deletions);
+	buf += sprintf(buf, "tags_used............ %u\n", dev->tags_used);
+	buf += sprintf(buf, "summary_used......... %u\n", dev->summary_used);
+
+	return buf;
+}
+
+static int yaffs_proc_read(char *page,
+			   char **start,
+			   off_t offset, int count, int *eof, void *data)
+{
+	struct list_head *item;
+	char *buf = page;
+	int step = offset;
+	int n = 0;
+
+	/* Get proc_file_read() to step 'offset' by one on each sucessive call.
+	 * We use 'offset' (*ppos) to indicate where we are in dev_list.
+	 * This also assumes the user has posted a read buffer large
+	 * enough to hold the complete output; but that's life in /proc.
+	 */
+
+	*(int *)start = 1;
+
+	/* Print header first */
+	if (step == 0)
+		buf +=
+		    sprintf(buf,
+			    "Multi-version YAFFS built:" __DATE__ " " __TIME__
+			    "\n");
+	else if (step == 1)
+		buf += sprintf(buf, "\n");
+	else {
+		step -= 2;
+
+		mutex_lock(&yaffs_context_lock);
+
+		/* Locate and print the Nth entry.  Order N-squared but N is small. */
+		list_for_each(item, &yaffs_context_list) {
+			struct yaffs_linux_context *dc =
+			    list_entry(item, struct yaffs_linux_context,
+				       context_list);
+			struct yaffs_dev *dev = dc->dev;
+
+			if (n < (step & ~1)) {
+				n += 2;
+				continue;
+			}
+			if ((step & 1) == 0) {
+				buf +=
+				    sprintf(buf, "\nDevice %d \"%s\"\n", n,
+					    dev->param.name);
+				buf = yaffs_dump_dev_part0(buf, dev);
+			} else {
+				buf = yaffs_dump_dev_part1(buf, dev);
+                        }
+
+			break;
+		}
+		mutex_unlock(&yaffs_context_lock);
+	}
+
+	return buf - page < count ? buf - page : count;
+}
+
+/**
+ * Set the verbosity of the warnings and error messages.
+ *
+ * Note that the names can only be a..z or _ with the current code.
+ */
+
+static struct {
+	char *mask_name;
+	unsigned mask_bitfield;
+} mask_flags[] = {
+	{"allocate", YAFFS_TRACE_ALLOCATE},
+	{"always", YAFFS_TRACE_ALWAYS},
+	{"background", YAFFS_TRACE_BACKGROUND},
+	{"bad_blocks", YAFFS_TRACE_BAD_BLOCKS},
+	{"buffers", YAFFS_TRACE_BUFFERS},
+	{"bug", YAFFS_TRACE_BUG},
+	{"checkpt", YAFFS_TRACE_CHECKPOINT},
+	{"deletion", YAFFS_TRACE_DELETION},
+	{"erase", YAFFS_TRACE_ERASE},
+	{"error", YAFFS_TRACE_ERROR},
+	{"gc_detail", YAFFS_TRACE_GC_DETAIL},
+	{"gc", YAFFS_TRACE_GC},
+	{"lock", YAFFS_TRACE_LOCK},
+	{"mtd", YAFFS_TRACE_MTD},
+	{"nandaccess", YAFFS_TRACE_NANDACCESS},
+	{"os", YAFFS_TRACE_OS},
+	{"scan_debug", YAFFS_TRACE_SCAN_DEBUG},
+	{"scan", YAFFS_TRACE_SCAN},
+	{"mount", YAFFS_TRACE_MOUNT},
+	{"tracing", YAFFS_TRACE_TRACING},
+	{"sync", YAFFS_TRACE_SYNC},
+	{"write", YAFFS_TRACE_WRITE},
+	{"verify", YAFFS_TRACE_VERIFY},
+	{"verify_nand", YAFFS_TRACE_VERIFY_NAND},
+	{"verify_full", YAFFS_TRACE_VERIFY_FULL},
+	{"verify_all", YAFFS_TRACE_VERIFY_ALL},
+	{"all", 0xffffffff},
+	{"none", 0},
+	{NULL, 0},
+};
+
+#define MAX_MASK_NAME_LENGTH 40
+static int yaffs_proc_write_trace_options(struct file *file, const char *buf,
+					  unsigned long count, void *data)
+{
+	unsigned rg = 0, mask_bitfield;
+	char *end;
+	char *mask_name;
+	const char *x;
+	char substring[MAX_MASK_NAME_LENGTH + 1];
+	int i;
+	int done = 0;
+	int add, len = 0;
+	int pos = 0;
+
+	rg = yaffs_trace_mask;
+
+	while (!done && (pos < count)) {
+		done = 1;
+		while ((pos < count) && isspace(buf[pos]))
+			pos++;
+
+		switch (buf[pos]) {
+		case '+':
+		case '-':
+		case '=':
+			add = buf[pos];
+			pos++;
+			break;
+
+		default:
+			add = ' ';
+			break;
+		}
+		mask_name = NULL;
+
+		mask_bitfield = simple_strtoul(buf + pos, &end, 0);
+
+		if (end > buf + pos) {
+			mask_name = "numeral";
+			len = end - (buf + pos);
+			pos += len;
+			done = 0;
+		} else {
+			for (x = buf + pos, i = 0;
+			     (*x == '_' || (*x >= 'a' && *x <= 'z')) &&
+			     i < MAX_MASK_NAME_LENGTH; x++, i++, pos++)
+				substring[i] = *x;
+			substring[i] = '\0';
+
+			for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+				if (strcmp(substring, mask_flags[i].mask_name)
+				    == 0) {
+					mask_name = mask_flags[i].mask_name;
+					mask_bitfield =
+					    mask_flags[i].mask_bitfield;
+					done = 0;
+					break;
+				}
+			}
+		}
+
+		if (mask_name != NULL) {
+			done = 0;
+			switch (add) {
+			case '-':
+				rg &= ~mask_bitfield;
+				break;
+			case '+':
+				rg |= mask_bitfield;
+				break;
+			case '=':
+				rg = mask_bitfield;
+				break;
+			default:
+				rg |= mask_bitfield;
+				break;
+			}
+		}
+	}
+
+	yaffs_trace_mask = rg | YAFFS_TRACE_ALWAYS;
+
+	printk(KERN_DEBUG "new trace = 0x%08X\n", yaffs_trace_mask);
+
+	if (rg & YAFFS_TRACE_ALWAYS) {
+		for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+			char flag;
+			flag = ((rg & mask_flags[i].mask_bitfield) ==
+				mask_flags[i].mask_bitfield) ? '+' : '-';
+			printk(KERN_DEBUG "%c%s\n", flag,
+			       mask_flags[i].mask_name);
+		}
+	}
+
+	return count;
+}
+
+static int yaffs_proc_write(struct file *file, const char *buf,
+			    unsigned long count, void *data)
+{
+	return yaffs_proc_write_trace_options(file, buf, count, data);
+}
+
+/* Stuff to handle installation of file systems */
+struct file_system_to_install {
+	struct file_system_type *fst;
+	int installed;
+};
+
+static struct file_system_to_install fs_to_install[] = {
+	{&yaffs_fs_type, 0},
+	{&yaffs2_fs_type, 0},
+	{NULL, 0}
+};
+
+static int __init init_yaffs_fs(void)
+{
+	int error = 0;
+	struct file_system_to_install *fsinst;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs built " __DATE__ " " __TIME__ " Installing.");
+
+	mutex_init(&yaffs_context_lock);
+
+	/* Install the proc_fs entries */
+	my_proc_entry = create_proc_entry("yaffs",
+					  S_IRUGO | S_IFREG, YPROC_ROOT);
+
+	if (my_proc_entry) {
+		my_proc_entry->write_proc = yaffs_proc_write;
+		my_proc_entry->read_proc = yaffs_proc_read;
+		my_proc_entry->data = NULL;
+	} else {
+		return -ENOMEM;
+        }
+
+	/* Now add the file system entries */
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst && !error) {
+		error = register_filesystem(fsinst->fst);
+		if (!error)
+			fsinst->installed = 1;
+		fsinst++;
+	}
+
+	/* Any errors? uninstall  */
+	if (error) {
+		fsinst = fs_to_install;
+
+		while (fsinst->fst) {
+			if (fsinst->installed) {
+				unregister_filesystem(fsinst->fst);
+				fsinst->installed = 0;
+			}
+			fsinst++;
+		}
+	}
+
+	return error;
+}
+
+static void __exit exit_yaffs_fs(void)
+{
+
+	struct file_system_to_install *fsinst;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs built " __DATE__ " " __TIME__ " removing.");
+
+	remove_proc_entry("yaffs", YPROC_ROOT);
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst) {
+		if (fsinst->installed) {
+			unregister_filesystem(fsinst->fst);
+			fsinst->installed = 0;
+		}
+		fsinst++;
+	}
+}
+
+module_init(init_yaffs_fs)
+    module_exit(exit_yaffs_fs)
+
+    MODULE_DESCRIPTION("YAFFS2 - a NAND specific flash file system");
+MODULE_AUTHOR("Charles Manning, Aleph One Ltd., 2002-2011");
+MODULE_LICENSE("GPL");
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_vfs_single.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_vfs_single.c
--- linux-3.1.9/fs/yaffs2/yaffs_vfs_single.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_vfs_single.c	2012-06-28 16:54:39.723622580 -0600
@@ -0,0 +1,2569 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ * Acknowledgements:
+ * Luc van OostenRyck for numerous patches.
+ * Nick Bane for numerous patches.
+ * Nick Bane for 2.5/2.6 integration.
+ * Andras Toth for mknod rdev issue.
+ * Michael Fischer for finding the problem with inode inconsistency.
+ * Some code bodily lifted from JFFS
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ *
+ * This is the file system front-end to YAFFS that hooks it up to
+ * the VFS.
+ *
+ * Special notes:
+ * >> 2.4: sb->u.generic_sbp points to the struct yaffs_dev associated with
+ *         this superblock
+ * >> 2.6: sb->s_fs_info  points to the struct yaffs_dev associated with this
+ *         superblock
+ * >> inode->u.generic_ip points to the associated struct yaffs_obj.
+ */
+
+/*
+ * NB There are two variants of Linux VFS glue code. This variant supports
+ * a single version and should not include any multi-version code.
+ */
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/pagemap.h>
+#include <linux/mtd/mtd.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <linux/namei.h>
+#include <linux/exportfs.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/freezer.h>
+#include <asm/div64.h>
+#include <linux/statfs.h>
+#include <linux/uaccess.h>
+#include <linux/mtd/mtd.h>
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+#include "yaffs_attribs.h"
+#include "yaffs_linux.h"
+#include "yaffs_mtdif.h"
+#include "yaffs_mtdif1.h"
+#include "yaffs_mtdif2.h"
+
+unsigned int yaffs_trace_mask = YAFFS_TRACE_BAD_BLOCKS | YAFFS_TRACE_ALWAYS;
+unsigned int yaffs_wr_attempts = YAFFS_WR_ATTEMPTS;
+unsigned int yaffs_auto_checkpoint = 1;
+unsigned int yaffs_gc_control = 1;
+unsigned int yaffs_bg_enable = 1;
+unsigned int yaffs_auto_select = 1;
+
+/* Module Parameters */
+module_param(yaffs_trace_mask, uint, 0644);
+module_param(yaffs_wr_attempts, uint, 0644);
+module_param(yaffs_auto_checkpoint, uint, 0644);
+module_param(yaffs_gc_control, uint, 0644);
+module_param(yaffs_bg_enable, uint, 0644);
+module_param(yaffs_auto_select, uint, 0644);
+
+#define yaffs_devname(sb, buf)	bdevname(sb->s_bdev, buf)
+
+static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
+{
+	uint64_t result = partition_size;
+
+	do_div(result, block_size);
+	return (uint32_t) result;
+}
+
+#define yaffs_inode_to_obj_lv(iptr) ((iptr)->i_private)
+#define yaffs_inode_to_obj(iptr)\
+	((struct yaffs_obj *)(yaffs_inode_to_obj_lv(iptr)))
+#define yaffs_dentry_to_obj(dptr) yaffs_inode_to_obj((dptr)->d_inode)
+#define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->s_fs_info)
+
+#define update_dir_time(dir) do {\
+			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
+		} while (0)
+
+
+static unsigned yaffs_gc_control_callback(struct yaffs_dev *dev)
+{
+	return yaffs_gc_control;
+}
+
+static void yaffs_gross_lock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locking %p", current);
+	mutex_lock(&(yaffs_dev_to_lc(dev)->gross_lock));
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locked %p", current);
+}
+
+static void yaffs_gross_unlock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs unlocking %p", current);
+	mutex_unlock(&(yaffs_dev_to_lc(dev)->gross_lock));
+}
+
+static void yaffs_fill_inode_from_obj(struct inode *inode,
+				      struct yaffs_obj *obj);
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode;
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_iget for %lu", ino);
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	yaffs_gross_unlock(dev);
+
+	unlock_new_inode(inode);
+	return inode;
+}
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+			      struct yaffs_obj *obj)
+{
+	struct inode *inode;
+
+	if (!sb) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL super_block!!");
+		return NULL;
+
+	}
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL object!!");
+		return NULL;
+
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_get_inode for object %d",
+		obj->obj_id);
+
+	inode = yaffs_iget(sb, obj->obj_id);
+	if (IS_ERR(inode))
+		return NULL;
+
+	/* NB Side effect: iget calls back to yaffs_read_inode(). */
+	/* iget also increments the inode's i_count */
+	/* NB You can't be holding gross_lock or deadlock will happen! */
+
+	return inode;
+}
+
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       dev_t rdev)
+{
+	struct inode *inode;
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *parent = yaffs_inode_to_obj(dir);
+	int error;
+	uid_t uid = current->cred->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : current->cred->fsgid;
+
+	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
+		mode |= S_ISGID;
+
+	if (!parent) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: could not get parent object");
+		return -EPERM;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: parent object %d type %d",
+			parent->obj_id, parent->variant_type);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_mknod: making oject for %s, mode %x dev %x",
+		dentry->d_name.name, mode, rdev);
+
+	dev = parent->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	if (yaffs_get_n_free_chunks(dev) < 1) {
+		error = -ENOSPC;
+		goto err_out;
+	}
+
+	switch (mode & S_IFMT) {
+	default:
+		/* Special (socket, fifo, device...) */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making special");
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, old_encode_dev(rdev));
+		break;
+	case S_IFREG:		/* file          */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making file");
+		obj = yaffs_create_file(parent, dentry->d_name.name, mode, uid,
+					gid);
+		break;
+	case S_IFDIR:		/* directory */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making directory");
+		obj = yaffs_create_dir(parent, dentry->d_name.name, mode,
+				       uid, gid);
+		break;
+	case S_IFLNK:		/* symlink */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making symlink");
+		obj = NULL;	/* Do we ever get here? */
+		break;
+	}
+
+	if (!obj) {
+		error = -ENOMEM;
+		goto err_out;
+	}
+
+	/* Can not call yaffs_get_inode() with gross lock held */
+	yaffs_gross_unlock(dev);
+
+
+	inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
+	d_instantiate(dentry, inode);
+	update_dir_time(dir);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_mknod created object %d count = %d",
+		obj->obj_id, atomic_read(&inode->i_count));
+	yaffs_fill_inode_from_obj(dir, parent);
+	return 0;
+
+err_out:
+	yaffs_gross_unlock(dev);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod error %d", error);
+	return error;
+
+}
+
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	return yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
+}
+
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n)
+{
+	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
+}
+
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+		      struct dentry *dentry)
+{
+	struct inode *inode = old_dentry->d_inode;
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_obj *link = NULL;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_link");
+
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	if (!S_ISDIR(inode->i_mode))	/* Don't link directories */
+		link =
+		    yaffs_link_obj(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   obj);
+
+	if (link) {
+		set_nlink(old_dentry->d_inode, yaffs_get_obj_link_count(obj));
+		d_instantiate(dentry, old_dentry->d_inode);
+		atomic_inc(&old_dentry->d_inode->i_count);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_link link count %d i_count %d",
+			old_dentry->d_inode->i_nlink,
+			atomic_read(&old_dentry->d_inode->i_count));
+	}
+
+	yaffs_gross_unlock(dev);
+
+	if (link) {
+		update_dir_time(dir);
+		return 0;
+	}
+
+	return -EPERM;
+}
+
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			 const char *symname)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	struct inode *inode;
+	uid_t uid = current->cred->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : current->cred->fsgid;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_symlink");
+
+	if (strnlen(dentry->d_name.name, YAFFS_MAX_NAME_LENGTH + 1) >
+				YAFFS_MAX_NAME_LENGTH)
+		return -ENAMETOOLONG;
+
+	if (strnlen(symname, YAFFS_MAX_ALIAS_LENGTH + 1) >
+				YAFFS_MAX_ALIAS_LENGTH)
+		return -ENAMETOOLONG;
+
+	dev = yaffs_inode_to_obj(dir)->my_dev;
+	yaffs_gross_lock(dev);
+	obj = yaffs_create_symlink(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   S_IFLNK | S_IRWXUGO, uid, gid, symname);
+	yaffs_gross_unlock(dev);
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS, "symlink not created");
+		return -ENOMEM;
+	}
+
+	inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+	d_instantiate(dentry, inode);
+	update_dir_time(dir);
+	yaffs_trace(YAFFS_TRACE_OS, "symlink created OK");
+
+	return 0;
+}
+
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *n)
+{
+	struct yaffs_obj *obj;
+	struct inode *inode = NULL;
+	struct yaffs_dev *dev = yaffs_inode_to_obj(dir)->my_dev;
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_lookup for %d:%s",
+		yaffs_inode_to_obj(dir)->obj_id, dentry->d_name.name);
+
+	obj = yaffs_find_by_name(yaffs_inode_to_obj(dir), dentry->d_name.name);
+
+	obj = yaffs_get_equivalent_obj(obj);	/* in case it was a hardlink */
+
+	/* Can't hold gross lock when calling yaffs_get_inode() */
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_unlock(dev);
+
+	if (obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_lookup found %d", obj->obj_id);
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+
+		if (inode) {
+			yaffs_trace(YAFFS_TRACE_OS, "yaffs_loookup dentry");
+			d_add(dentry, inode);
+			/* return dentry; */
+			return NULL;
+		}
+
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup not found");
+
+	}
+
+	d_add(dentry, inode);
+
+	return NULL;
+}
+
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int ret_val;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_unlink %d:%s",
+		(int)(dir->i_ino), dentry->d_name.name);
+	obj = yaffs_inode_to_obj(dir);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	ret_val = yaffs_unlinker(obj, dentry->d_name.name);
+
+	if (ret_val == YAFFS_OK) {
+		inode_dec_link_count(dentry->d_inode);
+		dir->i_version++;
+		yaffs_gross_unlock(dev);
+		update_dir_time(dir);
+		return 0;
+	}
+	yaffs_gross_unlock(dev);
+	return -ENOTEMPTY;
+}
+
+static int yaffs_sync_object(struct file *file,
+				loff_t start, loff_t end, int datasync)
+{
+
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	struct dentry *dentry = file->f_path.dentry;
+
+	obj = yaffs_dentry_to_obj(dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC, "yaffs_sync_object");
+	yaffs_gross_lock(dev);
+	yaffs_flush_file(obj, 1, datasync);
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+/*
+ * The VFS layer already does all the dentry stuff for rename.
+ *
+ * NB: POSIX says you can rename an object over an old object of the same name
+ */
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry)
+{
+	struct yaffs_dev *dev;
+	int ret_val = YAFFS_FAIL;
+	struct yaffs_obj *target;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_rename");
+	dev = yaffs_inode_to_obj(old_dir)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	/* Check if the target is an existing directory that is not empty. */
+	target = yaffs_find_by_name(yaffs_inode_to_obj(new_dir),
+				    new_dentry->d_name.name);
+
+	if (target && target->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY &&
+	    !list_empty(&target->variant.dir_variant.children)) {
+
+		yaffs_trace(YAFFS_TRACE_OS, "target is non-empty dir");
+
+		ret_val = YAFFS_FAIL;
+	} else {
+		/* Now does unlinking internally using shadowing mechanism */
+		yaffs_trace(YAFFS_TRACE_OS, "calling yaffs_rename_obj");
+
+		ret_val = yaffs_rename_obj(yaffs_inode_to_obj(old_dir),
+					   old_dentry->d_name.name,
+					   yaffs_inode_to_obj(new_dir),
+					   new_dentry->d_name.name);
+	}
+	yaffs_gross_unlock(dev);
+
+	if (ret_val == YAFFS_OK) {
+		if (target)
+			inode_dec_link_count(new_dentry->d_inode);
+
+		update_dir_time(old_dir);
+		if (old_dir != new_dir)
+			update_dir_time(new_dir);
+		return 0;
+	} else {
+		return -ENOTEMPTY;
+	}
+}
+
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	int result;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_setattr of object %d",
+		yaffs_inode_to_obj(inode)->obj_id);
+
+	/* Fail if a requested resize >= 2GB */
+	if (attr->ia_valid & ATTR_SIZE && (attr->ia_size >> 31))
+		error = -EINVAL;
+
+	if (!error)
+		error = inode_change_ok(inode, attr);
+
+	if (!error) {
+		setattr_copy(inode, attr);
+		yaffs_trace(YAFFS_TRACE_OS, "inode_setattr called");
+		if (attr->ia_valid & ATTR_SIZE) {
+			truncate_setsize(inode, attr->ia_size);
+			inode->i_blocks = (inode->i_size + 511) >> 9;
+		}
+		dev = yaffs_inode_to_obj(inode)->my_dev;
+		if (attr->ia_valid & ATTR_SIZE) {
+			yaffs_trace(YAFFS_TRACE_OS, "resize to %d(%x)",
+					   (int)(attr->ia_size),
+					   (int)(attr->ia_size));
+		}
+
+		yaffs_gross_lock(dev);
+		result = yaffs_set_attribs(yaffs_inode_to_obj(inode), attr);
+		if (result != YAFFS_OK)
+			error = -EPERM;
+		yaffs_gross_unlock(dev);
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setattr done returning %d", error);
+
+	return error;
+}
+
+static int yaffs_setxattr(struct dentry *dentry, const char *name,
+		   const void *value, size_t size, int flags)
+{
+	struct inode *inode = dentry->d_inode;
+	int error;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr of object %d", obj->obj_id);
+
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+	error = yaffs_set_xattrib(obj, name, value, size, flags);
+	yaffs_gross_unlock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_getxattr(struct dentry *dentry, const char *name,
+				void *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_getxattr \"%s\" from object %d",
+		name, obj->obj_id);
+
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+	error = yaffs_get_xattrib(obj, name, buff, size);
+	yaffs_gross_unlock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_getxattr done returning %d", error);
+
+	return error;
+}
+
+static int yaffs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct inode *inode = dentry->d_inode;
+	int error;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr of object %d", obj->obj_id);
+
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+	error = yaffs_remove_xattrib(obj, name);
+	yaffs_gross_unlock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_listxattr(struct dentry *dentry, char *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr of object %d", obj->obj_id);
+
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+	error = yaffs_list_xattrib(obj, buff, size);
+	yaffs_gross_unlock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr done returning %d", error);
+
+	return error;
+}
+
+static const struct inode_operations yaffs_dir_inode_operations = {
+	.create = yaffs_create,
+	.lookup = yaffs_lookup,
+	.link = yaffs_link,
+	.unlink = yaffs_unlink,
+	.symlink = yaffs_symlink,
+	.mkdir = yaffs_mkdir,
+	.rmdir = yaffs_unlink,
+	.mknod = yaffs_mknod,
+	.rename = yaffs_rename,
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+/*-----------------------------------------------------------------*/
+/* Directory search context allows us to unlock access to yaffs during
+ * filldir without causing problems with the directory being modified.
+ * This is similar to the tried and tested mechanism used in yaffs direct.
+ *
+ * A search context iterates along a doubly linked list of siblings in the
+ * directory. If the iterating object is deleted then this would corrupt
+ * the list iteration, likely causing a crash. The search context avoids
+ * this by using the remove_obj_fn to move the search context to the
+ * next object before the object is deleted.
+ *
+ * Many readdirs (and thus seach conexts) may be alive simulateously so
+ * each struct yaffs_dev has a list of these.
+ *
+ * A seach context lives for the duration of a readdir.
+ *
+ * All these functions must be called while yaffs is locked.
+ */
+
+struct yaffs_search_context {
+	struct yaffs_dev *dev;
+	struct yaffs_obj *dir_obj;
+	struct yaffs_obj *next_return;
+	struct list_head others;
+};
+
+/*
+ * yaffs_new_search() creates a new search context, initialises it and
+ * adds it to the device's search context list.
+ *
+ * Called at start of readdir.
+ */
+static struct yaffs_search_context *yaffs_new_search(struct yaffs_obj *dir)
+{
+	struct yaffs_dev *dev = dir->my_dev;
+	struct yaffs_search_context *sc =
+	    kmalloc(sizeof(struct yaffs_search_context), GFP_NOFS);
+
+	if (!sc)
+		return NULL;
+
+	sc->dir_obj = dir;
+	sc->dev = dev;
+	if (list_empty(&sc->dir_obj->variant.dir_variant.children))
+		sc->next_return = NULL;
+	else
+		sc->next_return =
+		    list_entry(dir->variant.dir_variant.children.next,
+			       struct yaffs_obj, siblings);
+	INIT_LIST_HEAD(&sc->others);
+	list_add(&sc->others, &(yaffs_dev_to_lc(dev)->search_contexts));
+
+	return sc;
+}
+
+/*
+ * yaffs_search_end() disposes of a search context and cleans up.
+ */
+static void yaffs_search_end(struct yaffs_search_context *sc)
+{
+	if (sc) {
+		list_del(&sc->others);
+		kfree(sc);
+	}
+}
+
+/*
+ * yaffs_search_advance() moves a search context to the next object.
+ * Called when the search iterates or when an object removal causes
+ * the search context to be moved to the next object.
+ */
+static void yaffs_search_advance(struct yaffs_search_context *sc)
+{
+	if (!sc)
+		return;
+
+	if (sc->next_return == NULL ||
+	    list_empty(&sc->dir_obj->variant.dir_variant.children))
+		sc->next_return = NULL;
+	else {
+		struct list_head *next = sc->next_return->siblings.next;
+
+		if (next == &sc->dir_obj->variant.dir_variant.children)
+			sc->next_return = NULL;	/* end of list */
+		else
+			sc->next_return =
+			    list_entry(next, struct yaffs_obj, siblings);
+	}
+}
+
+/*
+ * yaffs_remove_obj_callback() is called when an object is unlinked.
+ * We check open search contexts and advance any which are currently
+ * on the object being iterated.
+ */
+static void yaffs_remove_obj_callback(struct yaffs_obj *obj)
+{
+
+	struct list_head *i;
+	struct yaffs_search_context *sc;
+	struct list_head *search_contexts =
+	    &(yaffs_dev_to_lc(obj->my_dev)->search_contexts);
+
+	/* Iterate through the directory search contexts.
+	 * If any are currently on the object being removed, then advance
+	 * the search context to the next object to prevent a hanging pointer.
+	 */
+	list_for_each(i, search_contexts) {
+		sc = list_entry(i, struct yaffs_search_context, others);
+		if (sc->next_return == obj)
+			yaffs_search_advance(sc);
+	}
+
+}
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	struct yaffs_search_context *sc;
+	struct inode *inode = f->f_dentry->d_inode;
+	unsigned long offset, curoffs;
+	struct yaffs_obj *l;
+	int ret_val = 0;
+	char name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_dev_to_lc(dev)->readdir_process = current;
+
+	offset = f->f_pos;
+
+	sc = yaffs_new_search(obj);
+	if (!sc) {
+		ret_val = -ENOMEM;
+		goto out;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readdir: starting at %d", (int)offset);
+
+	if (offset == 0) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_readdir: entry . ino %d",
+			(int)inode->i_ino);
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, ".", 1, offset, inode->i_ino, DT_DIR) < 0) {
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+	if (offset == 1) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_readdir: entry .. ino %d",
+			(int)f->f_dentry->d_parent->d_inode->i_ino);
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, "..", 2, offset,
+			    f->f_dentry->d_parent->d_inode->i_ino,
+			    DT_DIR) < 0) {
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+
+	curoffs = 1;
+
+	/* If the directory has changed since the open or last call to
+	   readdir, rewind to after the 2 canned entries. */
+	if (f->f_version != inode->i_version) {
+		offset = 2;
+		f->f_pos = offset;
+		f->f_version = inode->i_version;
+	}
+
+	while (sc->next_return) {
+		curoffs++;
+		l = sc->next_return;
+		if (curoffs >= offset) {
+			int this_inode = yaffs_get_obj_inode(l);
+			int this_type = yaffs_get_obj_type(l);
+
+			yaffs_get_obj_name(l, name, YAFFS_MAX_NAME_LENGTH + 1);
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_readdir: %s inode %d",
+				name, yaffs_get_obj_inode(l));
+
+			yaffs_gross_unlock(dev);
+
+			if (filldir(dirent,
+				    name,
+				    strlen(name),
+				    offset, this_inode, this_type) < 0) {
+				yaffs_gross_lock(dev);
+				goto out;
+			}
+
+			yaffs_gross_lock(dev);
+
+			offset++;
+			f->f_pos++;
+		}
+		yaffs_search_advance(sc);
+	}
+
+out:
+	yaffs_search_end(sc);
+	yaffs_dev_to_lc(dev)->readdir_process = NULL;
+	yaffs_gross_unlock(dev);
+
+	return ret_val;
+}
+
+static const struct file_operations yaffs_dir_operations = {
+	.read = generic_read_dir,
+	.readdir = yaffs_readdir,
+	.fsync = yaffs_sync_object,
+	.llseek = generic_file_llseek,
+};
+
+
+
+static int yaffs_file_flush(struct file *file, fl_owner_t id)
+{
+	struct yaffs_obj *obj = yaffs_dentry_to_obj(file->f_dentry);
+	struct yaffs_dev *dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_flush object %d (%s)",
+		obj->obj_id, obj->dirty ? "dirty" : "clean");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_file(obj, 1, 0);
+
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.splice_read = generic_file_splice_read,
+	.splice_write = generic_file_splice_write,
+	.llseek = generic_file_llseek,
+};
+
+
+/* ExportFS support */
+static struct inode *yaffs2_nfs_get_inode(struct super_block *sb, uint64_t ino,
+					  uint32_t generation)
+{
+	return yaffs_iget(sb, ino);
+}
+
+static struct dentry *yaffs2_fh_to_dentry(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+static struct dentry *yaffs2_fh_to_parent(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+struct dentry *yaffs2_get_parent(struct dentry *dentry)
+{
+
+	struct super_block *sb = dentry->d_inode->i_sb;
+	struct dentry *parent = ERR_PTR(-ENOENT);
+	struct inode *inode;
+	unsigned long parent_ino;
+	struct yaffs_obj *d_obj;
+	struct yaffs_obj *parent_obj;
+
+	d_obj = yaffs_inode_to_obj(dentry->d_inode);
+
+	if (d_obj) {
+		parent_obj = d_obj->parent;
+		if (parent_obj) {
+			parent_ino = yaffs_get_obj_inode(parent_obj);
+			inode = yaffs_iget(sb, parent_ino);
+
+			if (IS_ERR(inode)) {
+				parent = ERR_CAST(inode);
+			} else {
+				parent = d_obtain_alias(inode);
+				if (!IS_ERR(parent)) {
+					parent = ERR_PTR(-ENOMEM);
+					iput(inode);
+				}
+			}
+		}
+	}
+	return parent;
+}
+
+/* Just declare a zero structure as a NULL value implies
+ * using the default functions of exportfs.
+ */
+
+static struct export_operations yaffs_export_ops = {
+	.fh_to_dentry = yaffs2_fh_to_dentry,
+	.fh_to_parent = yaffs2_fh_to_parent,
+	.get_parent = yaffs2_get_parent,
+};
+
+
+/*-----------------------------------------------------------------*/
+
+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
+			  int buflen)
+{
+	unsigned char *alias;
+	int ret;
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+
+	yaffs_gross_unlock(dev);
+
+	if (!alias)
+		return -ENOMEM;
+
+	ret = vfs_readlink(dentry, buffer, buflen, alias);
+	kfree(alias);
+	return ret;
+}
+
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	unsigned char *alias;
+	void *ret;
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+	yaffs_gross_unlock(dev);
+
+	if (!alias) {
+		ret = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+
+	nd_set_link(nd, alias);
+	ret = (void *)alias;
+out:
+	return ret;
+}
+
+void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias)
+{
+	kfree(alias);
+}
+
+
+static void yaffs_unstitch_obj(struct inode *inode, struct yaffs_obj *obj)
+{
+	/* Clear the association between the inode and
+	 * the struct yaffs_obj.
+	 */
+	obj->my_inode = NULL;
+	yaffs_inode_to_obj_lv(inode) = NULL;
+
+	/* If the object freeing was deferred, then the real
+	 * free happens now.
+	 * This should fix the inode inconsistency problem.
+	 */
+	yaffs_handle_defered_free(obj);
+}
+
+/* yaffs_evict_inode combines into one operation what was previously done in
+ * yaffs_clear_inode() and yaffs_delete_inode()
+ *
+ */
+static void yaffs_evict_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	int deleteme = 0;
+
+	obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_evict_inode: ino %d, count %d %s",
+		(int)inode->i_ino,
+		atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (!inode->i_nlink && !is_bad_inode(inode))
+		deleteme = 1;
+	truncate_inode_pages(&inode->i_data, 0);
+	end_writeback(inode);
+
+	if (deleteme && obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
+	}
+
+}
+
+static void yaffs_touch_super(struct yaffs_dev *dev)
+{
+	struct super_block *sb = yaffs_dev_to_lc(dev)->super;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_touch_super() sb = %p", sb);
+	if (sb)
+		sb->s_dirt = 1;
+}
+
+static int yaffs_readpage_nolock(struct file *f, struct page *pg)
+{
+	/* Lifted from jffs2 */
+
+	struct yaffs_obj *obj;
+	unsigned char *pg_buf;
+	int ret;
+	struct yaffs_dev *dev;
+	loff_t pos = ((loff_t) pg->index) << PAGE_CACHE_SHIFT;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readpage_nolock at %lld, size %08x",
+		(long long)pos,
+		(unsigned)PAGE_CACHE_SIZE);
+
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	BUG_ON(!PageLocked(pg));
+
+	pg_buf = kmap(pg);
+	/* FIXME: Can kmap fail? */
+
+	yaffs_gross_lock(dev);
+
+	ret = yaffs_file_rd(obj, pg_buf, pos, PAGE_CACHE_SIZE);
+
+	yaffs_gross_unlock(dev);
+
+	if (ret >= 0)
+		ret = 0;
+
+	if (ret) {
+		ClearPageUptodate(pg);
+		SetPageError(pg);
+	} else {
+		SetPageUptodate(pg);
+		ClearPageError(pg);
+	}
+
+	flush_dcache_page(pg);
+	kunmap(pg);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage_nolock done");
+	return ret;
+}
+
+static int yaffs_readpage_unlock(struct file *f, struct page *pg)
+{
+	int ret = yaffs_readpage_nolock(f, pg);
+
+	unlock_page(pg);
+	return ret;
+}
+
+static int yaffs_readpage(struct file *f, struct page *pg)
+{
+	int ret;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage");
+	ret = yaffs_readpage_unlock(f, pg);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage done");
+	return ret;
+}
+
+/* writepage inspired by/stolen from smbfs */
+
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc)
+{
+	struct yaffs_dev *dev;
+	struct address_space *mapping = page->mapping;
+	struct inode *inode;
+	unsigned long end_index;
+	char *buffer;
+	struct yaffs_obj *obj;
+	int n_written = 0;
+	unsigned n_bytes;
+	loff_t i_size;
+
+	if (!mapping)
+		BUG();
+	inode = mapping->host;
+	if (!inode)
+		BUG();
+	i_size = i_size_read(inode);
+
+	end_index = i_size >> PAGE_CACHE_SHIFT;
+
+	if (page->index < end_index)
+		n_bytes = PAGE_CACHE_SIZE;
+	else {
+		n_bytes = i_size & (PAGE_CACHE_SIZE - 1);
+
+		if (page->index > end_index || !n_bytes) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_writepage at %08x, inode size = %08x!!!",
+				(unsigned)(page->index << PAGE_CACHE_SHIFT),
+				(unsigned)inode->i_size);
+			yaffs_trace(YAFFS_TRACE_OS,
+			  "                -> don't care!!");
+
+			zero_user_segment(page, 0, PAGE_CACHE_SIZE);
+			set_page_writeback(page);
+			unlock_page(page);
+			end_page_writeback(page);
+			return 0;
+		}
+	}
+
+	if (n_bytes != PAGE_CACHE_SIZE)
+		zero_user_segment(page, n_bytes, PAGE_CACHE_SIZE);
+
+	get_page(page);
+
+	buffer = kmap(page);
+
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_writepage at %08x, size %08x",
+		(unsigned)(page->index << PAGE_CACHE_SHIFT), n_bytes);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag0: obj = %05x, ino = %05x",
+		(int)obj->variant.file_variant.file_size, (int)inode->i_size);
+
+	n_written = yaffs_wr_file(obj, buffer,
+				  ((loff_t)page->index) << PAGE_CACHE_SHIFT,
+				  n_bytes, 0);
+
+	yaffs_touch_super(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag1: obj = %05x, ino = %05x",
+		(int)obj->variant.file_variant.file_size, (int)inode->i_size);
+
+	yaffs_gross_unlock(dev);
+
+	kunmap(page);
+	set_page_writeback(page);
+	unlock_page(page);
+	end_page_writeback(page);
+	put_page(page);
+
+	return (n_written == n_bytes) ? 0 : -ENOSPC;
+}
+
+/* Space holding and freeing is done to ensure we have space available for
+ * write_begin/end.
+ * For now we just assume few parallel writes and check against a small
+ * number.
+ * Todo: need to do this with a counter to handle parallel reads better
+ */
+
+static ssize_t yaffs_hold_space(struct file *f)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	int n_free_chunks;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	n_free_chunks = yaffs_get_n_free_chunks(dev);
+
+	yaffs_gross_unlock(dev);
+
+	return (n_free_chunks > 20) ? 1 : 0;
+}
+
+static void yaffs_release_space(struct file *f)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_gross_unlock(dev);
+}
+
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+			     loff_t pos, unsigned len, unsigned flags,
+			     struct page **pagep, void **fsdata)
+{
+	struct page *pg = NULL;
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+	int ret = 0;
+	int space_held = 0;
+
+	/* Get a page */
+	pg = grab_cache_page_write_begin(mapping, index, flags);
+
+	*pagep = pg;
+	if (!pg) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"start yaffs_write_begin index %d(%x) uptodate %d",
+		(int)index, (int)index, PageUptodate(pg) ? 1 : 0);
+
+	/* Get fs space */
+	space_held = yaffs_hold_space(filp);
+
+	if (!space_held) {
+		ret = -ENOSPC;
+		goto out;
+	}
+
+	/* Update page if required */
+
+	if (!PageUptodate(pg))
+		ret = yaffs_readpage_nolock(filp, pg);
+
+	if (ret)
+		goto out;
+
+	/* Happy path return */
+	yaffs_trace(YAFFS_TRACE_OS, "end yaffs_write_begin - ok");
+
+	return 0;
+
+out:
+	yaffs_trace(YAFFS_TRACE_OS,
+		"end yaffs_write_begin fail returning %d", ret);
+	if (space_held)
+		yaffs_release_space(filp);
+	if (pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
+	}
+	return ret;
+}
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t *pos)
+{
+	struct yaffs_obj *obj;
+	int n_written, ipos;
+	struct inode *inode;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	if (!obj) {
+		/* This should not happen */
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_file_write: hey obj is null!");
+		return -EINVAL;
+	}
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	inode = f->f_dentry->d_inode;
+
+	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
+		ipos = inode->i_size;
+	else
+		ipos = *pos;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write about to write writing %u(%x) bytes to object %d at %d(%x)",
+		(unsigned)n, (unsigned)n, obj->obj_id, ipos, ipos);
+
+	n_written = yaffs_wr_file(obj, buf, ipos, n, 0);
+
+	yaffs_touch_super(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write: %d(%x) bytes written",
+		(unsigned)n, (unsigned)n);
+
+	if (n_written > 0) {
+		ipos += n_written;
+		*pos = ipos;
+		if (ipos > inode->i_size) {
+			inode->i_size = ipos;
+			inode->i_blocks = (ipos + 511) >> 9;
+
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_file_write size updated to %d bytes, %d blocks",
+				ipos, (int)(inode->i_blocks));
+		}
+	}
+	yaffs_gross_unlock(dev);
+	return (n_written == 0) && (n > 0) ? -ENOSPC : n_written;
+}
+
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata)
+{
+	int ret = 0;
+	void *addr, *kva;
+	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
+
+	kva = kmap(pg);
+	addr = kva + offset_into_page;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_write_end addr %p pos %x n_bytes %d",
+		addr, (unsigned)pos, copied);
+
+	ret = yaffs_file_write(filp, addr, copied, &pos);
+
+	if (ret != copied) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_write_end not same size ret %d  copied %d",
+			ret, copied);
+		SetPageError(pg);
+	}
+
+	kunmap(pg);
+
+	yaffs_release_space(filp);
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+	struct super_block *sb = dentry->d_sb;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_statfs");
+
+	yaffs_gross_lock(dev);
+
+	buf->f_type = YAFFS_MAGIC;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_namelen = 255;
+
+	if (dev->data_bytes_per_chunk & (dev->data_bytes_per_chunk - 1)) {
+		/* Do this if chunk size is not a power of 2 */
+
+		uint64_t bytes_in_dev;
+		uint64_t bytes_free;
+
+		bytes_in_dev =
+		    ((uint64_t)
+		     ((dev->param.end_block - dev->param.start_block + 1))) *
+		     ((uint64_t) (dev->param.chunks_per_block *
+					   dev->data_bytes_per_chunk));
+
+		do_div(bytes_in_dev, sb->s_blocksize);
+			/* bytes_in_dev becomes the number of blocks */
+		buf->f_blocks = bytes_in_dev;
+
+		bytes_free = ((uint64_t) (yaffs_get_n_free_chunks(dev))) *
+		    ((uint64_t) (dev->data_bytes_per_chunk));
+
+		do_div(bytes_free, sb->s_blocksize);
+
+		buf->f_bfree = bytes_free;
+
+	} else if (sb->s_blocksize > dev->data_bytes_per_chunk) {
+
+		buf->f_blocks =
+		    (dev->param.end_block - dev->param.start_block + 1) *
+		    dev->param.chunks_per_block /
+		    (sb->s_blocksize / dev->data_bytes_per_chunk);
+		buf->f_bfree =
+		    yaffs_get_n_free_chunks(dev) /
+		    (sb->s_blocksize / dev->data_bytes_per_chunk);
+	} else {
+		buf->f_blocks =
+		    (dev->param.end_block - dev->param.start_block + 1) *
+		    dev->param.chunks_per_block *
+		    (dev->data_bytes_per_chunk / sb->s_blocksize);
+
+		buf->f_bfree =
+		    yaffs_get_n_free_chunks(dev) *
+		    (dev->data_bytes_per_chunk / sb->s_blocksize);
+	}
+
+	buf->f_files = 0;
+	buf->f_ffree = 0;
+	buf->f_bavail = buf->f_bfree;
+
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+
+static void yaffs_flush_inodes(struct super_block *sb)
+{
+	struct inode *iptr;
+	struct yaffs_obj *obj;
+
+	list_for_each_entry(iptr, &sb->s_inodes, i_sb_list) {
+		obj = yaffs_inode_to_obj(iptr);
+		if (obj) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"flushing obj %d", obj->obj_id);
+			yaffs_flush_file(obj, 1, 0);
+		}
+	}
+}
+
+static void yaffs_flush_super(struct super_block *sb, int do_checkpoint)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+
+	if (!dev)
+		return;
+
+	yaffs_flush_inodes(sb);
+	yaffs_update_dirty_dirs(dev);
+	yaffs_flush_whole_cache(dev);
+	if (do_checkpoint)
+		yaffs_checkpoint_save(dev);
+}
+
+static unsigned yaffs_bg_gc_urgency(struct yaffs_dev *dev)
+{
+	unsigned erased_chunks =
+	    dev->n_erased_blocks * dev->param.chunks_per_block;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned scattered = 0;	/* Free chunks not in an erased block */
+
+	if (erased_chunks < dev->n_free_chunks)
+		scattered = (dev->n_free_chunks - erased_chunks);
+
+	if (!context->bg_running)
+		return 0;
+	else if (scattered < (dev->param.chunks_per_block * 2))
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 2)
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 4)
+		return 1;
+	else
+		return 2;
+}
+
+static int yaffs_do_sync_fs(struct super_block *sb, int request_checkpoint)
+{
+
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	unsigned int oneshot_checkpoint = (yaffs_auto_checkpoint & 4);
+	unsigned gc_urgent = yaffs_bg_gc_urgency(dev);
+	int do_checkpoint;
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		"yaffs_do_sync_fs: gc-urgency %d %s %s%s",
+		gc_urgent,
+		sb->s_dirt ? "dirty" : "clean",
+		request_checkpoint ? "checkpoint requested" : "no checkpoint",
+		oneshot_checkpoint ? " one-shot" : "");
+
+	yaffs_gross_lock(dev);
+	do_checkpoint = ((request_checkpoint && !gc_urgent) ||
+			 oneshot_checkpoint) && !dev->is_checkpointed;
+
+	if (sb->s_dirt || do_checkpoint) {
+		yaffs_flush_super(sb, !dev->is_checkpointed && do_checkpoint);
+		sb->s_dirt = 0;
+		if (oneshot_checkpoint)
+			yaffs_auto_checkpoint &= ~4;
+	}
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+/*
+ * yaffs background thread functions .
+ * yaffs_bg_thread_fn() the thread function
+ * yaffs_bg_start() launches the background thread.
+ * yaffs_bg_stop() cleans up the background thread.
+ *
+ * NB:
+ * The thread should only run after the yaffs is initialised
+ * The thread should be stopped before yaffs is unmounted.
+ * The thread should not do any writing while the fs is in read only.
+ */
+
+void yaffs_background_waker(unsigned long data)
+{
+	wake_up_process((struct task_struct *)data);
+}
+
+static int yaffs_bg_thread_fn(void *data)
+{
+	struct yaffs_dev *dev = (struct yaffs_dev *)data;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned long now = jiffies;
+	unsigned long next_dir_update = now;
+	unsigned long next_gc = now;
+	unsigned long expires;
+	unsigned int urgency;
+	int gc_result;
+	struct timer_list timer;
+
+	yaffs_trace(YAFFS_TRACE_BACKGROUND,
+		"yaffs_background starting for dev %p", (void *)dev);
+
+	set_freezable();
+	while (context->bg_running) {
+		yaffs_trace(YAFFS_TRACE_BACKGROUND, "yaffs_background");
+
+		if (kthread_should_stop())
+			break;
+
+		if (try_to_freeze())
+			continue;
+
+		yaffs_gross_lock(dev);
+
+		now = jiffies;
+
+		if (time_after(now, next_dir_update) && yaffs_bg_enable) {
+			yaffs_update_dirty_dirs(dev);
+			next_dir_update = now + HZ;
+		}
+
+		if (time_after(now, next_gc) && yaffs_bg_enable) {
+			if (!dev->is_checkpointed) {
+				urgency = yaffs_bg_gc_urgency(dev);
+				gc_result = yaffs_bg_gc(dev, urgency);
+				if (urgency > 1)
+					next_gc = now + HZ / 20 + 1;
+				else if (urgency > 0)
+					next_gc = now + HZ / 10 + 1;
+				else
+					next_gc = now + HZ * 2;
+			} else	{
+				/*
+				 * gc not running so set to next_dir_update
+				 * to cut down on wake ups
+				 */
+				next_gc = next_dir_update;
+			}
+		}
+		yaffs_gross_unlock(dev);
+		expires = next_dir_update;
+		if (time_before(next_gc, expires))
+			expires = next_gc;
+		if (time_before(expires, now))
+			expires = now + HZ;
+
+		init_timer_on_stack(&timer);
+		timer.expires = expires + 1;
+		timer.data = (unsigned long)current;
+		timer.function = yaffs_background_waker;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_timer(&timer);
+		schedule();
+		del_timer_sync(&timer);
+	}
+
+	return 0;
+}
+
+static int yaffs_bg_start(struct yaffs_dev *dev)
+{
+	int retval = 0;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+
+	if (dev->read_only)
+		return -1;
+
+	context->bg_running = 1;
+
+	context->bg_thread = kthread_run(yaffs_bg_thread_fn,
+					 (void *)dev, "yaffs-bg-%d",
+					 context->mount_id);
+
+	if (IS_ERR(context->bg_thread)) {
+		retval = PTR_ERR(context->bg_thread);
+		context->bg_thread = NULL;
+		context->bg_running = 0;
+	}
+	return retval;
+}
+
+static void yaffs_bg_stop(struct yaffs_dev *dev)
+{
+	struct yaffs_linux_context *ctxt = yaffs_dev_to_lc(dev);
+
+	ctxt->bg_running = 0;
+
+	if (ctxt->bg_thread) {
+		kthread_stop(ctxt->bg_thread);
+		ctxt->bg_thread = NULL;
+	}
+}
+
+static void yaffs_write_super(struct super_block *sb)
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 2);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		"yaffs_write_super%s",
+		request_checkpoint ? " checkpt" : "");
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+}
+
+static int yaffs_sync_fs(struct super_block *sb, int wait)
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 1);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		"yaffs_sync_fs%s", request_checkpoint ? " checkpt" : "");
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+	return 0;
+}
+
+static LIST_HEAD(yaffs_context_list);
+struct mutex yaffs_context_lock;
+
+struct yaffs_options {
+	int inband_tags;
+	int skip_checkpoint_read;
+	int skip_checkpoint_write;
+	int no_cache;
+	int tags_ecc_on;
+	int tags_ecc_overridden;
+	int lazy_loading_enabled;
+	int lazy_loading_overridden;
+	int empty_lost_and_found;
+	int empty_lost_and_found_overridden;
+};
+
+#define MAX_OPT_LEN 30
+static int yaffs_parse_options(struct yaffs_options *options,
+				const char *options_str)
+{
+	char cur_opt[MAX_OPT_LEN + 1];
+	int p;
+	int error = 0;
+
+	/* Parse through the options which is a comma seperated list */
+
+	while (options_str && *options_str && !error) {
+		memset(cur_opt, 0, MAX_OPT_LEN + 1);
+		p = 0;
+
+		while (*options_str == ',')
+			options_str++;
+
+		while (*options_str && *options_str != ',') {
+			if (p < MAX_OPT_LEN) {
+				cur_opt[p] = *options_str;
+				p++;
+			}
+			options_str++;
+		}
+
+		if (!strcmp(cur_opt, "inband-tags")) {
+			options->inband_tags = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-off")) {
+			options->tags_ecc_on = 0;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-on")) {
+			options->tags_ecc_on = 1;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-off")) {
+			options->lazy_loading_enabled = 0;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-on")) {
+			options->lazy_loading_enabled = 1;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-off")) {
+			options->empty_lost_and_found = 0;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-on")) {
+			options->empty_lost_and_found = 1;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "no-cache")) {
+			options->no_cache = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-read")) {
+			options->skip_checkpoint_read = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-write")) {
+			options->skip_checkpoint_write = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint")) {
+			options->skip_checkpoint_read = 1;
+			options->skip_checkpoint_write = 1;
+		} else {
+			printk(KERN_INFO "yaffs: Bad mount option \"%s\"\n",
+			       cur_opt);
+			error = 1;
+		}
+	}
+	return error;
+}
+
+static const struct address_space_operations yaffs_file_address_operations = {
+	.readpage = yaffs_readpage,
+	.writepage = yaffs_writepage,
+	.write_begin = yaffs_write_begin,
+	.write_end = yaffs_write_end,
+};
+
+
+
+static const struct inode_operations yaffs_file_inode_operations = {
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+static const struct inode_operations yaffs_symlink_inode_operations = {
+	.readlink = yaffs_readlink,
+	.follow_link = yaffs_follow_link,
+	.put_link = yaffs_put_link,
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+static void yaffs_fill_inode_from_obj(struct inode *inode,
+				      struct yaffs_obj *obj)
+{
+	u32 mode;
+
+	if (!inode || !obj)  {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_fill_inode invalid parameters");
+		return;
+	}
+
+	/* Check mode against the variant type
+	 * and attempt to repair if broken. */
+	mode = obj->yst_mode;
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		if (!S_ISREG(mode)) {
+			obj->yst_mode &= ~S_IFMT;
+			obj->yst_mode |= S_IFREG;
+		}
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		if (!S_ISLNK(mode)) {
+			obj->yst_mode &= ~S_IFMT;
+			obj->yst_mode |= S_IFLNK;
+		}
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		if (!S_ISDIR(mode)) {
+			obj->yst_mode &= ~S_IFMT;
+			obj->yst_mode |= S_IFDIR;
+		}
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+	default:
+		/* TODO? */
+		break;
+	}
+
+	inode->i_flags |= S_NOATIME;
+	inode->i_ino = obj->obj_id;
+	inode->i_mode = obj->yst_mode;
+	inode->i_uid = obj->yst_uid;
+	inode->i_gid = obj->yst_gid;
+
+	inode->i_rdev = old_decode_dev(obj->yst_rdev);
+
+	inode->i_atime.tv_sec = (time_t) (obj->yst_atime);
+	inode->i_atime.tv_nsec = 0;
+	inode->i_mtime.tv_sec = (time_t) obj->yst_mtime;
+	inode->i_mtime.tv_nsec = 0;
+	inode->i_ctime.tv_sec = (time_t) obj->yst_ctime;
+	inode->i_ctime.tv_nsec = 0;
+	inode->i_size = yaffs_get_obj_length(obj);
+	inode->i_blocks = (inode->i_size + 511) >> 9;
+	set_nlink(inode, yaffs_get_obj_link_count(obj));
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_fill_inode mode %x uid %d gid %d size %d count %d",
+		inode->i_mode, inode->i_uid, inode->i_gid,
+		(int)inode->i_size, atomic_read(&inode->i_count));
+
+	switch (obj->yst_mode & S_IFMT) {
+	default:	/* fifo, device or socket */
+		init_special_inode(inode, obj->yst_mode,
+				   old_decode_dev(obj->yst_rdev));
+		break;
+	case S_IFREG:	/* file */
+		inode->i_op = &yaffs_file_inode_operations;
+		inode->i_fop = &yaffs_file_operations;
+		inode->i_mapping->a_ops = &yaffs_file_address_operations;
+		break;
+	case S_IFDIR:	/* directory */
+		inode->i_op = &yaffs_dir_inode_operations;
+		inode->i_fop = &yaffs_dir_operations;
+		break;
+	case S_IFLNK:	/* symlink */
+		inode->i_op = &yaffs_symlink_inode_operations;
+		break;
+	}
+
+	yaffs_inode_to_obj_lv(inode) = obj;
+	obj->my_inode = inode;
+}
+
+static void yaffs_put_super(struct super_block *sb)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_put_super");
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"Shutting down yaffs background thread");
+	yaffs_bg_stop(dev);
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"yaffs background thread shut down");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_super(sb, 1);
+
+	if (yaffs_dev_to_lc(dev)->put_super_fn)
+		yaffs_dev_to_lc(dev)->put_super_fn(sb);
+
+	yaffs_deinitialise(dev);
+
+	yaffs_gross_unlock(dev);
+	mutex_lock(&yaffs_context_lock);
+	list_del_init(&(yaffs_dev_to_lc(dev)->context_list));
+	mutex_unlock(&yaffs_context_lock);
+
+	if (yaffs_dev_to_lc(dev)->spare_buffer) {
+		kfree(yaffs_dev_to_lc(dev)->spare_buffer);
+		yaffs_dev_to_lc(dev)->spare_buffer = NULL;
+	}
+
+	kfree(dev);
+}
+
+static void yaffs_mtd_put_super(struct super_block *sb)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(yaffs_super_to_dev(sb));
+
+	if (mtd->sync)
+		mtd->sync(mtd);
+
+	put_mtd_device(mtd);
+}
+
+static const struct super_operations yaffs_super_ops = {
+	.statfs = yaffs_statfs,
+	.put_super = yaffs_put_super,
+	.evict_inode = yaffs_evict_inode,
+	.sync_fs = yaffs_sync_fs,
+	.write_super = yaffs_write_super,
+};
+
+static struct super_block *yaffs_internal_read_super(int yaffs_version,
+						     struct super_block *sb,
+						     void *data, int silent)
+{
+	int n_blocks;
+	struct inode *inode = NULL;
+	struct dentry *root;
+	struct yaffs_dev *dev = 0;
+	char devname_buf[BDEVNAME_SIZE + 1];
+	struct mtd_info *mtd;
+	int err;
+	char *data_str = (char *)data;
+	struct yaffs_linux_context *context = NULL;
+	struct yaffs_param *param;
+	int read_only = 0;
+	struct yaffs_options options;
+	unsigned mount_id;
+	int found;
+	struct yaffs_linux_context *context_iterator;
+	struct list_head *l;
+
+	if (!sb) {
+		printk(KERN_INFO "yaffs: sb is NULL\n");
+		return NULL;
+	}
+
+	sb->s_magic = YAFFS_MAGIC;
+	sb->s_op = &yaffs_super_ops;
+	sb->s_flags |= MS_NOATIME;
+
+	read_only = ((sb->s_flags & MS_RDONLY) != 0);
+
+	sb->s_export_op = &yaffs_export_ops;
+
+	if (!sb->s_dev)
+		printk(KERN_INFO "yaffs: sb->s_dev is NULL\n");
+	else if (!yaffs_devname(sb, devname_buf))
+		printk(KERN_INFO "yaffs: devname is NULL\n");
+	else
+		printk(KERN_INFO "yaffs: dev is %d name is \"%s\" %s\n",
+		       sb->s_dev,
+		       yaffs_devname(sb, devname_buf), read_only ? "ro" : "rw");
+
+	if (!data_str)
+		data_str = "";
+
+	printk(KERN_INFO "yaffs: passed flags \"%s\"\n", data_str);
+
+	memset(&options, 0, sizeof(options));
+
+	if (yaffs_parse_options(&options, data_str))
+		/* Option parsing failed */
+		return NULL;
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: Using yaffs%d", yaffs_version);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: block size %d", (int)(sb->s_blocksize));
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"Attempting MTD mount of %u.%u,\"%s\"",
+		MAJOR(sb->s_dev), MINOR(sb->s_dev),
+		yaffs_devname(sb, devname_buf));
+
+	/* Check it's an mtd device..... */
+	if (MAJOR(sb->s_dev) != MTD_BLOCK_MAJOR)
+		return NULL;	/* This isn't an mtd device */
+
+	/* Get the device */
+	mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
+	if (!mtd) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"MTD device #%u doesn't appear to exist",
+			MINOR(sb->s_dev));
+		return NULL;
+	}
+	/* Check it's NAND */
+	if (mtd->type != MTD_NANDFLASH) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"MTD device is not NAND it's type %d",
+			mtd->type);
+		return NULL;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, " erase %p", mtd->erase);
+	yaffs_trace(YAFFS_TRACE_OS, " read %p", mtd->read);
+	yaffs_trace(YAFFS_TRACE_OS, " write %p", mtd->write);
+	yaffs_trace(YAFFS_TRACE_OS, " readoob %p", mtd->read_oob);
+	yaffs_trace(YAFFS_TRACE_OS, " writeoob %p", mtd->write_oob);
+	yaffs_trace(YAFFS_TRACE_OS, " block_isbad %p", mtd->block_isbad);
+	yaffs_trace(YAFFS_TRACE_OS, " block_markbad %p", mtd->block_markbad);
+	yaffs_trace(YAFFS_TRACE_OS, " writesize %d", mtd->writesize);
+	yaffs_trace(YAFFS_TRACE_OS, " oobsize %d", mtd->oobsize);
+	yaffs_trace(YAFFS_TRACE_OS, " erasesize %d", mtd->erasesize);
+	yaffs_trace(YAFFS_TRACE_OS, " size %lld", mtd->size);
+
+	if (yaffs_auto_select && yaffs_version == 1 && mtd->writesize >= 2048) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs2");
+		yaffs_version = 2;
+	}
+
+	if (yaffs_auto_select && yaffs_version == 2 && !options.inband_tags &&
+		mtd->writesize == 512) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs1");
+		yaffs_version = 1;
+	}
+
+	if (yaffs_version == 2) {
+		/* Check for version 2 style functions */
+		if (!mtd->erase ||
+		    !mtd->block_isbad ||
+		    !mtd->block_markbad ||
+		    !mtd->read ||
+		    !mtd->write || !mtd->read_oob || !mtd->write_oob) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support required functions");
+			return NULL;
+		}
+
+		if ((mtd->writesize < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||
+		     mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&
+		    !options.inband_tags) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not have the right page sizes");
+			return NULL;
+		}
+	} else {
+		/* Check for V1 style functions */
+		if (!mtd->erase ||
+		    !mtd->read ||
+		    !mtd->write || !mtd->read_oob || !mtd->write_oob) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support required functions");
+			return NULL;
+		}
+
+		if (mtd->writesize < YAFFS_BYTES_PER_CHUNK ||
+		    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support have the right page sizes");
+			return NULL;
+		}
+	}
+
+	/* OK, so if we got here, we have an MTD that's NAND and looks
+	 * like it has the right capabilities
+	 * Set the struct yaffs_dev up for mtd
+	 */
+
+	if (!read_only && !(mtd->flags & MTD_WRITEABLE)) {
+		read_only = 1;
+		printk(KERN_INFO
+		       "yaffs: mtd is read only, setting superblock read only");
+		sb->s_flags |= MS_RDONLY;
+	}
+
+	dev = kmalloc(sizeof(struct yaffs_dev), GFP_KERNEL);
+	context = kmalloc(sizeof(struct yaffs_linux_context), GFP_KERNEL);
+
+	if (!dev || !context) {
+		kfree(dev);
+		kfree(context);
+		dev = NULL;
+		context = NULL;
+	}
+
+	if (!dev) {
+		/* Deep shit could not allocate device structure */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs_read_super failed trying to allocate yaffs_dev");
+		return NULL;
+	}
+	memset(dev, 0, sizeof(struct yaffs_dev));
+	param = &(dev->param);
+
+	memset(context, 0, sizeof(struct yaffs_linux_context));
+	dev->os_context = context;
+	INIT_LIST_HEAD(&(context->context_list));
+	context->dev = dev;
+	context->super = sb;
+
+	dev->read_only = read_only;
+
+	sb->s_fs_info = dev;
+
+	dev->driver_context = mtd;
+	param->name = mtd->name;
+
+	/* Set up the memory size parameters.... */
+
+	n_blocks =
+	    YCALCBLOCKS(mtd->size,
+			(YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK));
+
+	param->start_block = 0;
+	param->end_block = n_blocks - 1;
+	param->chunks_per_block = YAFFS_CHUNKS_PER_BLOCK;
+	param->total_bytes_per_chunk = YAFFS_BYTES_PER_CHUNK;
+	param->n_reserved_blocks = 5;
+	param->n_caches = (options.no_cache) ? 0 : 10;
+	param->inband_tags = options.inband_tags;
+
+	param->disable_lazy_load = 1;
+	param->enable_xattr = 1;
+	if (options.lazy_loading_overridden)
+		param->disable_lazy_load = !options.lazy_loading_enabled;
+
+	param->defered_dir_update = 1;
+
+	if (options.tags_ecc_overridden)
+		param->no_tags_ecc = !options.tags_ecc_on;
+
+	param->empty_lost_n_found = 1;
+
+	param->refresh_period = 500;
+
+	if (options.empty_lost_and_found_overridden)
+		param->empty_lost_n_found = options.empty_lost_and_found;
+
+	/* ... and the functions. */
+	if (yaffs_version == 2) {
+		param->write_chunk_tags_fn = nandmtd2_write_chunk_tags;
+		param->read_chunk_tags_fn = nandmtd2_read_chunk_tags;
+		param->bad_block_fn = nandmtd2_mark_block_bad;
+		param->query_block_fn = nandmtd2_query_block;
+		yaffs_dev_to_lc(dev)->spare_buffer =
+				kmalloc(mtd->oobsize, GFP_NOFS);
+		param->is_yaffs2 = 1;
+		param->total_bytes_per_chunk = mtd->writesize;
+		param->chunks_per_block = mtd->erasesize / mtd->writesize;
+		n_blocks = YCALCBLOCKS(mtd->size, mtd->erasesize);
+
+		param->start_block = 0;
+		param->end_block = n_blocks - 1;
+	} else {
+		/* use the MTD interface in yaffs_mtdif1.c */
+		param->write_chunk_tags_fn = nandmtd1_write_chunk_tags;
+		param->read_chunk_tags_fn = nandmtd1_read_chunk_tags;
+		param->bad_block_fn = nandmtd1_mark_block_bad;
+		param->query_block_fn = nandmtd1_query_block;
+		param->is_yaffs2 = 0;
+	}
+	/* ... and common functions */
+	param->erase_fn = nandmtd_erase_block;
+	param->initialise_flash_fn = nandmtd_initialise;
+
+	yaffs_dev_to_lc(dev)->put_super_fn = yaffs_mtd_put_super;
+
+	param->sb_dirty_fn = yaffs_touch_super;
+	param->gc_control = yaffs_gc_control_callback;
+
+	yaffs_dev_to_lc(dev)->super = sb;
+
+	param->use_nand_ecc = 1;
+
+	param->skip_checkpt_rd = options.skip_checkpoint_read;
+	param->skip_checkpt_wr = options.skip_checkpoint_write;
+
+	mutex_lock(&yaffs_context_lock);
+	/* Get a mount id */
+	for (mount_id = 0, found = 0; !found; mount_id++) {
+		found = 1;
+		list_for_each(l, &yaffs_context_list) {
+			context_iterator =
+				list_entry(l, struct yaffs_linux_context,
+					context_list);
+			if (context_iterator->mount_id == mount_id)
+				found = 0;
+		}
+	}
+	context->mount_id = mount_id;
+
+	list_add_tail(&(yaffs_dev_to_lc(dev)->context_list),
+		      &yaffs_context_list);
+	mutex_unlock(&yaffs_context_lock);
+
+	/* Directory search handling... */
+	INIT_LIST_HEAD(&(yaffs_dev_to_lc(dev)->search_contexts));
+	param->remove_obj_fn = yaffs_remove_obj_callback;
+
+	mutex_init(&(yaffs_dev_to_lc(dev)->gross_lock));
+
+	yaffs_gross_lock(dev);
+
+	err = yaffs_guts_initialise(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: guts initialised %s",
+		(err == YAFFS_OK) ? "OK" : "FAILED");
+
+	if (err == YAFFS_OK)
+		yaffs_bg_start(dev);
+
+	if (!context->bg_thread)
+		param->defered_dir_update = 0;
+
+	sb->s_maxbytes = yaffs_max_file_size(dev);
+
+	/* Release lock before yaffs_get_inode() */
+	yaffs_gross_unlock(dev);
+
+	/* Create root inode */
+	if (err == YAFFS_OK)
+		inode = yaffs_get_inode(sb, S_IFDIR | 0755, 0, yaffs_root(dev));
+
+	if (!inode)
+		return NULL;
+
+	inode->i_op = &yaffs_dir_inode_operations;
+	inode->i_fop = &yaffs_dir_operations;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: got root inode");
+
+	root = d_alloc_root(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: d_alloc_root done");
+
+	if (!root) {
+		iput(inode);
+		return NULL;
+	}
+	sb->s_root = root;
+	sb->s_dirt = !dev->is_checkpointed;
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs_read_super: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: done");
+	return sb;
+}
+
+static int yaffs_internal_read_super_mtd(struct super_block *sb, void *data,
+					 int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;
+}
+
+static struct dentry *yaffs_mount(struct file_system_type *fs,
+			    int flags, const char *dev_name,
+			    void *data)
+{
+	return mount_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd);
+}
+
+static struct file_system_type yaffs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs",
+	.mount = yaffs_mount,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+
+static int yaffs2_internal_read_super_mtd(struct super_block *sb, void *data,
+					  int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;
+}
+
+static struct dentry *yaffs2_mount(struct file_system_type *fs,
+			     int flags, const char *dev_name, void *data)
+{
+	return mount_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd);
+}
+
+static struct file_system_type yaffs2_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs2",
+	.mount = yaffs2_mount,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+
+
+static struct proc_dir_entry *my_proc_entry;
+
+static char *yaffs_dump_dev_part0(char *buf, struct yaffs_dev *dev)
+{
+	struct yaffs_param *param = &dev->param;
+
+	buf += sprintf(buf, "start_block........... %d\n", param->start_block);
+	buf += sprintf(buf, "end_block............. %d\n", param->end_block);
+	buf += sprintf(buf, "total_bytes_per_chunk. %d\n",
+			param->total_bytes_per_chunk);
+	buf += sprintf(buf, "use_nand_ecc.......... %d\n",
+			param->use_nand_ecc);
+	buf += sprintf(buf, "no_tags_ecc........... %d\n", param->no_tags_ecc);
+	buf += sprintf(buf, "is_yaffs2............. %d\n", param->is_yaffs2);
+	buf += sprintf(buf, "inband_tags........... %d\n", param->inband_tags);
+	buf += sprintf(buf, "empty_lost_n_found.... %d\n",
+			param->empty_lost_n_found);
+	buf += sprintf(buf, "disable_lazy_load..... %d\n",
+			param->disable_lazy_load);
+	buf += sprintf(buf, "refresh_period........ %d\n",
+			param->refresh_period);
+	buf += sprintf(buf, "n_caches.............. %d\n", param->n_caches);
+	buf += sprintf(buf, "n_reserved_blocks..... %d\n",
+			param->n_reserved_blocks);
+	buf += sprintf(buf, "always_check_erased... %d\n",
+			param->always_check_erased);
+
+	return buf;
+}
+
+static char *yaffs_dump_dev_part1(char *buf, struct yaffs_dev *dev)
+{
+	buf += sprintf(buf, "max file size......... %lld\n",
+			(long long) yaffs_max_file_size(dev));
+	buf += sprintf(buf, "data_bytes_per_chunk.. %d\n",
+			dev->data_bytes_per_chunk);
+	buf += sprintf(buf, "chunk_grp_bits........ %d\n", dev->chunk_grp_bits);
+	buf += sprintf(buf, "chunk_grp_size........ %d\n", dev->chunk_grp_size);
+	buf +=
+	    sprintf(buf, "n_erased_blocks....... %d\n", dev->n_erased_blocks);
+	buf +=
+	    sprintf(buf, "blocks_in_checkpt..... %d\n", dev->blocks_in_checkpt);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_tnodes.............. %d\n", dev->n_tnodes);
+	buf += sprintf(buf, "n_obj................. %d\n", dev->n_obj);
+	buf += sprintf(buf, "n_free_chunks......... %d\n", dev->n_free_chunks);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_page_writes......... %u\n", dev->n_page_writes);
+	buf += sprintf(buf, "n_page_reads.......... %u\n", dev->n_page_reads);
+	buf += sprintf(buf, "n_erasures............ %u\n", dev->n_erasures);
+	buf += sprintf(buf, "n_gc_copies........... %u\n", dev->n_gc_copies);
+	buf += sprintf(buf, "all_gcs............... %u\n", dev->all_gcs);
+	buf +=
+	    sprintf(buf, "passive_gc_count...... %u\n", dev->passive_gc_count);
+	buf +=
+	    sprintf(buf, "oldest_dirty_gc_count. %u\n",
+		    dev->oldest_dirty_gc_count);
+	buf += sprintf(buf, "n_gc_blocks........... %u\n", dev->n_gc_blocks);
+	buf += sprintf(buf, "bg_gcs................ %u\n", dev->bg_gcs);
+	buf +=
+	    sprintf(buf, "n_retried_writes...... %u\n", dev->n_retried_writes);
+	buf +=
+	    sprintf(buf, "n_retired_blocks...... %u\n", dev->n_retired_blocks);
+	buf += sprintf(buf, "n_ecc_fixed........... %u\n", dev->n_ecc_fixed);
+	buf += sprintf(buf, "n_ecc_unfixed......... %u\n", dev->n_ecc_unfixed);
+	buf +=
+	    sprintf(buf, "n_tags_ecc_fixed...... %u\n", dev->n_tags_ecc_fixed);
+	buf +=
+	    sprintf(buf, "n_tags_ecc_unfixed.... %u\n",
+		    dev->n_tags_ecc_unfixed);
+	buf += sprintf(buf, "cache_hits............ %u\n", dev->cache_hits);
+	buf +=
+	    sprintf(buf, "n_deleted_files....... %u\n", dev->n_deleted_files);
+	buf +=
+	    sprintf(buf, "n_unlinked_files...... %u\n", dev->n_unlinked_files);
+	buf += sprintf(buf, "refresh_count......... %u\n", dev->refresh_count);
+	buf += sprintf(buf, "n_bg_deletions........ %u\n", dev->n_bg_deletions);
+
+	return buf;
+}
+
+static int yaffs_proc_read(char *page,
+			   char **start,
+			   off_t offset, int count, int *eof, void *data)
+{
+	struct list_head *item;
+	char *buf = page;
+	int step = offset;
+	int n = 0;
+
+	/* Get proc_file_read() to step 'offset' by one on each sucessive call.
+	 * We use 'offset' (*ppos) to indicate where we are in dev_list.
+	 * This also assumes the user has posted a read buffer large
+	 * enough to hold the complete output; but that's life in /proc.
+	 */
+
+	*(int *)start = 1;
+
+	/* Print header first */
+	if (step == 0)
+		buf += sprintf(buf, "YAFFS built:" __DATE__ " " __TIME__ "\n");
+	else if (step == 1)
+		buf += sprintf(buf, "\n");
+	else {
+		step -= 2;
+
+		mutex_lock(&yaffs_context_lock);
+
+		/* Locate and print the Nth entry.
+		 * Order N-squared but N is small. */
+		list_for_each(item, &yaffs_context_list) {
+			struct yaffs_linux_context *dc =
+			    list_entry(item, struct yaffs_linux_context,
+				       context_list);
+			struct yaffs_dev *dev = dc->dev;
+
+			if (n < (step & ~1)) {
+				n += 2;
+				continue;
+			}
+			if ((step & 1) == 0) {
+				buf +=
+				    sprintf(buf, "\nDevice %d \"%s\"\n", n,
+					    dev->param.name);
+				buf = yaffs_dump_dev_part0(buf, dev);
+			} else {
+				buf = yaffs_dump_dev_part1(buf, dev);
+			}
+
+			break;
+		}
+		mutex_unlock(&yaffs_context_lock);
+	}
+
+	return buf - page < count ? buf - page : count;
+}
+
+
+
+/* Stuff to handle installation of file systems */
+struct file_system_to_install {
+	struct file_system_type *fst;
+	int installed;
+};
+
+static struct file_system_to_install fs_to_install[] = {
+	{&yaffs_fs_type, 0},
+	{&yaffs2_fs_type, 0},
+	{NULL, 0}
+};
+
+static int __init init_yaffs_fs(void)
+{
+	int error = 0;
+	struct file_system_to_install *fsinst;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs built " __DATE__ " " __TIME__ " Installing.");
+
+	mutex_init(&yaffs_context_lock);
+
+	/* Install the proc_fs entries */
+	my_proc_entry = create_proc_entry("yaffs",
+					  S_IRUGO | S_IFREG, NULL);
+
+	if (my_proc_entry) {
+		my_proc_entry->write_proc = NULL;
+		my_proc_entry->read_proc = yaffs_proc_read;
+		my_proc_entry->data = NULL;
+	} else {
+		return -ENOMEM;
+	}
+
+
+	/* Now add the file system entries */
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst && !error) {
+		error = register_filesystem(fsinst->fst);
+		if (!error)
+			fsinst->installed = 1;
+		fsinst++;
+	}
+
+	/* Any errors? uninstall  */
+	if (error) {
+		fsinst = fs_to_install;
+
+		while (fsinst->fst) {
+			if (fsinst->installed) {
+				unregister_filesystem(fsinst->fst);
+				fsinst->installed = 0;
+			}
+			fsinst++;
+		}
+	}
+
+	return error;
+}
+
+static void __exit exit_yaffs_fs(void)
+{
+
+	struct file_system_to_install *fsinst;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs built " __DATE__ " " __TIME__ " removing.");
+
+	remove_proc_entry("yaffs", NULL);
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst) {
+		if (fsinst->installed) {
+			unregister_filesystem(fsinst->fst);
+			fsinst->installed = 0;
+		}
+		fsinst++;
+	}
+}
+
+module_init(init_yaffs_fs)
+module_exit(exit_yaffs_fs)
+
+MODULE_DESCRIPTION("YAFFS2 - a NAND specific flash file system");
+MODULE_AUTHOR("Charles Manning, Aleph One Ltd., 2002-2011");
+MODULE_LICENSE("GPL");
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_yaffs1.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_yaffs1.c
--- linux-3.1.9/fs/yaffs2/yaffs_yaffs1.c	2012-06-20 14:51:23.982803635 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_yaffs1.c	2012-06-28 16:54:39.723622580 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -24,29 +24,25 @@
 	struct yaffs_ext_tags tags;
 	int blk;
 	int result;
-
 	int chunk;
 	int c;
 	int deleted;
 	enum yaffs_block_state state;
-	struct yaffs_obj *hard_list = NULL;
+	LIST_HEAD(hard_list);
 	struct yaffs_block_info *bi;
 	u32 seq_number;
 	struct yaffs_obj_hdr *oh;
 	struct yaffs_obj *in;
 	struct yaffs_obj *parent;
-
 	int alloc_failed = 0;
-
 	struct yaffs_shadow_fixer *shadow_fixers = NULL;
-
 	u8 *chunk_data;
 
 	yaffs_trace(YAFFS_TRACE_SCAN,
 		"yaffs1_scan starts  intstartblk %d intendblk %d...",
 		dev->internal_start_block, dev->internal_end_block);
 
-	chunk_data = yaffs_get_temp_buffer(dev, __LINE__);
+	chunk_data = yaffs_get_temp_buffer(dev);
 
 	dev->seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;
 
@@ -93,8 +89,9 @@
 		deleted = 0;
 
 		/* For each chunk in each block that needs scanning.... */
-		for (c = 0; !alloc_failed && c < dev->param.chunks_per_block &&
-		     state == YAFFS_BLOCK_STATE_NEEDS_SCANNING; c++) {
+		for (c = 0;
+			!alloc_failed && c < dev->param.chunks_per_block &&
+			state == YAFFS_BLOCK_STATE_NEEDS_SCAN; c++) {
 			/* Read the tags and decide what to do */
 			chunk = blk * dev->param.chunks_per_block + c;
 
@@ -103,14 +100,13 @@
 
 			/* Let's have a good look at this chunk... */
 
-			if (tags.ecc_result == YAFFS_ECC_RESULT_UNFIXED
-			    || tags.is_deleted) {
+			if (tags.ecc_result == YAFFS_ECC_RESULT_UNFIXED ||
+			    tags.is_deleted) {
 				/* YAFFS1 only...
 				 * A deleted chunk
 				 */
 				deleted++;
 				dev->n_free_chunks++;
-				/*T((" %d %d deleted\n",blk,c)); */
 			} else if (!tags.chunk_used) {
 				/* An unassigned chunk in the block
 				 * This means that either the block is empty or
@@ -118,11 +114,12 @@
 				 */
 
 				if (c == 0) {
-					/* We're looking at the first chunk in the block so the block is unused */
+					/* We're looking at the first chunk in
+					 *the block so the block is unused */
 					state = YAFFS_BLOCK_STATE_EMPTY;
 					dev->n_erased_blocks++;
 				} else {
-					/* this is the block being allocated from */
+					/* this is the block being allocated */
 					yaffs_trace(YAFFS_TRACE_SCAN,
 						" Allocating from %d %d",
 						blk, c);
@@ -130,7 +127,6 @@
 					dev->alloc_block = blk;
 					dev->alloc_page = c;
 					dev->alloc_block_finder = blk;
-					/* Set block finder here to encourage the allocator to go forth from here. */
 
 				}
 
@@ -146,8 +142,8 @@
 				in = yaffs_find_or_create_by_number(dev,
 								    tags.obj_id,
 								    YAFFS_OBJECT_TYPE_FILE);
-				/* PutChunkIntoFile checks for a clash (two data chunks with
-				 * the same chunk_id).
+				/* PutChunkIntoFile checks for a clash
+				 * (two data chunks with the same chunk_id).
 				 */
 
 				if (!in)
@@ -160,13 +156,13 @@
 				}
 
 				endpos =
-				    (tags.chunk_id -
-				     1) * dev->data_bytes_per_chunk +
+				    (tags.chunk_id - 1) *
+				    dev->data_bytes_per_chunk +
 				    tags.n_bytes;
-				if (in
-				    && in->variant_type ==
-				    YAFFS_OBJECT_TYPE_FILE
-				    && in->variant.file_variant.scanned_size <
+				if (in &&
+				    in->variant_type ==
+				     YAFFS_OBJECT_TYPE_FILE &&
+				    in->variant.file_variant.scanned_size <
 				    endpos) {
 					in->variant.file_variant.scanned_size =
 					    endpos;
@@ -178,10 +174,9 @@
 					}
 
 				}
-				/* T((" %d %d data %d %d\n",blk,c,tags.obj_id,tags.chunk_id));   */
 			} else {
 				/* chunk_id == 0, so it is an ObjectHeader.
-				 * Thus, we read in the object header and make the object
+				 * Make the object
 				 */
 				yaffs_set_chunk_bit(dev, blk, c);
 				bi->pages_in_use++;
@@ -195,13 +190,14 @@
 				in = yaffs_find_by_number(dev, tags.obj_id);
 				if (in && in->variant_type != oh->type) {
 					/* This should not happen, but somehow
-					 * Wev'e ended up with an obj_id that has been reused but not yet
-					 * deleted, and worse still it has changed type. Delete the old object.
+					 * Wev'e ended up with an obj_id that
+					 * has been reused but not yet deleted,
+					 * and worse still it has changed type.
+					 * Delete the old object.
 					 */
 
 					yaffs_del_obj(in);
-
-					in = 0;
+					in = NULL;
 				}
 
 				in = yaffs_find_or_create_by_number(dev,
@@ -234,7 +230,9 @@
 				}
 
 				if (in && in->valid) {
-					/* We have already filled this one. We have a duplicate and need to resolve it. */
+					/* We have already filled this one.
+					 * We have a duplicate and need to
+					 * resolve it. */
 
 					unsigned existing_serial = in->serial;
 					unsigned new_serial =
@@ -242,13 +240,15 @@
 
 					if (((existing_serial + 1) & 3) ==
 					    new_serial) {
-						/* Use new one - destroy the exisiting one */
+						/* Use new one - destroy the
+						 * exisiting one */
 						yaffs_chunk_del(dev,
 								in->hdr_chunk,
 								1, __LINE__);
 						in->valid = 0;
 					} else {
-						/* Use existing - destroy this one. */
+						/* Use existing - destroy
+						 * this one. */
 						yaffs_chunk_del(dev, chunk, 1,
 								__LINE__);
 					}
@@ -258,7 +258,8 @@
 				    (tags.obj_id == YAFFS_OBJECTID_ROOT ||
 				     tags.obj_id ==
 				     YAFFS_OBJECTID_LOSTNFOUND)) {
-					/* We only load some info, don't fiddle with directory structure */
+					/* We only load some info, don't fiddle
+					 * with directory structure */
 					in->valid = 1;
 					in->variant_type = oh->type;
 
@@ -297,12 +298,14 @@
 						parent->variant_type =
 						    YAFFS_OBJECT_TYPE_DIRECTORY;
 						INIT_LIST_HEAD(&parent->
-							       variant.dir_variant.children);
-					} else if (!parent
-						   || parent->variant_type !=
+							variant.dir_variant.
+							children);
+					} else if (!parent ||
+						parent->variant_type !=
 						   YAFFS_OBJECT_TYPE_DIRECTORY) {
-						/* Hoosterman, another problem....
-						 * We're trying to use a non-directory as a directory
+						/* Hoosterman, a problem....
+						 * We're trying to use a
+						 * non-directory as a directory
 						 */
 
 						yaffs_trace(YAFFS_TRACE_ERROR,
@@ -313,19 +316,6 @@
 
 					yaffs_add_obj_to_dir(parent, in);
 
-					if (0 && (parent == dev->del_dir ||
-						  parent ==
-						  dev->unlinked_dir)) {
-						in->deleted = 1;	/* If it is unlinked at start up then it wants deleting */
-						dev->n_deleted_files++;
-					}
-					/* Note re hardlinks.
-					 * Since we might scan a hardlink before its equivalent object is scanned
-					 * we put them all in a list.
-					 * After scanning is complete, we should have all the objects, so we run through this
-					 * list and fix up all the chains.
-					 */
-
 					switch (in->variant_type) {
 					case YAFFS_OBJECT_TYPE_UNKNOWN:
 						/* Todo got a problem */
@@ -333,20 +323,16 @@
 					case YAFFS_OBJECT_TYPE_FILE:
 						if (dev->param.
 						    use_header_file_size)
-
 							in->variant.
 							    file_variant.file_size
-							    = oh->file_size;
-
+							= yaffs_oh_to_size(oh);
 						break;
 					case YAFFS_OBJECT_TYPE_HARDLINK:
 						in->variant.
 						    hardlink_variant.equiv_id =
 						    oh->equiv_id;
-						in->hard_links.next =
-						    (struct list_head *)
-						    hard_list;
-						hard_list = in;
+						list_add(&in->hard_links,
+								&hard_list);
 						break;
 					case YAFFS_OBJECT_TYPE_DIRECTORY:
 						/* Do nothing */
@@ -363,18 +349,19 @@
 							alloc_failed = 1;
 						break;
 					}
-
 				}
 			}
 		}
 
-		if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
-			/* If we got this far while scanning, then the block is fully allocated. */
+		if (state == YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			/* If we got this far while scanning,
+			 * then the block is fully allocated. */
 			state = YAFFS_BLOCK_STATE_FULL;
 		}
 
 		if (state == YAFFS_BLOCK_STATE_ALLOCATING) {
-			/* If the block was partially allocated then treat it as fully allocated. */
+			/* If the block was partially allocated then
+			 * treat it as fully allocated. */
 			state = YAFFS_BLOCK_STATE_FULL;
 			dev->alloc_block = -1;
 		}
@@ -384,21 +371,22 @@
 		/* Now let's see if it was dirty */
 		if (bi->pages_in_use == 0 &&
 		    !bi->has_shrink_hdr &&
-		    bi->block_state == YAFFS_BLOCK_STATE_FULL) {
+		    bi->block_state == YAFFS_BLOCK_STATE_FULL)
 			yaffs_block_became_dirty(dev, blk);
 		}
 
-	}
-
 	/* Ok, we've done all the scanning.
 	 * Fix up the hard link chains.
-	 * We should now have scanned all the objects, now it's time to add these
-	 * hardlinks.
+	 * We should now have scanned all the objects, now it's time to add
+	 * these hardlinks.
 	 */
 
-	yaffs_link_fixup(dev, hard_list);
+	yaffs_link_fixup(dev, &hard_list);
 
-	/* Fix up any shadowed objects */
+	/*
+	 * Fix up any shadowed objects.
+	 * There should not be more than one of these.
+	 */
 	{
 		struct yaffs_shadow_fixer *fixer;
 		struct yaffs_obj *obj;
@@ -406,8 +394,9 @@
 		while (shadow_fixers) {
 			fixer = shadow_fixers;
 			shadow_fixers = fixer->next;
-			/* Complete the rename transaction by deleting the shadowed object
-			 * then setting the object header to unshadowed.
+			/* Complete the rename transaction by deleting the
+			 * shadowed object then setting the object header
+			 to unshadowed.
 			 */
 			obj = yaffs_find_by_number(dev, fixer->shadowed_id);
 			if (obj)
@@ -422,7 +411,7 @@
 		}
 	}
 
-	yaffs_release_temp_buffer(dev, chunk_data, __LINE__);
+	yaffs_release_temp_buffer(dev, chunk_data);
 
 	if (alloc_failed)
 		return YAFFS_FAIL;
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_yaffs1.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_yaffs1.h
--- linux-3.1.9/fs/yaffs2/yaffs_yaffs1.h	2012-06-20 14:51:23.982803635 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_yaffs1.h	2012-06-28 16:54:39.723622580 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_yaffs2.c linux-3.1.9-yaffs2/fs/yaffs2/yaffs_yaffs2.c
--- linux-3.1.9/fs/yaffs2/yaffs_yaffs2.c	2012-06-20 14:51:23.982803635 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_yaffs2.c	2012-06-28 16:54:39.723622580 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -20,6 +20,7 @@
 #include "yaffs_getblockinfo.h"
 #include "yaffs_verify.h"
 #include "yaffs_attribs.h"
+#include "yaffs_summary.h"
 
 /*
  * Checkpoints are really no benefit on very small partitions.
@@ -28,7 +29,6 @@
  * the partition is at least this big.
  */
 #define YAFFS_CHECKPOINT_MIN_BLOCKS 60
-
 #define YAFFS_SMALL_HOLE_THRESHOLD 4
 
 /*
@@ -55,7 +55,8 @@
 	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
 		if (b->block_state == YAFFS_BLOCK_STATE_FULL &&
 		    (b->pages_in_use - b->soft_del_pages) <
-		    dev->param.chunks_per_block && b->seq_number < seq) {
+		    dev->param.chunks_per_block &&
+		    b->seq_number < seq) {
 			seq = b->seq_number;
 			block_no = i;
 		}
@@ -66,7 +67,6 @@
 		dev->oldest_dirty_seq = seq;
 		dev->oldest_dirty_block = block_no;
 	}
-
 }
 
 void yaffs2_find_oldest_dirty_seq(struct yaffs_dev *dev)
@@ -127,8 +127,8 @@
 
 	yaffs2_find_oldest_dirty_seq(dev);
 
-	/* Can't do gc of this block if there are any blocks older than this one that have
-	 * discarded pages.
+	/* Can't do gc of this block if there are any blocks older than this
+	 * one that have discarded pages.
 	 */
 	return (bi->seq_number <= dev->oldest_dirty_seq);
 }
@@ -138,13 +138,11 @@
  * periodically finds the oldest full block by sequence number for refreshing.
  * Only for yaffs2.
  */
-u32 yaffs2_find_refresh_block(struct yaffs_dev * dev)
+u32 yaffs2_find_refresh_block(struct yaffs_dev *dev)
 {
 	u32 b;
-
 	u32 oldest = 0;
 	u32 oldest_seq = 0;
-
 	struct yaffs_block_info *bi;
 
 	if (!dev->param.is_yaffs2)
@@ -210,29 +208,29 @@
 int yaffs_calc_checkpt_blocks_required(struct yaffs_dev *dev)
 {
 	int retval;
+	int n_bytes = 0;
+	int n_blocks;
+	int dev_blocks;
 
 	if (!dev->param.is_yaffs2)
 		return 0;
 
 	if (!dev->checkpoint_blocks_required && yaffs2_checkpt_required(dev)) {
 		/* Not a valid value so recalculate */
-		int n_bytes = 0;
-		int n_blocks;
-		int dev_blocks =
-		    (dev->param.end_block - dev->param.start_block + 1);
-
+		dev_blocks = dev->param.end_block - dev->param.start_block + 1;
 		n_bytes += sizeof(struct yaffs_checkpt_validity);
 		n_bytes += sizeof(struct yaffs_checkpt_dev);
 		n_bytes += dev_blocks * sizeof(struct yaffs_block_info);
 		n_bytes += dev_blocks * dev->chunk_bit_stride;
 		n_bytes +=
-		    (sizeof(struct yaffs_checkpt_obj) +
-		     sizeof(u32)) * (dev->n_obj);
-		n_bytes += (dev->tnode_size + sizeof(u32)) * (dev->n_tnodes);
+		    (sizeof(struct yaffs_checkpt_obj) + sizeof(u32)) *
+		    dev->n_obj;
+		n_bytes += (dev->tnode_size + sizeof(u32)) * dev->n_tnodes;
 		n_bytes += sizeof(struct yaffs_checkpt_validity);
 		n_bytes += sizeof(u32);	/* checksum */
 
-		/* Round up and add 2 blocks to allow for some bad blocks, so add 3 */
+		/* Round up and add 2 blocks to allow for some bad blocks,
+		 * so add 3 */
 
 		n_blocks =
 		    (n_bytes /
@@ -312,9 +310,7 @@
 {
 	struct yaffs_checkpt_dev cp;
 	u32 n_bytes;
-	u32 n_blocks =
-	    (dev->internal_end_block - dev->internal_start_block + 1);
-
+	u32 n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
 	int ok;
 
 	/* Write device runtime values */
@@ -322,22 +318,20 @@
 	cp.struct_type = sizeof(cp);
 
 	ok = (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp));
+	if (!ok)
+		return 0;
 
 	/* Write block info */
-	if (ok) {
 		n_bytes = n_blocks * sizeof(struct yaffs_block_info);
-		ok = (yaffs2_checkpt_wr(dev, dev->block_info, n_bytes) ==
-		      n_bytes);
-	}
+	ok = (yaffs2_checkpt_wr(dev, dev->block_info, n_bytes) == n_bytes);
+	if (!ok)
+		return 0;
 
 	/* Write chunk bits */
-	if (ok) {
 		n_bytes = n_blocks * dev->chunk_bit_stride;
-		ok = (yaffs2_checkpt_wr(dev, dev->chunk_bits, n_bytes) ==
-		      n_bytes);
-	}
-	return ok ? 1 : 0;
+	ok = (yaffs2_checkpt_wr(dev, dev->chunk_bits, n_bytes) == n_bytes);
 
+	return ok ? 1 : 0;
 }
 
 static int yaffs2_rd_checkpt_dev(struct yaffs_dev *dev)
@@ -346,7 +340,6 @@
 	u32 n_bytes;
 	u32 n_blocks =
 	    (dev->internal_end_block - dev->internal_start_block + 1);
-
 	int ok;
 
 	ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
@@ -364,6 +357,7 @@
 
 	if (!ok)
 		return 0;
+
 	n_bytes = n_blocks * dev->chunk_bit_stride;
 
 	ok = (yaffs2_checkpt_rd(dev, dev->chunk_bits, n_bytes) == n_bytes);
@@ -374,7 +368,6 @@
 static void yaffs2_obj_checkpt_obj(struct yaffs_checkpt_obj *cp,
 				   struct yaffs_obj *obj)
 {
-
 	cp->obj_id = obj->obj_id;
 	cp->parent_id = (obj->parent) ? obj->parent->obj_id : 0;
 	cp->hdr_chunk = obj->hdr_chunk;
@@ -394,10 +387,9 @@
 		cp->size_or_equiv_obj = obj->variant.hardlink_variant.equiv_id;
 }
 
-static int taffs2_checkpt_obj_to_obj(struct yaffs_obj *obj,
+static int yaffs2_checkpt_obj_to_obj(struct yaffs_obj *obj,
 				     struct yaffs_checkpt_obj *cp)
 {
-
 	struct yaffs_obj *parent;
 
 	if (obj->variant_type != cp->variant_type) {
@@ -457,39 +449,33 @@
 	int i;
 	struct yaffs_dev *dev = in->my_dev;
 	int ok = 1;
+	u32 base_offset;
 
-	if (tn) {
-		if (level > 0) {
+	if (!tn)
+		return 1;
 
+	if (level > 0) {
 			for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++) {
-				if (tn->internal[i]) {
+			if (!tn->internal[i])
+				continue;
 					ok = yaffs2_checkpt_tnode_worker(in,
-									 tn->
-									 internal
-									 [i],
-									 level -
-									 1,
-									 (chunk_offset
-									  <<
-									  YAFFS_TNODES_INTERNAL_BITS)
-									 + i);
-				}
-			}
-		} else if (level == 0) {
-			u32 base_offset =
-			    chunk_offset << YAFFS_TNODES_LEVEL0_BITS;
-			ok = (yaffs2_checkpt_wr
-			      (dev, &base_offset,
-			       sizeof(base_offset)) == sizeof(base_offset));
-			if (ok)
-				ok = (yaffs2_checkpt_wr
-				      (dev, tn,
-				       dev->tnode_size) == dev->tnode_size);
+				 tn->internal[i],
+				 level - 1,
+				 (chunk_offset <<
+				  YAFFS_TNODES_INTERNAL_BITS) + i);
 		}
+		return ok;
 	}
 
-	return ok;
+	/* Level 0 tnode */
+	base_offset = chunk_offset << YAFFS_TNODES_LEVEL0_BITS;
+	ok = (yaffs2_checkpt_wr(dev, &base_offset, sizeof(base_offset)) ==
+			sizeof(base_offset));
+	if (ok)
+		ok = (yaffs2_checkpt_wr(dev, tn, dev->tnode_size) ==
+			dev->tnode_size);
 
+	return ok;
 }
 
 static int yaffs2_wr_checkpt_tnodes(struct yaffs_obj *obj)
@@ -497,16 +483,16 @@
 	u32 end_marker = ~0;
 	int ok = 1;
 
-	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE) {
+	if (obj->variant_type != YAFFS_OBJECT_TYPE_FILE)
+		return ok;
+
 		ok = yaffs2_checkpt_tnode_worker(obj,
 						 obj->variant.file_variant.top,
 						 obj->variant.file_variant.
 						 top_level, 0);
 		if (ok)
-			ok = (yaffs2_checkpt_wr
-			      (obj->my_dev, &end_marker,
+		ok = (yaffs2_checkpt_wr(obj->my_dev, &end_marker,
 			       sizeof(end_marker)) == sizeof(end_marker));
-	}
 
 	return ok ? 1 : 0;
 }
@@ -528,12 +514,11 @@
 		/* Read level 0 tnode */
 
 		tn = yaffs_get_tnode(dev);
-		if (tn) {
+		if (tn)
 			ok = (yaffs2_checkpt_rd(dev, tn, dev->tnode_size) ==
 			      dev->tnode_size);
-		} else {
+		else
 			ok = 0;
-                }
 
 		if (tn && ok)
 			ok = yaffs_add_find_tnode_0(dev,
@@ -544,7 +529,6 @@
 			ok = (yaffs2_checkpt_rd
 			      (dev, &base_chunk,
 			       sizeof(base_chunk)) == sizeof(base_chunk));
-
 	}
 
 	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
@@ -568,9 +552,7 @@
 
 	for (i = 0; ok && i < YAFFS_NOBJECT_BUCKETS; i++) {
 		list_for_each(lh, &dev->obj_bucket[i].list) {
-			if (lh) {
-				obj =
-				    list_entry(lh, struct yaffs_obj, hash_link);
+			obj = list_entry(lh, struct yaffs_obj, hash_link);
 				if (!obj->defered_free) {
 					yaffs2_obj_checkpt_obj(&cp, obj);
 					cp.struct_type = sizeof(cp);
@@ -580,22 +562,19 @@
 						cp.obj_id, cp.parent_id,
 						cp.variant_type, cp.hdr_chunk, obj);
 
-					ok = (yaffs2_checkpt_wr
-					      (dev, &cp,
+				ok = (yaffs2_checkpt_wr(dev, &cp,
 					       sizeof(cp)) == sizeof(cp));
 
-					if (ok
-					    && obj->variant_type ==
+				if (ok &&
+					obj->variant_type ==
 					    YAFFS_OBJECT_TYPE_FILE)
-						ok = yaffs2_wr_checkpt_tnodes
-						    (obj);
-				}
+					ok = yaffs2_wr_checkpt_tnodes(obj);
 			}
 		}
 	}
 
 	/* Dump end of list */
-	memset(&cp, 0xFF, sizeof(struct yaffs_checkpt_obj));
+	memset(&cp, 0xff, sizeof(struct yaffs_checkpt_obj));
 	cp.struct_type = sizeof(cp);
 
 	if (ok)
@@ -610,7 +589,8 @@
 	struct yaffs_checkpt_obj cp;
 	int ok = 1;
 	int done = 0;
-	struct yaffs_obj *hard_list = NULL;
+	LIST_HEAD(hard_list);
+
 
 	while (ok && !done) {
 		ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
@@ -633,16 +613,15 @@
 			    yaffs_find_or_create_by_number(dev, cp.obj_id,
 							   cp.variant_type);
 			if (obj) {
-				ok = taffs2_checkpt_obj_to_obj(obj, &cp);
+				ok = yaffs2_checkpt_obj_to_obj(obj, &cp);
 				if (!ok)
 					break;
-				if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE) {
+				if (obj->variant_type ==
+					YAFFS_OBJECT_TYPE_FILE) {
 					ok = yaffs2_rd_checkpt_tnodes(obj);
 				} else if (obj->variant_type ==
 					   YAFFS_OBJECT_TYPE_HARDLINK) {
-					obj->hard_links.next =
-					    (struct list_head *)hard_list;
-					hard_list = obj;
+					list_add(&obj->hard_links, &hard_list);
 				}
 			} else {
 				ok = 0;
@@ -651,7 +630,7 @@
 	}
 
 	if (ok)
-		yaffs_link_fixup(dev, hard_list);
+		yaffs_link_fixup(dev, &hard_list);
 
 	return ok ? 1 : 0;
 }
@@ -792,7 +771,6 @@
 		dev->is_checkpointed = 0;
 
 	return ok ? 1 : 0;
-
 }
 
 void yaffs2_checkpt_invalidate(struct yaffs_dev *dev)
@@ -807,7 +785,6 @@
 
 int yaffs_checkpoint_save(struct yaffs_dev *dev)
 {
-
 	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
 		"save entry: is_checkpointed %d",
 		dev->is_checkpointed);
@@ -831,6 +808,7 @@
 int yaffs2_checkpt_restore(struct yaffs_dev *dev)
 {
 	int retval;
+
 	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
 		"restore entry: is_checkpointed %d",
 		dev->is_checkpointed);
@@ -854,17 +832,15 @@
 {
 	/* if new_size > old_file_size.
 	 * We're going to be writing a hole.
-	 * If the hole is small then write zeros otherwise write a start of hole marker.
+	 * If the hole is small then write zeros otherwise write a start
+	 * of hole marker.
 	 */
-
 	loff_t old_file_size;
-	int increase;
+	loff_t increase;
 	int small_hole;
 	int result = YAFFS_OK;
 	struct yaffs_dev *dev = NULL;
-
 	u8 *local_buffer = NULL;
-
 	int small_increase_ok = 0;
 
 	if (!obj)
@@ -893,11 +869,11 @@
 		small_hole = 0;
 
 	if (small_hole)
-		local_buffer = yaffs_get_temp_buffer(dev, __LINE__);
+		local_buffer = yaffs_get_temp_buffer(dev);
 
 	if (local_buffer) {
 		/* fill hole with zero bytes */
-		int pos = old_file_size;
+		loff_t pos = old_file_size;
 		int this_write;
 		int written;
 		memset(local_buffer, 0, dev->data_bytes_per_chunk);
@@ -918,9 +894,9 @@
                         }
 		}
 
-		yaffs_release_temp_buffer(dev, local_buffer, __LINE__);
+		yaffs_release_temp_buffer(dev, local_buffer);
 
-		/* If we were out of space then reverse any chunks we've added */
+		/* If out of space then reverse any chunks we've added */
 		if (!small_increase_ok)
 			yaffs_resize_file_down(obj, old_file_size);
 	}
@@ -934,7 +910,6 @@
 	}
 
 	return result;
-
 }
 
 struct yaffs_block_index {
@@ -948,220 +923,91 @@
 	int bseq = ((struct yaffs_block_index *)b)->seq;
 	int ablock = ((struct yaffs_block_index *)a)->block;
 	int bblock = ((struct yaffs_block_index *)b)->block;
+
 	if (aseq == bseq)
 		return ablock - bblock;
-	else
+
 		return aseq - bseq;
 }
 
-int yaffs2_scan_backwards(struct yaffs_dev *dev)
+static inline int yaffs2_scan_chunk(struct yaffs_dev *dev,
+		struct yaffs_block_info *bi,
+		int blk, int chunk_in_block,
+		int *found_chunks,
+		u8 *chunk_data,
+		struct list_head *hard_list,
+		int summary_available)
 {
-	struct yaffs_ext_tags tags;
-	int blk;
-	int block_iter;
-	int start_iter;
-	int end_iter;
-	int n_to_scan = 0;
-
-	int chunk;
-	int result;
-	int c;
-	int deleted;
-	enum yaffs_block_state state;
-	struct yaffs_obj *hard_list = NULL;
-	struct yaffs_block_info *bi;
-	u32 seq_number;
 	struct yaffs_obj_hdr *oh;
 	struct yaffs_obj *in;
 	struct yaffs_obj *parent;
-	int n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
-	int is_unlinked;
-	u8 *chunk_data;
-
-	int file_size;
-	int is_shrink;
-	int found_chunks;
 	int equiv_id;
+	loff_t file_size;
+	int is_shrink;
+	int is_unlinked;
+	struct yaffs_ext_tags tags;
+	int result;
 	int alloc_failed = 0;
-
-	struct yaffs_block_index *block_index = NULL;
-	int alt_block_index = 0;
-
-	yaffs_trace(YAFFS_TRACE_SCAN,
-		"yaffs2_scan_backwards starts  intstartblk %d intendblk %d...",
-		dev->internal_start_block, dev->internal_end_block);
-
-	dev->seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;
-
-	block_index = kmalloc(n_blocks * sizeof(struct yaffs_block_index),
-			GFP_NOFS);
-
-	if (!block_index) {
-		block_index =
-		    vmalloc(n_blocks * sizeof(struct yaffs_block_index));
-		alt_block_index = 1;
+	int chunk = blk * dev->param.chunks_per_block + chunk_in_block;
+	struct yaffs_file_var *file_var;
+	struct yaffs_hardlink_var *hl_var;
+	struct yaffs_symlink_var *sl_var;
+
+	if (summary_available) {
+		result = yaffs_summary_fetch(dev, &tags, chunk_in_block);
+		tags.seq_number = bi->seq_number;
 	}
 
-	if (!block_index) {
-		yaffs_trace(YAFFS_TRACE_SCAN,
-			"yaffs2_scan_backwards() could not allocate block index!"
-			);
-		return YAFFS_FAIL;
-	}
-
-	dev->blocks_in_checkpt = 0;
-
-	chunk_data = yaffs_get_temp_buffer(dev, __LINE__);
-
-	/* Scan all the blocks to determine their state */
-	bi = dev->block_info;
-	for (blk = dev->internal_start_block; blk <= dev->internal_end_block;
-	     blk++) {
-		yaffs_clear_chunk_bits(dev, blk);
-		bi->pages_in_use = 0;
-		bi->soft_del_pages = 0;
-
-		yaffs_query_init_block_state(dev, blk, &state, &seq_number);
-
-		bi->block_state = state;
-		bi->seq_number = seq_number;
-
-		if (bi->seq_number == YAFFS_SEQUENCE_CHECKPOINT_DATA)
-			bi->block_state = state = YAFFS_BLOCK_STATE_CHECKPOINT;
-		if (bi->seq_number == YAFFS_SEQUENCE_BAD_BLOCK)
-			bi->block_state = state = YAFFS_BLOCK_STATE_DEAD;
-
-		yaffs_trace(YAFFS_TRACE_SCAN_DEBUG,
-			"Block scanning block %d state %d seq %d",
-			blk, state, seq_number);
-
-		if (state == YAFFS_BLOCK_STATE_CHECKPOINT) {
-			dev->blocks_in_checkpt++;
-
-		} else if (state == YAFFS_BLOCK_STATE_DEAD) {
-			yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
-				"block %d is bad", blk);
-		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
-			yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "Block empty ");
-			dev->n_erased_blocks++;
-			dev->n_free_chunks += dev->param.chunks_per_block;
-		} else if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
-
-			/* Determine the highest sequence number */
-			if (seq_number >= YAFFS_LOWEST_SEQUENCE_NUMBER &&
-			    seq_number < YAFFS_HIGHEST_SEQUENCE_NUMBER) {
-
-				block_index[n_to_scan].seq = seq_number;
-				block_index[n_to_scan].block = blk;
-
-				n_to_scan++;
-
-				if (seq_number >= dev->seq_number)
-					dev->seq_number = seq_number;
+	if (!summary_available || tags.obj_id == 0) {
+		result = yaffs_rd_chunk_tags_nand(dev, chunk, NULL, &tags);
+		dev->tags_used++;
 			} else {
-				/* TODO: Nasty sequence number! */
-				yaffs_trace(YAFFS_TRACE_SCAN,
-					"Block scanning block %d has bad sequence number %d",
-					blk, seq_number);
-
-			}
+		dev->summary_used++;
 		}
-		bi++;
-	}
-
-	yaffs_trace(YAFFS_TRACE_SCAN, "%d blocks to be sorted...", n_to_scan);
-
-	cond_resched();
-
-	/* Sort the blocks by sequence number */
-	sort(block_index, n_to_scan, sizeof(struct yaffs_block_index),
-		   yaffs2_ybicmp, NULL);
-
-	cond_resched();
-
-	yaffs_trace(YAFFS_TRACE_SCAN, "...done");
-
-	/* Now scan the blocks looking at the data. */
-	start_iter = 0;
-	end_iter = n_to_scan - 1;
-	yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "%d blocks to scan", n_to_scan);
-
-	/* For each block.... backwards */
-	for (block_iter = end_iter; !alloc_failed && block_iter >= start_iter;
-	     block_iter--) {
-		/* Cooperative multitasking! This loop can run for so
-		   long that watchdog timers expire. */
-		cond_resched();
-
-		/* get the block to scan in the correct order */
-		blk = block_index[block_iter].block;
-
-		bi = yaffs_get_block_info(dev, blk);
-
-		state = bi->block_state;
-
-		deleted = 0;
-
-		/* For each chunk in each block that needs scanning.... */
-		found_chunks = 0;
-		for (c = dev->param.chunks_per_block - 1;
-		     !alloc_failed && c >= 0 &&
-		     (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||
-		      state == YAFFS_BLOCK_STATE_ALLOCATING); c--) {
-			/* Scan backwards...
-			 * Read the tags and decide what to do
-			 */
-
-			chunk = blk * dev->param.chunks_per_block + c;
-
-			result = yaffs_rd_chunk_tags_nand(dev, chunk, NULL,
-							  &tags);
 
 			/* Let's have a good look at this chunk... */
 
 			if (!tags.chunk_used) {
 				/* An unassigned chunk in the block.
 				 * If there are used chunks after this one, then
-				 * it is a chunk that was skipped due to failing the erased
-				 * check. Just skip it so that it can be deleted.
-				 * But, more typically, We get here when this is an unallocated
-				 * chunk and his means that either the block is empty or
-				 * this is the one being allocated from
-				 */
-
-				if (found_chunks) {
-					/* This is a chunk that was skipped due to failing the erased check */
-				} else if (c == 0) {
-					/* We're looking at the first chunk in the block so the block is unused */
-					state = YAFFS_BLOCK_STATE_EMPTY;
+		 * it is a chunk that was skipped due to failing
+		 * the erased check. Just skip it so that it can
+		 * be deleted.
+		 * But, more typically, We get here when this is
+		 * an unallocated chunk and his means that
+		 * either the block is empty or this is the one
+		 * being allocated from
+		 */
+
+		if (*found_chunks) {
+			/* This is a chunk that was skipped due
+			 * to failing the erased check */
+		} else if (chunk_in_block == 0) {
+			/* We're looking at the first chunk in
+			 * the block so the block is unused */
+			bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
 					dev->n_erased_blocks++;
 				} else {
-					if (state ==
-					    YAFFS_BLOCK_STATE_NEEDS_SCANNING
-					    || state ==
-					    YAFFS_BLOCK_STATE_ALLOCATING) {
-						if (dev->seq_number ==
-						    bi->seq_number) {
-							/* this is the block being allocated from */
-
+			if (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
+			    bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING) {
+				if (dev->seq_number == bi->seq_number) {
+					/* Allocating from this block*/
 							yaffs_trace(YAFFS_TRACE_SCAN,
 								" Allocating from %d %d",
-								blk, c);
+					    blk, chunk_in_block);
 
-							state =
+					bi->block_state =
 							    YAFFS_BLOCK_STATE_ALLOCATING;
 							dev->alloc_block = blk;
-							dev->alloc_page = c;
-							dev->
-							    alloc_block_finder =
-							    blk;
+					dev->alloc_page = chunk_in_block;
+					dev->alloc_block_finder = blk;
 						} else {
-							/* This is a partially written block that is not
-							 * the current allocation block.
+					/* This is a partially written block
+					 * that is not the current
+					 * allocation block.
 							 */
-
 							yaffs_trace(YAFFS_TRACE_SCAN,
-								"Partially written block %d detected",
+						"Partially written block %d detected. gc will fix this.",
 								blk);
 						}
 					}
@@ -1169,83 +1015,79 @@
 
 				dev->n_free_chunks++;
 
-			} else if (tags.ecc_result == YAFFS_ECC_RESULT_UNFIXED) {
+	} else if (tags.ecc_result ==
+		YAFFS_ECC_RESULT_UNFIXED) {
 				yaffs_trace(YAFFS_TRACE_SCAN,
 					" Unfixed ECC in chunk(%d:%d), chunk ignored",
-					blk, c);
-
+			blk, chunk_in_block);
 				dev->n_free_chunks++;
-
 			} else if (tags.obj_id > YAFFS_MAX_OBJECT_ID ||
 				   tags.chunk_id > YAFFS_MAX_CHUNK_ID ||
-				   (tags.chunk_id > 0
-				    && tags.n_bytes > dev->data_bytes_per_chunk)
-				   || tags.seq_number != bi->seq_number) {
+		   tags.obj_id == YAFFS_OBJECTID_SUMMARY ||
+		   (tags.chunk_id > 0 &&
+		     tags.n_bytes > dev->data_bytes_per_chunk) ||
+		   tags.seq_number != bi->seq_number) {
 				yaffs_trace(YAFFS_TRACE_SCAN,
 					"Chunk (%d:%d) with bad tags:obj = %d, chunk_id = %d, n_bytes = %d, ignored",
-					blk, c, tags.obj_id,
+			blk, chunk_in_block, tags.obj_id,
 					tags.chunk_id, tags.n_bytes);
-
 				dev->n_free_chunks++;
-
 			} else if (tags.chunk_id > 0) {
 				/* chunk_id > 0 so it is a data chunk... */
-				unsigned int endpos;
-				u32 chunk_base =
-				    (tags.chunk_id -
-				     1) * dev->data_bytes_per_chunk;
+		loff_t endpos;
+		loff_t chunk_base = (tags.chunk_id - 1) *
+					dev->data_bytes_per_chunk;
 
-				found_chunks = 1;
+		*found_chunks = 1;
 
-				yaffs_set_chunk_bit(dev, blk, c);
+		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
 				bi->pages_in_use++;
 
 				in = yaffs_find_or_create_by_number(dev,
 								    tags.obj_id,
 								    YAFFS_OBJECT_TYPE_FILE);
-				if (!in) {
+		if (!in)
 					/* Out of memory */
 					alloc_failed = 1;
-				}
 
 				if (in &&
-				    in->variant_type == YAFFS_OBJECT_TYPE_FILE
-				    && chunk_base <
-				    in->variant.file_variant.shrink_size) {
-					/* This has not been invalidated by a resize */
-					if (!yaffs_put_chunk_in_file
-					    (in, tags.chunk_id, chunk, -1)) {
+		    in->variant_type == YAFFS_OBJECT_TYPE_FILE &&
+		    chunk_base < in->variant.file_variant.shrink_size) {
+			/* This has not been invalidated by
+			 * a resize */
+			if (!yaffs_put_chunk_in_file(in, tags.chunk_id,
+								chunk, -1))
 						alloc_failed = 1;
-					}
 
-					/* File size is calculated by looking at the data chunks if we have not
-					 * seen an object header yet. Stop this practice once we find an object header.
+			/* File size is calculated by looking at
+			 * the data chunks if we have not
+			 * seen an object header yet.
+			 * Stop this practice once we find an
+			 * object header.
 					 */
 					endpos = chunk_base + tags.n_bytes;
 
-					if (!in->valid &&	/* have not got an object header yet */
-					    in->variant.file_variant.
-					    scanned_size < endpos) {
+			if (!in->valid &&
+			    in->variant.file_variant.scanned_size < endpos) {
 						in->variant.file_variant.
 						    scanned_size = endpos;
 						in->variant.file_variant.
 						    file_size = endpos;
 					}
-
 				} else if (in) {
-					/* This chunk has been invalidated by a resize, or a past file deletion
+			/* This chunk has been invalidated by a
+			 * resize, or a past file deletion
 					 * so delete the chunk*/
-					yaffs_chunk_del(dev, chunk, 1,
-							__LINE__);
-
+			yaffs_chunk_del(dev, chunk, 1, __LINE__);
 				}
 			} else {
 				/* chunk_id == 0, so it is an ObjectHeader.
-				 * Thus, we read in the object header and make the object
+		 * Thus, we read in the object header and make
+		 * the object
 				 */
-				found_chunks = 1;
+		*found_chunks = 1;
 
-				yaffs_set_chunk_bit(dev, blk, c);
+		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
 				bi->pages_in_use++;
 
 				oh = NULL;
@@ -1253,27 +1095,23 @@
 
 				if (tags.extra_available) {
 					in = yaffs_find_or_create_by_number(dev,
-									    tags.
-									    obj_id,
-									    tags.
-									    extra_obj_type);
+					tags.obj_id,
+					tags.extra_obj_type);
 					if (!in)
 						alloc_failed = 1;
 				}
 
 				if (!in ||
-				    (!in->valid && dev->param.disable_lazy_load)
-				    || tags.extra_shadows || (!in->valid
-							      && (tags.obj_id ==
-								  YAFFS_OBJECTID_ROOT
-								  || tags.
-								  obj_id ==
-								  YAFFS_OBJECTID_LOSTNFOUND)))
-				{
-
-					/* If we don't have  valid info then we need to read the chunk
-					 * TODO In future we can probably defer reading the chunk and
-					 * living with invalid data until needed.
+		    (!in->valid && dev->param.disable_lazy_load) ||
+		    tags.extra_shadows ||
+		    (!in->valid && (tags.obj_id == YAFFS_OBJECTID_ROOT ||
+				 tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND))) {
+
+			/* If we don't have  valid info then we
+			 * need to read the chunk
+			 * TODO In future we can probably defer
+			 * reading the chunk and living with
+			 * invalid data until needed.
 					 */
 
 					result = yaffs_rd_chunk_tags_nand(dev,
@@ -1284,7 +1122,8 @@
 					oh = (struct yaffs_obj_hdr *)chunk_data;
 
 					if (dev->param.inband_tags) {
-						/* Fix up the header if they got corrupted by inband tags */
+				/* Fix up the header if they got
+				 * corrupted by inband tags */
 						oh->shadows_obj =
 						    oh->inband_shadowed_obj_id;
 						oh->is_shrink =
@@ -1292,11 +1131,11 @@
 					}
 
 					if (!in) {
-						in = yaffs_find_or_create_by_number(dev, tags.obj_id, oh->type);
+				in = yaffs_find_or_create_by_number(dev,
+							tags.obj_id, oh->type);
 						if (!in)
 							alloc_failed = 1;
 					}
-
 				}
 
 				if (!in) {
@@ -1304,91 +1143,71 @@
 					yaffs_trace(YAFFS_TRACE_ERROR,
 						"yaffs tragedy: Could not make object for object  %d at chunk %d during scan",
 						tags.obj_id, chunk);
-					continue;
+			return YAFFS_FAIL;
 				}
 
 				if (in->valid) {
 					/* We have already filled this one.
-					 * We have a duplicate that will be discarded, but
-					 * we first have to suck out resize info if it is a file.
-					 */
-
-					if ((in->variant_type ==
-					     YAFFS_OBJECT_TYPE_FILE) && ((oh
-									  &&
-									  oh->
-									  type
-									  ==
-									  YAFFS_OBJECT_TYPE_FILE)
-									 ||
-									 (tags.
-									  extra_available
-									  &&
-									  tags.
-									  extra_obj_type
-									  ==
-									  YAFFS_OBJECT_TYPE_FILE)))
-					{
-						u32 this_size =
-						    (oh) ? oh->
-						    file_size :
-						    tags.extra_length;
-						u32 parent_obj_id =
-						    (oh) ? oh->parent_obj_id :
+			 * We have a duplicate that will be
+			 * discarded, but we first have to suck
+			 * out resize info if it is a file.
+			 */
+			if ((in->variant_type == YAFFS_OBJECT_TYPE_FILE) &&
+				((oh && oh->type == YAFFS_OBJECT_TYPE_FILE) ||
+				 (tags.extra_available &&
+				  tags.extra_obj_type == YAFFS_OBJECT_TYPE_FILE)
+				)) {
+				loff_t this_size = (oh) ?
+					yaffs_oh_to_size(oh) :
+					tags.extra_file_size;
+				u32 parent_obj_id = (oh) ?
+					oh->parent_obj_id :
 						    tags.extra_parent_id;
 
-						is_shrink =
-						    (oh) ? oh->
-						    is_shrink :
+				is_shrink = (oh) ?
+					oh->is_shrink :
 						    tags.extra_is_shrink;
 
-						/* If it is deleted (unlinked at start also means deleted)
-						 * we treat the file size as being zeroed at this point.
+				/* If it is deleted (unlinked
+				 * at start also means deleted)
+				 * we treat the file size as
+				 * being zeroed at this point.
 						 */
-						if (parent_obj_id ==
-						    YAFFS_OBJECTID_DELETED
-						    || parent_obj_id ==
-						    YAFFS_OBJECTID_UNLINKED) {
+				if (parent_obj_id == YAFFS_OBJECTID_DELETED ||
+				    parent_obj_id == YAFFS_OBJECTID_UNLINKED) {
 							this_size = 0;
 							is_shrink = 1;
 						}
 
-						if (is_shrink
-						    && in->variant.file_variant.
-						    shrink_size > this_size)
-							in->variant.
-							    file_variant.
-							    shrink_size =
+				if (is_shrink &&
+				    in->variant.file_variant.shrink_size >
+				    this_size)
+					in->variant.file_variant.shrink_size =
 							    this_size;
 
 						if (is_shrink)
 							bi->has_shrink_hdr = 1;
-
 					}
 					/* Use existing - destroy this one. */
-					yaffs_chunk_del(dev, chunk, 1,
-							__LINE__);
-
+			yaffs_chunk_del(dev, chunk, 1, __LINE__);
 				}
 
 				if (!in->valid && in->variant_type !=
 				    (oh ? oh->type : tags.extra_obj_type))
 					yaffs_trace(YAFFS_TRACE_ERROR,
 						"yaffs tragedy: Bad object type, %d != %d, for object %d at chunk %d during scan",
-						oh ?
-						oh->type : tags.extra_obj_type,
+				oh ? oh->type : tags.extra_obj_type,
 						in->variant_type, tags.obj_id,
 						chunk);
 
 				if (!in->valid &&
 				    (tags.obj_id == YAFFS_OBJECTID_ROOT ||
-				     tags.obj_id ==
-				     YAFFS_OBJECTID_LOSTNFOUND)) {
-					/* We only load some info, don't fiddle with directory structure */
+		     tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND)) {
+			/* We only load some info, don't fiddle
+			 * with directory structure */
 					in->valid = 1;
 
 					if (oh) {
-
 						in->yst_mode = oh->yst_mode;
 						yaffs_load_attribs(in, oh);
 						in->lazy_loaded = 0;
@@ -1399,46 +1218,33 @@
 
 				} else if (!in->valid) {
 					/* we need to load this info */
-
 					in->valid = 1;
 					in->hdr_chunk = chunk;
-
 					if (oh) {
 						in->variant_type = oh->type;
-
 						in->yst_mode = oh->yst_mode;
 						yaffs_load_attribs(in, oh);
 
 						if (oh->shadows_obj > 0)
-							yaffs_handle_shadowed_obj
-							    (dev,
-							     oh->shadows_obj,
-							     1);
-
-						yaffs_set_obj_name_from_oh(in,
-									   oh);
-						parent =
-						    yaffs_find_or_create_by_number
-						    (dev, oh->parent_obj_id,
-						     YAFFS_OBJECT_TYPE_DIRECTORY);
+					yaffs_handle_shadowed_obj(dev,
+					     oh->shadows_obj, 1);
 
-						file_size = oh->file_size;
+				yaffs_set_obj_name_from_oh(in, oh);
+				parent = yaffs_find_or_create_by_number(dev,
+						oh->parent_obj_id,
+						YAFFS_OBJECT_TYPE_DIRECTORY);
+				file_size = yaffs_oh_to_size(oh);
 						is_shrink = oh->is_shrink;
 						equiv_id = oh->equiv_id;
-
 					} else {
-						in->variant_type =
-						    tags.extra_obj_type;
-						parent =
-						    yaffs_find_or_create_by_number
-						    (dev, tags.extra_parent_id,
+				in->variant_type = tags.extra_obj_type;
+				parent = yaffs_find_or_create_by_number(dev,
+						tags.extra_parent_id,
 						     YAFFS_OBJECT_TYPE_DIRECTORY);
-						file_size = tags.extra_length;
-						is_shrink =
-						    tags.extra_is_shrink;
+				file_size = tags.extra_file_size;
+				is_shrink = tags.extra_is_shrink;
 						equiv_id = tags.extra_equiv_id;
 						in->lazy_loaded = 1;
-
 					}
 					in->dirty = 0;
 
@@ -1449,18 +1255,18 @@
 					 * hook up to parent
 					 */
 
-					if (parent && parent->variant_type ==
-					    YAFFS_OBJECT_TYPE_UNKNOWN) {
+			if (parent &&
+			    parent->variant_type == YAFFS_OBJECT_TYPE_UNKNOWN) {
 						/* Set up as a directory */
 						parent->variant_type =
 						    YAFFS_OBJECT_TYPE_DIRECTORY;
 						INIT_LIST_HEAD(&parent->
 							       variant.dir_variant.children);
-					} else if (!parent
-						   || parent->variant_type !=
+			} else if (!parent ||
+				   parent->variant_type !=
 						   YAFFS_OBJECT_TYPE_DIRECTORY) {
 						/* Hoosterman, another problem....
-						 * We're trying to use a non-directory as a directory
+				 * Trying to use a non-directory as a directory
 						 */
 
 						yaffs_trace(YAFFS_TRACE_ERROR,
@@ -1468,22 +1274,21 @@
 							);
 						parent = dev->lost_n_found;
 					}
-
 					yaffs_add_obj_to_dir(parent, in);
 
-					is_unlinked = (parent == dev->del_dir)
-					    || (parent == dev->unlinked_dir);
+			is_unlinked = (parent == dev->del_dir) ||
+					(parent == dev->unlinked_dir);
 
-					if (is_shrink) {
-						/* Mark the block as having a shrink header */
+			if (is_shrink)
+				/* Mark the block */
 						bi->has_shrink_hdr = 1;
-					}
 
 					/* Note re hardlinks.
-					 * Since we might scan a hardlink before its equivalent object is scanned
-					 * we put them all in a list.
-					 * After scanning is complete, we should have all the objects, so we run
-					 * through this list and fix up all the chains.
+			 * Since we might scan a hardlink before its equivalent
+			 * object is scanned we put them all in a list.
+			 * After scanning is complete, we should have all the
+			 * objects, so we run through this list and fix up all
+			 * the chains.
 					 */
 
 					switch (in->variant_type) {
@@ -1491,42 +1296,27 @@
 						/* Todo got a problem */
 						break;
 					case YAFFS_OBJECT_TYPE_FILE:
+				file_var = &in->variant.file_variant;
+				if (file_var->scanned_size < file_size) {
+					/* This covers the case where the file
+					 * size is greater than the data held.
+					 * This will happen if the file is
+					 * resized to be larger than its
+					 * current data extents.
+					 */
+					file_var->file_size = file_size;
+					file_var->scanned_size = file_size;
+				}
 
-						if (in->variant.
-						    file_variant.scanned_size <
-						    file_size) {
-							/* This covers the case where the file size is greater
-							 * than where the data is
-							 * This will happen if the file is resized to be larger
-							 * than its current data extents.
-							 */
-							in->variant.
-							    file_variant.
-							    file_size =
-							    file_size;
-							in->variant.
-							    file_variant.
-							    scanned_size =
-							    file_size;
-						}
-
-						if (in->variant.file_variant.
-						    shrink_size > file_size)
-							in->variant.
-							    file_variant.
-							    shrink_size =
-							    file_size;
+				if (file_var->shrink_size > file_size)
+					file_var->shrink_size = file_size;
 
 						break;
 					case YAFFS_OBJECT_TYPE_HARDLINK:
+				hl_var = &in->variant.hardlink_variant;
 						if (!is_unlinked) {
-							in->variant.
-							    hardlink_variant.
-							    equiv_id = equiv_id;
-							in->hard_links.next =
-							    (struct list_head *)
-							    hard_list;
-							hard_list = in;
+					hl_var->equiv_id = equiv_id;
+					list_add(&in->hard_links, hard_list);
 						}
 						break;
 					case YAFFS_OBJECT_TYPE_DIRECTORY:
@@ -1536,33 +1326,178 @@
 						/* Do nothing */
 						break;
 					case YAFFS_OBJECT_TYPE_SYMLINK:
+				sl_var = &in->variant.symlink_variant;
 						if (oh) {
-							in->variant.
-							    symlink_variant.
-							    alias =
-							    yaffs_clone_str(oh->
-									    alias);
-							if (!in->variant.
-							    symlink_variant.
-							    alias)
-								alloc_failed =
-								    1;
+					sl_var->alias =
+					    yaffs_clone_str(oh->alias);
+					if (!sl_var->alias)
+						alloc_failed = 1;
 						}
 						break;
 					}
+		}
+	}
+	return alloc_failed ? YAFFS_FAIL : YAFFS_OK;
+}
 
+int yaffs2_scan_backwards(struct yaffs_dev *dev)
+{
+	int blk;
+	int block_iter;
+	int start_iter;
+	int end_iter;
+	int n_to_scan = 0;
+	enum yaffs_block_state state;
+	int c;
+	int deleted;
+	LIST_HEAD(hard_list);
+	struct yaffs_block_info *bi;
+	u32 seq_number;
+	int n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
+	u8 *chunk_data;
+	int found_chunks;
+	int alloc_failed = 0;
+	struct yaffs_block_index *block_index = NULL;
+	int alt_block_index = 0;
+	int summary_available;
+
+	yaffs_trace(YAFFS_TRACE_SCAN,
+		"yaffs2_scan_backwards starts  intstartblk %d intendblk %d...",
+		dev->internal_start_block, dev->internal_end_block);
+
+	dev->seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;
+
+	block_index =
+		kmalloc(n_blocks * sizeof(struct yaffs_block_index), GFP_NOFS);
+
+	if (!block_index) {
+		block_index =
+		    vmalloc(n_blocks * sizeof(struct yaffs_block_index));
+		alt_block_index = 1;
 				}
 
+	if (!block_index) {
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			"yaffs2_scan_backwards() could not allocate block index!"
+			);
+		return YAFFS_FAIL;
 			}
 
-		}		/* End of scanning for each chunk */
+	dev->blocks_in_checkpt = 0;
+
+	chunk_data = yaffs_get_temp_buffer(dev);
 
-		if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {
-			/* If we got this far while scanning, then the block is fully allocated. */
-			state = YAFFS_BLOCK_STATE_FULL;
-		}
+	/* Scan all the blocks to determine their state */
+	bi = dev->block_info;
+	for (blk = dev->internal_start_block; blk <= dev->internal_end_block;
+	     blk++) {
+		yaffs_clear_chunk_bits(dev, blk);
+		bi->pages_in_use = 0;
+		bi->soft_del_pages = 0;
+
+		yaffs_query_init_block_state(dev, blk, &state, &seq_number);
 
 		bi->block_state = state;
+		bi->seq_number = seq_number;
+
+		if (bi->seq_number == YAFFS_SEQUENCE_CHECKPOINT_DATA)
+			bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
+		if (bi->seq_number == YAFFS_SEQUENCE_BAD_BLOCK)
+			bi->block_state = YAFFS_BLOCK_STATE_DEAD;
+
+		yaffs_trace(YAFFS_TRACE_SCAN_DEBUG,
+			"Block scanning block %d state %d seq %d",
+			blk, bi->block_state, seq_number);
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT) {
+			dev->blocks_in_checkpt++;
+
+		} else if (bi->block_state == YAFFS_BLOCK_STATE_DEAD) {
+			yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+				"block %d is bad", blk);
+		} else if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
+			yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "Block empty ");
+			dev->n_erased_blocks++;
+			dev->n_free_chunks += dev->param.chunks_per_block;
+		} else if (bi->block_state ==
+				YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			/* Determine the highest sequence number */
+			if (seq_number >= YAFFS_LOWEST_SEQUENCE_NUMBER &&
+			    seq_number < YAFFS_HIGHEST_SEQUENCE_NUMBER) {
+				block_index[n_to_scan].seq = seq_number;
+				block_index[n_to_scan].block = blk;
+				n_to_scan++;
+				if (seq_number >= dev->seq_number)
+					dev->seq_number = seq_number;
+			} else {
+				/* TODO: Nasty sequence number! */
+				yaffs_trace(YAFFS_TRACE_SCAN,
+					"Block scanning block %d has bad sequence number %d",
+					blk, seq_number);
+			}
+		}
+		bi++;
+	}
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "%d blocks to be sorted...", n_to_scan);
+
+	cond_resched();
+
+	/* Sort the blocks by sequence number */
+	sort(block_index, n_to_scan, sizeof(struct yaffs_block_index),
+		   yaffs2_ybicmp, NULL);
+
+	cond_resched();
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "...done");
+
+	/* Now scan the blocks looking at the data. */
+	start_iter = 0;
+	end_iter = n_to_scan - 1;
+	yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "%d blocks to scan", n_to_scan);
+
+	/* For each block.... backwards */
+	for (block_iter = end_iter;
+	     !alloc_failed && block_iter >= start_iter;
+	     block_iter--) {
+		/* Cooperative multitasking! This loop can run for so
+		   long that watchdog timers expire. */
+		cond_resched();
+
+		/* get the block to scan in the correct order */
+		blk = block_index[block_iter].block;
+		bi = yaffs_get_block_info(dev, blk);
+		deleted = 0;
+
+		summary_available = yaffs_summary_read(dev, dev->sum_tags, blk);
+
+		/* For each chunk in each block that needs scanning.... */
+		found_chunks = 0;
+		if (summary_available)
+			c = dev->chunks_per_summary - 1;
+		else
+			c = dev->param.chunks_per_block - 1;
+
+		for (/* c is already initialised */;
+		     !alloc_failed && c >= 0 &&
+		     (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
+		      bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING);
+		      c--) {
+			/* Scan backwards...
+			 * Read the tags and decide what to do
+			 */
+			if (yaffs2_scan_chunk(dev, bi, blk, c,
+					&found_chunks, chunk_data,
+					&hard_list, summary_available) ==
+					YAFFS_FAIL)
+				alloc_failed = 1;
+		}
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			/* If we got this far while scanning, then the block
+			 * is fully allocated. */
+			bi->block_state = YAFFS_BLOCK_STATE_FULL;
+		}
 
 		/* Now let's see if it was dirty */
 		if (bi->pages_in_use == 0 &&
@@ -1570,7 +1505,6 @@
 		    bi->block_state == YAFFS_BLOCK_STATE_FULL) {
 			yaffs_block_became_dirty(dev, blk);
 		}
-
 	}
 
 	yaffs_skip_rest_of_block(dev);
@@ -1582,12 +1516,12 @@
 
 	/* Ok, we've done all the scanning.
 	 * Fix up the hard link chains.
-	 * We should now have scanned all the objects, now it's time to add these
+	 * We have scanned all the objects, now it's time to add these
 	 * hardlinks.
 	 */
-	yaffs_link_fixup(dev, hard_list);
+	yaffs_link_fixup(dev, &hard_list);
 
-	yaffs_release_temp_buffer(dev, chunk_data, __LINE__);
+	yaffs_release_temp_buffer(dev, chunk_data);
 
 	if (alloc_failed)
 		return YAFFS_FAIL;
diff -uNrb linux-3.1.9/fs/yaffs2/yaffs_yaffs2.h linux-3.1.9-yaffs2/fs/yaffs2/yaffs_yaffs2.h
--- linux-3.1.9/fs/yaffs2/yaffs_yaffs2.h	2012-06-20 14:51:23.982803635 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yaffs_yaffs2.h	2012-06-28 16:54:39.723622580 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
diff -uNrb linux-3.1.9/fs/yaffs2/yportenv.h linux-3.1.9-yaffs2/fs/yaffs2/yportenv.h
--- linux-3.1.9/fs/yaffs2/yportenv.h	2012-06-20 14:51:23.982803635 -0600
+++ linux-3.1.9-yaffs2/fs/yaffs2/yportenv.h	2012-06-28 17:14:08.343665954 -0600
@@ -1,7 +1,7 @@
 /*
  * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
  *
- * Copyright (C) 2002-2010 Aleph One Ltd.
+ * Copyright (C) 2002-2011 Aleph One Ltd.
  *   for Toby Churchill Ltd and Brightstar Engineering
  *
  * Created by Charles Manning <charles@aleph1.co.uk>
@@ -13,10 +13,28 @@
  * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
  */
 
-#ifndef __YPORTENV_LINUX_H__
-#define __YPORTENV_LINUX_H__
+#ifndef __YPORTENV_H__
+#define __YPORTENV_H__
+
+/*
+ * Define the MTD version in terms of Linux Kernel versions
+ * This allows yaffs to be used independantly of the kernel
+ * as well as with it.
+ */
+
+#define MTD_VERSION(a, b, c) (((a) << 16) + ((b) << 8) + (c))
+
+#ifdef YAFFS_OUT_OF_TREE
+#include "moduleconfig.h"
+#endif
 
 #include <linux/version.h>
+#define MTD_VERSION_CODE LINUX_VERSION_CODE
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+#include <linux/version.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/sched.h>
@@ -31,6 +49,7 @@
 #include <linux/sort.h>
 #include <linux/bitops.h>
 
+/*  These type wrappings are used to support Unicode names in WinCE. */
 #define YCHAR char
 #define YUCHAR unsigned char
 #define _Y(x)     x
@@ -42,29 +61,22 @@
 #define YAFFS_ROOT_MODE			0755
 #define YAFFS_LOSTNFOUND_MODE		0700
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
 #define Y_CURRENT_TIME CURRENT_TIME.tv_sec
 #define Y_TIME_CONVERT(x) (x).tv_sec
+#else
+#define Y_CURRENT_TIME CURRENT_TIME
+#define Y_TIME_CONVERT(x) (x)
+#endif
 
 #define compile_time_assertion(assertion) \
 	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
 
 
-#ifndef Y_DUMP_STACK
-#define Y_DUMP_STACK() dump_stack()
-#endif
-
 #define yaffs_trace(msk, fmt, ...) do { \
-	if(yaffs_trace_mask & (msk)) \
+	if (yaffs_trace_mask & (msk)) \
 		printk(KERN_DEBUG "yaffs: " fmt "\n", ##__VA_ARGS__); \
-} while(0)
-
-#ifndef YBUG
-#define YBUG() do {\
-	yaffs_trace(YAFFS_TRACE_BUG,\
-		"bug " __FILE__ " %d",\
-		__LINE__);\
-	Y_DUMP_STACK();\
 } while (0)
-#endif
+
 
 #endif
diff -uNrb linux-3.1.9/fs/yaffs2/yportenv.h.orig linux-3.1.9-yaffs2/fs/yaffs2/yportenv.h.orig
--- linux-3.1.9/fs/yaffs2/yportenv.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.9-yaffs2/fs/yaffs2/yportenv.h.orig	2012-06-28 16:54:39.723622580 -0600
@@ -0,0 +1,20 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Waldemar Rymarkiewicz <waldemar.rymarkiewicz@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifdef YAFFS_CURRENT
+	#include "yportenv_single.h"
+#else
+	#include "yportenv_multi.h"
+#endif
diff -uNrb linux-3.1.9/fs/yaffs2/yportenv_multi.h linux-3.1.9-yaffs2/fs/yaffs2/yportenv_multi.h
--- linux-3.1.9/fs/yaffs2/yportenv_multi.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.9-yaffs2/fs/yaffs2/yportenv_multi.h	2012-06-28 16:54:39.723622580 -0600
@@ -0,0 +1,82 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YPORTENV_H__
+#define __YPORTENV_H__
+
+/*
+ * Define the MTD version in terms of Linux Kernel versions
+ * This allows yaffs to be used independantly of the kernel
+ * as well as with it.
+ */
+
+#define MTD_VERSION(a, b, c) (((a) << 16) + ((b) << 8) + (c))
+
+#ifdef YAFFS_OUT_OF_TREE
+#include "moduleconfig.h"
+#endif
+
+#include <linux/version.h>
+#define MTD_VERSION_CODE LINUX_VERSION_CODE
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/xattr.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/stat.h>
+#include <linux/sort.h>
+#include <linux/bitops.h>
+
+/*  These type wrappings are used to support Unicode names in WinCE. */
+#define YCHAR char
+#define YUCHAR unsigned char
+#define _Y(x)     x
+
+#define YAFFS_LOSTNFOUND_NAME		"lost+found"
+#define YAFFS_LOSTNFOUND_PREFIX		"obj"
+
+
+#define YAFFS_ROOT_MODE			0755
+#define YAFFS_LOSTNFOUND_MODE		0700
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+#define Y_CURRENT_TIME CURRENT_TIME.tv_sec
+#define Y_TIME_CONVERT(x) (x).tv_sec
+#else
+#define Y_CURRENT_TIME CURRENT_TIME
+#define Y_TIME_CONVERT(x) (x)
+#endif
+
+#define compile_time_assertion(assertion) \
+	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
+
+
+#define yaffs_trace(msk, fmt, ...) do { \
+	if (yaffs_trace_mask & (msk)) \
+		printk(KERN_DEBUG "yaffs: " fmt "\n", ##__VA_ARGS__); \
+} while (0)
+
+
+#endif
diff -uNrb linux-3.1.9/fs/yaffs2/yportenv_single.h linux-3.1.9-yaffs2/fs/yaffs2/yportenv_single.h
--- linux-3.1.9/fs/yaffs2/yportenv_single.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-3.1.9-yaffs2/fs/yaffs2/yportenv_single.h	2012-06-28 16:54:39.723622580 -0600
@@ -0,0 +1,62 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YPORTENV_LINUX_H__
+#define __YPORTENV_LINUX_H__
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/xattr.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/stat.h>
+#include <linux/sort.h>
+#include <linux/bitops.h>
+
+/*  These type wrappings are used to support Unicode names in WinCE. */
+#define YCHAR char
+#define YUCHAR unsigned char
+#define _Y(x)     x
+
+#define YAFFS_LOSTNFOUND_NAME		"lost+found"
+#define YAFFS_LOSTNFOUND_PREFIX		"obj"
+
+
+#define YAFFS_ROOT_MODE			0755
+#define YAFFS_LOSTNFOUND_MODE		0700
+
+#define Y_CURRENT_TIME CURRENT_TIME.tv_sec
+#define Y_TIME_CONVERT(x) (x).tv_sec
+
+#define compile_time_assertion(assertion) \
+	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
+
+#ifdef CONFIG_YAFFS_DEBUG
+#define yaffs_trace(msk, fmt, ...) do { \
+	if (yaffs_trace_mask & (msk)) \
+		printk(KERN_DEBUG "yaffs: " fmt "\n", ##__VA_ARGS__); \
+} while (0)
+#else
+#define yaffs_trace(msk, fmt, ...) do { \
+} while (0)
+#endif
+
+#endif
